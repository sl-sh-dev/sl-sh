//! Notes on how conversion works:
//!
//! # Accepting argumets
//! Check rust docs for [`SlFrom`], [`SlFromRef`], and [`SlFromRefMut`] to get a feel for
//! which rust types will work as parameters to the procedural macro.
//!
//! # Returning Arguments
//! [`SlInto`], [`SlIntoRef`], and [`SlIntoRefMut`] are all inverses of their respective from implementations
//! and are used to transform the rust types tha function return into slosh values from the procedural macro.
//!
//! # On accepting arguments from a dynamically typed language to a static one
//! Helper types in this crate like [`LooseString`] use the rust type system to model various slosh
//! types to avoid accepting a raw slosh [`Value`] as a parameter in the procedural macro. This is
//! not necessary, however, and should only be done if one finds oneself constantly accepting a
//! [`Value`] type in multiple procedural macro functions and functionally duplicating similar
//! parsing code.
//!
//! # On returning arguments from a statically typed language to a dynamically one
//! It is also possible to manually return a [`VMResult`] of [`Ok`]<[`Value`]> if the return
//! type of the function should not be bound by strict typing.
//!
//! # Borrowing and Mutable Borrowing when a rust type does not implement [`Copy`], demonstration with &str and &mut String
//!
//! [`SlAsRef`] and [`SlAsMut`] can be used to avoid cloning from the [`SloshVm`] into the scope of
//! function generated by the procedural macro but the traits must be structured properly.
//!
//!
//! ## For regular borrows, copy this pattern used for &str
//!
//! ```ignore
//!
//! impl<'a> SlFromRef<'a, Value> for &'a str {
//!     fn sl_from_ref(value: Value, vm: &'a SloshVm) -> VMResult<Self> {
//!         (&value).sl_as_ref(vm)
//!     }
//! }
//!
//! impl<'a> SlAsRef<'a, str> for &Value {
//!     fn sl_as_ref(&self, vm: &'a SloshVm) -> VMResult<&'a str> {
//!         match self {
//!             Value::String(h) => Ok(vm.get_string(*h)),
//!             Value::StringConst(i) => Ok(vm.get_interned(*i)),
//!             _ => Err(VMError::new_conversion(
//!                 ErrorStrings::fix_me_mismatched_type(
//!                     String::from(ValueTypes::from([
//!                         ValueType::String,
//!                         ValueType::StringConst,
//!                     ])),
//!                     self.display_type(vm),
//!                 ),
//!             )),
//!         }
//!     }
//! }
//! ```
//!
//!
//! # Mutale borrowing when a rust type does not implement copy
//!
//! ```ignore
//!
//! impl<'a> SlFromRefMut<'a, Value> for &'a mut String {
//!     fn sl_from_ref_mut(value: Value, vm: &'a mut SloshVm) -> VMResult<Self> {
//!         (&value).sl_as_mut(vm)
//!     }
//! }
//!
//! impl<'a> SlAsMut<'a, String> for &Value {
//!     fn sl_as_mut(&mut self, vm: &'a mut SloshVm) -> VMResult<&'a mut String> {
//!         match self {
//!             Value::String(h) => vm.get_string_mut(*h),
//!             _ => Err(VMError::new_conversion(
//!                 ErrorStrings::fix_me_mismatched_type(
//!                     <&'static str>::from(ValueType::String),
//!                     self.display_type(vm),
//!                 ),
//!             )),
//!         }
//!     }
//! }
//! ```
//!
//!
//!  # More explanation
//!     - this section needs more clarity on when users should worry about borrowing or not???
//!     - am i returning owned values? borrowed values?
//!     - how can i avoid needless cloning when going to/from rust/slosh boundary w/ procedural macro etc. etc.
//!     - To convert a rust value to a slosh type
//! `impl SlFrom<T> for Value { ... }`
//!     - To convert a slosh &Value to an owned type implement
//! `impl SlFromRef<'a, &Value> for RustType { ... }`
//!         this allows rust native functions annotated with the bridge macro to receive normal
//!         rust types.
//!     - To convert a slosh &Value to a mutable reference type implement.
//! `impl SlAsMut<&Value> for MutRefType { ... }`
//!     - To convert some rust type back to a value that the rust native function
//!         annotated by the bridge macro returns implement.
//! `impl SlFrom<&Value> for RustType { ... }`
//!
//!
//! TODO PC ISSUE #7 - returning values via annotated or lifetime?
//!  To avoid allocations when converting a slosh &Value back to a rust type that was mutated
//!  don't return anything. If it is necessary for the API to return some value.
//! ...either use an annotation on an input argument `fn myfun(#[likeThis] returnme: &mut String, someotherval: String) -> VMResult<()>`
//! or a lifetime... might be easier to do the annotation.
//!
//!
//! ** It is unclear to me if this table is has redundant information, might only be relevant for demonstration of how *String* works so we can see
//! how to borrow without cloning w/ the macro and for catch types like [`LooseString`], or maybe just make a marker trait for thoses?
//!
//! ## rosetta stone for bridge macros
//! Rust Type                   | Slosh Type & Traits   <br>&emsp; <br> S -> R Convert Slosh -> Rust <br> &emsp; - Occurs when coercing slush arguments to the parameter types in the signature of the annotated Rust function. <br> R -> S Convert Rust -> Slosh <br> &emsp; - Occurs when coercing some returned Rust type to a Slosh type. |
//! ----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|
//! [`String`]                  | [Value]`::String`           |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] [`String`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- [`SlFrom`] `&`[`Value`] for [`String`]
//!                             |                             |
//! `&`[`String`]               | [`Value`]`::String`         |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] `&`[`String`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- take [`String`]
//!                             |                             |     &emsp;* uses Clone unless TODO PC ISSUE #7 the extant value problem
//!                             |                             |
//! `&mut `[`String`]           | [`Value`]`::String`         |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlAsMut`] [`String`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- take `&mut `[`String`]
//!                             |                             |     &emsp;* uses Clone unless TODO PC ISSUE #7 the extant value problem
//!                             |                             |
//! `&`[`str`]                  | [`Value`]`::String` / [`Value`]`::StringConst` |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlAsRef`] &[`str`] for `&`[`Value`]
//!                             |                             |     &emsp;- [`SlIntoRef`] &[`str`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- [`SlFrom`] for [`Value`]
//!                             |                             |     &emsp;* uses Clone unless TODO PC ISSUE #7 - the extant value problem
//!                             |                             |     &emsp;- TODO PC ISSUE #7 adjacent is it even possible to call vm.alloc_string_ro on something that was *newly* created in the current fcn and returned as a RO value OR should that be made as a custom type so the user can declare their intent.
//!                             |                             |     &emsp;- TODO PC update, isn't this solved with SlAsRef/SlAsMut
//!                             |                             |
//! [`char`]                    | [`Value`]`::CodePoint`      |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] [`char`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- [`SlFrom`] `&`[`Value`] for [`char`]
//!                             |                             |
//! [SloshChar]               |  [`Value`]`::CharClusterLong` / [`Value`]`::CharCluster` / [`Value`]`::CodePoint` |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] [`SloshChar`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- [`SlFromRef`] `&`[`Value`] for [`SloshChar`]
//!                             |                             |
//! [`LooseString`]             | [`Value`]`::String` / [`Value`]`::CodePoint` / [`Value`]`::CharCluster` / [`Value`]`::CharClusterLong` / [`Value`]`::Symbol` / [`Value`]`::Keyword` / [`Value`]`::StringConst` |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] [`LooseString`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;* Note: Always does an allocation and returns a [`Value`]`::String` type.
//!                             |                             |     &emsp;- [`SlFromRef`] `&`[`Value`] for [`LooseString`]
//!                             |                             |
//! [`bool`]                    | [`Value`]::True / [`Value`]::False / [`Value`]::Nil |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] [`bool`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- [`SlFrom`] `&`[`Value`] for [`primitives`]
//!                             |                             |
//! [`u8`]                      | [`Value`]::Byte             |
//!                             |                             | S -> R
//!                             |                             |     &emsp;- [`SlIntoRef`] [`u8`] for `&`[`Value`]
//!                             |                             | R -> S
//!                             |                             |     &emsp;- [`SlFrom`] `&`[`Value`] for [`i8`]
//!                             |                             |
//! [`u32`]/[`i32`]/[`u64`]/[`i64`]/[`usize`]                             | [`Value`]::Int          |
//! TODO PC *current behavior overflows* |  [`Value`]::Int([[u8; 7]]), // Store a 7 byte int (i56...).                           |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//! [`f32`]/[`f64`]             | [`Value`]::Float(F56)       |                             |
//!                             |                             |
//!                             | [`Value`]::Pair(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::List(Handle, u16)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Vector(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Map(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Symbol(Interned)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Keyword(Interned)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Special(Interned) // Intended for symbols that are compiled.       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Builtin(u32)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Undefined       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Nil       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Bytes(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Lambda(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Closure(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Continuation(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::CallFrame(Handle)       |                             |
//!                             |                             |
//!                             |                             |
//!                             | [`Value`]::Error(Handle)       |                             |
//!                             |                             |
//!                             |                             |

use bridge_types::BridgedType;
#[cfg(doc)]
use bridge_types::{LooseString, SloshChar};
use compile_state::state::SloshVm;

use slvm::{VMResult, Value};
mod collections;
pub mod numbers;
pub mod primitives;
pub mod text;

/// Use mutable [`SloshVm`] to take a rust value and convert it to a [`BridgedType`].
pub trait SlFrom<T>: Sized
where
    Self: BridgedType,
{
    /// Converts to this type from the input type.
    fn sl_from(value: T, vm: &mut SloshVm) -> VMResult<Self>;
}

impl<T> SlFrom<Vec<T>> for Value
where
    T: SlInto<Value>,
{
    fn sl_from(value: Vec<T>, vm: &mut SloshVm) -> VMResult<Self> {
        let mut u = Vec::with_capacity(value.len());
        for v in value {
            u.push(v.sl_into(vm)?);
        }
        Ok(vm.alloc_vector(u))
    }
}

impl<'a, T> SlFromRef<'a, slvm::Value> for Vec<T>
where
    T: SlFromRef<'a, Value> + 'a,
{
    fn sl_from_ref(value: slvm::Value, vm: &'a SloshVm) -> VMResult<Self> {
        let mut res = vec![];
        for val in value.iter(vm) {
            let t: T = val.sl_into_ref(vm)?;
            res.push(t);
        }
        Ok(res)
    }
}

/// Inverse of [`SlFrom`]
pub trait SlInto<T>: Sized
where
    T: BridgedType,
{
    /// Converts this type into the (usually inferred) input type.
    fn sl_into(self, vm: &mut SloshVm) -> VMResult<T>;
}

impl<T, U> SlInto<U> for T
where
    U: SlFrom<T>,
{
    fn sl_into(self, vm: &mut SloshVm) -> VMResult<U> {
        U::sl_from(self, vm)
    }
}

pub trait SlFromRef<'a, T: BridgedType>
where
    Self: Sized,
{
    /// Converts to this type from the input type.
    fn sl_from_ref(value: T, vm: &'a SloshVm) -> VMResult<Self>;
}

/// Inverse of [`SlFromRef`]
pub trait SlIntoRef<'a, T>: Sized
where
    T: 'a,
    Self: BridgedType,
{
    /// Converts to this type from the input type.
    fn sl_into_ref(self, vm: &'a SloshVm) -> VMResult<T>;
}

impl<'a, T, U> SlIntoRef<'a, U> for T
where
    T: BridgedType,
    U: SlFromRef<'a, T>,
    U: 'a,
{
    fn sl_into_ref(self, vm: &'a SloshVm) -> VMResult<U> {
        U::sl_from_ref(self, vm)
    }
}

pub trait SlFromRefMut<'a, T: BridgedType>
where
    Self: Sized,
{
    /// Converts to this type from the input type.
    fn sl_from_ref_mut(value: T, vm: &'a mut SloshVm) -> VMResult<Self>;
}

/// Inverse of [`SlFromRefMut`]
pub trait SlIntoRefMut<'a, T>: Sized
where
    T: 'a,
    Self: BridgedType,
{
    /// Converts to this type from the input type.
    fn sl_into_ref_mut(self, vm: &'a mut SloshVm) -> VMResult<T>;
}

impl<'a, T, U> SlIntoRefMut<'a, U> for T
where
    T: BridgedType,
    U: SlFromRefMut<'a, T>,
    U: 'a,
{
    fn sl_into_ref_mut(self, vm: &'a mut SloshVm) -> VMResult<U> {
        U::sl_from_ref_mut(self, vm)
    }
}

/// Converts a [`BridgedType`] to some rust type
pub trait SlAsRef<'a, T: ?Sized>
where
    Self: BridgedType,
{
    /// Converts this type into a shared reference of the (usually inferred) input type.
    fn sl_as_ref(&self, vm: &'a SloshVm) -> VMResult<&'a T>;
}

// SlAsRef lifts over &
impl<'a, T: ?Sized, U: ?Sized> SlAsRef<'a, U> for &'a T
where
    T: SlAsRef<'a, U>,
    &'a T: BridgedType,
{
    #[inline]
    fn sl_as_ref(&self, vm: &'a SloshVm) -> VMResult<&'a U> {
        <T as SlAsRef<'a, U>>::sl_as_ref(*self, vm)
    }
}

// SlAsRef lifts over &mut
impl<'a, T: ?Sized, U: ?Sized> SlAsRef<'a, U> for &'a mut T
where
    T: SlAsRef<'a, U> + BridgedType,
    &'a mut T: BridgedType,
{
    #[inline]
    fn sl_as_ref(&self, vm: &'a SloshVm) -> VMResult<&'a U> {
        <T as SlAsRef<'a, U>>::sl_as_ref(*self, vm)
    }
}

pub trait SlAsMut<'a, T: ?Sized>
where
    Self: BridgedType,
{
    /// Converts this type into a mutable reference of the (usually inferred) input type.
    fn sl_as_mut(&mut self, vm: &'a mut SloshVm) -> VMResult<&'a mut T>;
}

// SlAsMut lifts over &mut
impl<'a, T: ?Sized, U: ?Sized> SlAsMut<'a, U> for &'a mut T
where
    T: SlAsMut<'a, U>,
    &'a mut T: BridgedType,
{
    #[inline]
    fn sl_as_mut(&mut self, vm: &'a mut SloshVm) -> VMResult<&'a mut U> {
        (*self).sl_as_mut(vm)
    }
}

impl SlFrom<Value> for Value {
    fn sl_from(value: Value, _vm: &mut SloshVm) -> VMResult<Self> {
        Ok(value)
    }
}
