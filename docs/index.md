---
layout: default
title: sl-sh form documentation
---

# Sl-sh form documentation

## Vector forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | vec-insert-nth! | Function<br> | root<br><br> | (vec-insert-nth! index new-element vector)<br><br>Inserts new-element at index and moves following elements right in vector.  This is destructive!<br><br> | (def 'test-insert-nth-vec (vec 1 2 3))<br>(test::assert-equal '(1 2 3) test-insert-nth-vec)<br>(vec-insert-nth! 1 5 test-insert-nth-vec)<br>(test::assert-equal '(1 5 2 3) test-insert-nth-vec)<br>(vec-insert-nth! 2 6 test-insert-nth-vec)<br>(test::assert-equal '(1 5 6 2 3) test-insert-nth-vec)<br>(vec-insert-nth! 0 4 test-insert-nth-vec)<br>(test::assert-equal '(4 1 5 6 2 3) test-insert-nth-vec) | 
 | vec-clear! | Function<br> | root<br><br> | (vec-clear! vector)<br><br>Clears a vector.  This is destructive!<br><br> | (def 'test-clear-vec (vec 1 2 3))<br>(test::assert-false (vec-empty? test-clear-vec))<br>(vec-clear! test-clear-vec)<br>(test::assert-true (vec-empty? test-clear-vec)) | 
 | vec-slice | Function<br> | root<br><br> | (vec-slice vector start end?)<br><br>Returns a slice of a vector (0 based indexes, end is exclusive).<br><br> | (test::assert-equal '(5 6) (vec-slice '#(1 2 3 4 5 6) 4 6))<br>(test::assert-equal '(1 2 3) (vec-slice '#(1 2 3 4 5 6) 0 3))<br>(test::assert-equal '(3 4 5) (vec-slice '#(1 2 3 4 5 6) 2 5))<br>(test::assert-equal '(3 4 5 6) (vec-slice '#(1 2 3 4 5 6) 2)) | 
 | vec-setnth! | Function<br> | root<br><br> | (vec-setnth! index value vector)<br><br>Set the nth index (0 based) of a vector to value.  This is destructive!<br><br> | (def 'test-setnth-vec (vec 1 2 3))<br>(test::assert-equal '(1 5 3) (vec-setnth! 1 5 test-setnth-vec))<br>(test::assert-equal '(7 5 3) (vec-setnth! 0 7 test-setnth-vec))<br>(test::assert-equal '(7 5 9) (vec-setnth! 2 9 test-setnth-vec)) | 
 | vec-remove-nth! | Function<br> | root<br><br> | (vec-remove-nth! index vector)<br><br>Remove the element at index from vector.  This is destructive!<br><br> | (def 'test-remove-nth-vec (vec 1 2 3))<br>(test::assert-equal '(1 2 3) test-remove-nth-vec)<br>(vec-remove-nth! 1 test-remove-nth-vec)<br>(test::assert-equal '(1 3) test-remove-nth-vec)<br>(vec-remove-nth! 1 test-remove-nth-vec)<br>(test::assert-equal '(1) test-remove-nth-vec)<br>(vec-remove-nth! 0 test-remove-nth-vec)<br>(test::assert-equal '() test-remove-nth-vec) | 
 | vec-push! | Function<br> | root<br><br> | (vec-push! vector object)<br><br>Pushes the provided object onto the end of the vector.  This is destructive!<br><br> | (def 'test-push-vec (vec))<br>(test::assert-equal '(1) (vec-push! test-push-vec 1))<br>(test::assert-equal '(1) test-push-vec)<br>(test::assert-equal '(1 2) (vec-push! test-push-vec 2))<br>(test::assert-equal '(1 2) test-push-vec)<br>(test::assert-equal '(1 2 3) (vec-push! test-push-vec 3))<br>(test::assert-equal '(1 2 3) test-push-vec) | 
 | vec-empty? | Function<br> | root<br><br> | (vec-empty? vector)<br><br>True if the vector is empty.<br><br> | (test::assert-true (vec-empty? '#()))<br>(test::assert-false (vec-empty? '#(1 2 3))) | 
 | vec | Function<br> | root<br><br> | (vec item1 item2 .. itemN)<br><br>Make a new vector with items.<br><br> | (test::assert-false (vec))<br>(test::assert-equal '(1 2 3) (vec 1 2 3)) | 
 | vec-nth | Function<br> | root<br><br> | (vec-nth index vector)<br><br>Get the nth element (0 based) of a vector.<br><br> | (test::assert-equal 5 (vec-nth 4 '#(1 2 3 4 5 6)))<br>(test::assert-equal 1 (vec-nth 0 '#(1 2 3 4 5 6)))<br>(test::assert-equal 3 (vec-nth 2 '#(1 2 3 4 5 6)))<br>(test::assert-equal 6 (vec-nth 5 '#(1 2 3 4 5 6))) | 
 | vec-pop! | Function<br> | root<br><br> | (vec-pop! vector object)<br><br>Pops the last object off of the end of the vector.  This is destructive!<br><br> | (def 'test-pop-vec (vec 1 2 3))<br>(test::assert-equal 3 (vec-pop! test-pop-vec))<br>(test::assert-equal '(1 2) test-pop-vec)<br>(test::assert-equal 2 (vec-pop! test-pop-vec))<br>(test::assert-equal '(1) test-pop-vec)<br>(test::assert-equal 1 (vec-pop! test-pop-vec))<br>(test::assert-equal '() test-pop-vec) | 
 | make-vec | Function<br> | root<br><br> | (make-vec capacity default)<br><br>Make a new vector with capacity and default item(s).<br><br> | (test::assert-false (make-vec))<br>(test::assert-equal '(x x x) (make-vec 3 'x))<br>(test::assert-equal '(nil nil nil nil nil) (make-vec 5 nil))<br>(test::assert-equal '() (make-vec 5)) | 

## Namespace forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | ns-pop | Function<br> | root<br><br> | (ns-pop)<br><br>Returns to the previous namespace.<br><br> | (ns-create 'ns-pop-test-namespace)<br>(test::assert-equal "ns-pop-test-namespace" *ns*)<br>(ns-pop)<br>(test::assert-not-equal "ns-pop-test-namespace" *ns*) | 
 | ns-exists? | Function<br> | root<br><br> | (ns-exists? namespace)<br><br>True if the supplied namespace exists (must evaluate to a string or symbol).<br><br> | (test::assert-false (ns-exists? 'ns-exists-test-namespace))<br>(ns-create 'ns-exists-test-namespace)<br>(ns-pop)<br>(test::assert-true (ns-exists? 'ns-exists-test-namespace)) | 
 | ns-symbols | Function<br> | root<br><br> | (ns-symbols namespace)<br><br>Returns the list of all symbols in namespace (must evaluate to a string or symbol).<br><br> | (test::assert-not-includes 'dumb-symbol-xxx (ns-symbols 'core))<br>(test::assert-includes 'loop (ns-symbols 'core))<br>(test::assert-not-includes 'dumb-symbol-xxx (ns-symbols 'root))<br>(test::assert-includes 'car (ns-symbols 'root))<br>t | 
 | ns-create | Function<br> | root<br><br> | (ns-create namespace)<br><br>Creates and enters a new a namespace (must evaluate to a string or symbol).<br><br> | (ns-create 'ns-create-test-namespace)<br>(def 'test-symbol "testing")<br>(test::assert-equal "testing" test-symbol)<br>(ns-pop)<br>(test::assert-false (def? 'test-symbol)) | 
 | ns-list | Function<br> | root<br><br> | (ns-list)<br><br>Returns a vector of all namespaces.<br><br> | (test::assert-not-includes "ns-list-test-namespace" (ns-list))<br>(ns-create 'ns-list-test-namespace)<br>(ns-pop)<br>(test::assert-includes "ns-list-test-namespace" (ns-list))<br>t | 
 | ns-enter | Function<br> | root<br><br> | (ns-enter namespace)<br><br>Enters an existing namespace (must evaluate to a string or symbol).<br><br> | (ns-create 'ns-enter-test-namespace)<br>(def 'test-symbol "testing")<br>(test::assert-equal "testing" test-symbol)<br>(ns-pop)<br>(test::assert-false (def? 'test-symbol))<br>(ns-enter 'ns-enter-test-namespace)<br>(test::assert-true (def? 'test-symbol))<br>(test::assert-equal "testing" test-symbol)<br>(ns-pop)<br>t | 

## Uncategorized forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | *load-path* | Vector<br> | root<br><br> |   | ;(set '*load-path '("/path"))<br>;(load "script-in-path")<br>t | 
 | *stdout* | File<br> | root<br><br> |   | ; Use a file for stdout for test.<br>(dyn '*stdout* (open "/tmp/sl-sh.stdout.test" :create :truncate) (write-line *stdout* "Test out"))<br>(test::assert-equal "Test out<br>" (read-line (open "/tmp/sl-sh.stdout.test" :read))) | 
 | *stdin* | File<br> | root<br><br> |   | (def 'stdin-test (open "/tmp/sl-sh.stdin.test" :create :truncate))<br>(write-line stdin-test "Test line")<br>(close stdin-test)<br>; Use a file for stdin for test.<br>(dyn '*stdin* (open "/tmp/sl-sh.stdin.test" :read) (test::assert-equal "Test line<br>" (read-line *stdin*))) | 
 | *stderr* | File<br> | root<br><br> |   | ; Use a file for stderr for test.<br>(dyn '*stderr* (open "/tmp/sl-sh.stderr.test" :create :truncate) (write-line *stderr* "Test Error"))<br>(test::assert-equal "Test Error<br>" (read-line (open "/tmp/sl-sh.stderr.test" :read))) | 
 | alias | Macro<br> | shell<br><br> |   |   | 
 | register-alias | Lambda<br> | shell<br><br> |   |   | 
 | unregister-alias | Lambda<br> | shell<br><br> |   |   | 
 | alias? | Lambda<br> | shell<br><br> |   |   | 
 | out>> | Macro<br> | shell<br><br> |   |   | 
 | out> | Macro<br> | shell<br><br> |   |   | 
 | err>> | Macro<br> | shell<br><br> |   |   | 
 | err> | Macro<br> | shell<br><br> |   |   | 
 | out-err>> | Macro<br> | shell<br><br> |   |   | 
 | out-err> | Macro<br> | shell<br><br> |   |   | 
 | out>null | Macro<br> | shell<br><br> |   |   | 
 | err>null | Macro<br> | shell<br><br> |   |   | 
 | out-err>null | Macro<br> | shell<br><br> |   |   | 
 | \| | Macro<br> | shell<br><br> |   |   | 
 | pushd | Lambda<br> | shell<br><br> |   |   | 
 | popd | Lambda<br> | shell<br><br> |   |   | 
 | dirs | Lambda<br> | shell<br><br> |   |   | 
 | get-dirs | Lambda<br> | shell<br><br> |   |   | 
 | clear-dirs | Lambda<br> | shell<br><br> |   |   | 
 | set-dirs-max | Lambda<br> | shell<br><br> |   |   | 
 | let-env | Macro<br> | shell<br><br> |   |   | 
 | sys-command? | Lambda<br> | shell<br><br> |   |   | 
 | syntax-on | Macro<br> | shell<br><br> |   |   | 
 | syntax-off | Macro<br> | shell<br><br> |   |   | 
 | seq? | Lambda<br> | core<br><br> |   | (test::assert-true (seq? '(1 2 3)))<br>(test::assert-true (seq? '#(1 2 3)))<br>(test::assert-true (seq? '()))<br>(test::assert-true (seq? '#()))<br>(test::assert-false (seq? "aaa"))<br>(test::assert-false (seq? 1)) | 
 | non-empty-seq? | Lambda<br> | core<br><br> |   |   | 
 | empty-seq? | Lambda<br> | core<br><br> |   |   | 
 | first | Lambda<br> | core<br><br> |   |   | 
 | rest | Lambda<br> | core<br><br> |   |   | 
 | last | Lambda<br> | core<br><br> |   |   | 
 | butlast | Lambda<br> | core<br><br> |   |   | 
 | setnth! | Lambda<br> | core<br><br> |   |   | 
 | nth | Lambda<br> | core<br><br> |   |   | 
 | append | Lambda<br> | core<br><br> |   |   | 
 | append! | Macro<br> | core<br><br> |   |   | 
 | map | Lambda<br> | core<br><br> |   |   | 
 | map! | Lambda<br> | core<br><br> |   |   | 
 | reverse | Lambda<br> | core<br><br> |   |   | 
 | reverse! | Lambda<br> | core<br><br> |   |   | 
 | in? | Lambda<br> | core<br><br> |   | ;; check list contains in? fcn<br>(let ((vowels-list (list 'a 'e 'i 'o 'u)))<br>    (assert-true (in? vowels-list 'u))<br>    (assert-false (in? vowels-list 'c))) | 
 | qsort | Lambda<br> | core<br><br> |   | (test::assert-equal '(1 2 3) (qsort '(2 3 1)))<br>(test::assert-equal '(1 2 3) (qsort '#(2 3 1)))<br>(test::assert-equal '(3 2 1) (qsort '(2 3 1) >))<br>(test::assert-equal '(3 2 1) (qsort '#(2 3 1) (fn (a b) (< b a))))<br>(test::assert-equal '("aaa" "aab" "aba" "baa" "bab" "ccc")<br>    (qsort '("aaa" "aab" "aba" "baa" "bab" "ccc")))<br>(test::assert-equal '("aaa" "aab" "aba" "baa" "bab" "ccc")<br>    (qsort '("ccc" "bab" "baa" "aba" "aab" "aaa")))<br>(test::assert-equal '("aaa" "aab" "aba" "baa" "bab" "ccc")<br>    (qsort '("aba" "bab" "aab" "ccc" "baa" "aaa")))<br>(test::assert-equal '("ccc" "bab" "baa" "aba" "aab" "aaa")<br>    (qsort '("aba" "bab" "aab" "ccc" "baa" "aaa") >))<br>(test::assert-equal '("ccc" "bab" "baa" "aba" "aab" "aaa")<br>    (qsort '("aba" "bab" "aab" "ccc" "baa" "aaa") (fn (a b) (> a b))))<br>(test::assert-equal '() (qsort '()))<br>(test::assert-equal '() (qsort '#()))<br>(test::assert-equal '#() (qsort '()))<br>(test::assert-equal '#() (qsort '#())) | 
 | defmacro | Macro<br> | core<br><br> |   |   | 
 | setmacro | Macro<br> | core<br><br> |   |   | 
 | ns-export | Macro<br> | core<br><br> |   |   | 
 | ns-import | Macro<br> | core<br><br> |   |   | 
 | setq | Macro<br> | core<br><br> |   |   | 
 | defq | Macro<br> | core<br><br> |   |   | 
 | defn | Macro<br> | core<br><br> |   |   | 
 | setfn | Macro<br> | core<br><br> |   |   | 
 | loop | Macro<br> | core<br><br> |   |   | 
 | dotimes | Macro<br> | core<br><br> |   |   | 
 | dotimesi | Macro<br> | core<br><br> |   |   | 
 | for | Macro<br> | core<br><br> |   |   | 
 | fori | Macro<br> | core<br><br> |   |   | 
 | match | Macro<br> | core<br><br> |   |   | 
 | let | Macro<br> | core<br><br> |   |   | 
 | copy-seq | Lambda<br> | core<br><br> |   |   | 
 | reduce | Lambda<br> | core<br><br> |   | (assert-true (= 15 (reduce + 0 (list 1 2 3 4 5))))<br>(assert-false (= 15 (reduce + 1 (list 1 2 3 4 5))))<br>(assert-true (= "one hoopy frood" (reduce str "" (list "one " "hoopy " "frood")))) | 
 | when | Macro<br> | core<br><br> |   | (assert-true (when #t #t))<br>(assert-false (when #t nil))<br>(assert-false (when nil nil)) | 
 | filter | Lambda<br> | core<br><br> |   | (assert-equal '(2 4) (filter (fn (x) (= (% x 2) 0)) (list 1 2 3 4 5))) | 
 | func? | Macro<br> | core<br><br> |   |   | 

## Unknown forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | macro | Function<br> | root<br><br> | (macro (x) (+ x x))<br>Define a macro. You probably only want to use defmacro or fn instead.<br><br> |   | 
 | wait | Function<br> | root<br><br> | (wait proc-to-wait-for)<br><br>Wait for a process to end and return it's exit status.<br><br> |   | 
 | fs-exists? | Function<br> | root<br><br> | (fs-exists? path-to-test)<br><br>Does the given path exist?<br><br> |   | 
 | glob | Function<br> | root<br><br> | (glob /path/with/*)<br><br>Takes a list/varargs of globs and return the list of them expanded.<br><br> |   | 
 | pipe | Function<br> | root<br><br> | (pipe (proc-whose-stdout) (is-inpup-here))<br><br>Setup a pipe between processes.<br><br> |   | 
 | cd | Function<br> | root<br><br> | (cd dir-to-change-to)<br><br>Change directory.<br><br> |   | 
 | pid | Function<br> | root<br><br> | (pid proc)<br><br>Return the pid of a process.<br><br> |   | 
 | fs-dir? | Function<br> | root<br><br> | (fs-dir? path-to-test)<br><br>Is the given path a directory?<br><br> |   | 
 | fn | SpecialForm<br> | root<br><br> | (fn (x) (x + 1))<br><br>Create a function (lambda).<br><br> |   | 
 | fs-file? | Function<br> | root<br><br> | (fs-file? path-to-test)<br><br>Is the given path a file?<br><br> |   | 
 | recur | Function<br> | root<br><br> | (recur &rest)<br><br> |   | 
 | fg-color-rgb | Lambda<br> | shell<br><br><br> | (fg-color-rgb red-val green-val blue-val)<br><br>Set the foreground color to the desired rgb where each arg is an integer between 0 and<br>255 inclusive.<br><br> |   | 
 | bg-color-rgb | Lambda<br> | shell<br><br><br> | (bg-color-rgb red-val green-val blue-val)<br><br>Set the background color to the desired rgb where each arg is an integer between 0 and<br>255 inclusive.<br><br> |   | 
 | endfix-on | Macro<br> | shell<br><br> | (endfix-on)<br><br><br>	Allows use of infix notation for common shell forms. The following is the<br>	complete mapping in lisp/endfix.lisp of all supported infix operators and<br>	the corresponding sl-sh function they map to:<br>		'|| 'or<br>		'| '|<br>		'@@ 'progn (@@ is used instead of ; because ; is a comment in lisp)<br>		'&& 'and<br>		'out> 'out><br>		'out>> 'out>><br>		'err> 'err><br>		'err>> 'err>><br>		'out>null 'out>null<br>		'out-err> 'out-err><br>		'out-err>> 'out-err>><br>		'out-err>null 'out-err>null<br><br><br> |   | 

## Math forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | / | Function<br> | root<br><br> | (/ number+)<br><br>Divide a sequence of numbers.  Requires at least two numbers.<br><br> | (test::assert-equal 5 (/ 50 10))<br>(test::assert-equal 5 (/ 50.0 10.0))<br>(test::assert-equal 0 (/ 1 5))<br>(test::assert-equal .2 (/ 1.0 5))<br>(test::assert-equal .2 (/ 1.0 5.0))<br>(test::assert-equal 5.5 (/ 5.5 1))<br>(test::assert-equal 2 (/ 16 2 4))<br>(test::assert-equal 5 (/ 100 2 5 2)) | 
 | - | Function<br> | root<br><br> | (- number+)<br><br>Subtract a sequence of numbers.<br><br> | (test::assert-equal 5 (- 5))<br>(test::assert-equal 5 (- 5.0))<br>(test::assert-equal -4 (- 1 5))<br>(test::assert-equal -4.5 (- 1 5.5))<br>(test::assert-equal 4 (- 10 2 4))<br>(test::assert-equal 4.9 (- 10.9 2 4)) | 
 | * | Function<br> | root<br><br> | (* number+)<br><br>Multiply a sequence of numbers.<br><br> | (test::assert-equal 5 (* 5))<br>(test::assert-equal 5 (* 1 5))<br>(test::assert-equal 5.0 (* 1.0 5))<br>(test::assert-equal 7.5 (* 1.5 5))<br>(test::assert-equal 7.5 (* 1.5 5.0))<br>(test::assert-equal 15 (* 3 5))<br>(test::assert-equal 8 (* 1 2 4))<br>(test::assert-equal 16 (* 2 2 4))<br>(test::assert-equal 16.0 (* 2 2.0 4))<br>(test::assert-equal 16.0 (* 2.0 2.0 4.0)) | 
 | + | Function<br> | root<br><br> | (+ number+)<br><br>Add a sequence of numbers.<br><br> | (test::assert-equal 5 (+ 5))<br>(test::assert-equal 5 (+ 5.0))<br>(test::assert-equal 6 (+ 1 5))<br>(test::assert-equal 6.5 (+ 1 5.5))<br>(test::assert-equal 7 (+ 1 2 4)) | 
 | % | Function<br> | root<br><br> | (% int int)<br><br>Remainder from dividing first int by the second.<br><br> | (test::assert-equal 0 (% 50 10))<br>(test::assert-equal 5 (% 55 10))<br>(test::assert-equal 1 (% 1 2)) | 

## Hashmap forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | hash-get | Function<br> | root<br><br> | (hash-get hashmap key)<br><br>Get a value for a key from a hashmap.<br><br> | (def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :key1))<br>(test::assert-equal "val two" (hash-get tst-hash 'key2))<br>(test::assert-equal "val three" (hash-get tst-hash "key3")) | 
 | hash-clear! | Function<br> | root<br><br> | (hash-clear! hashmap)<br><br>Clears a hashmap.  This is a destructive form!<br><br> | (def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-true (hash-haskey tst-hash :key1))<br>(test::assert-true (hash-haskey tst-hash 'key2))<br>(test::assert-true (hash-haskey tst-hash "key3"))<br>(hash-clear! tst-hash)<br>(test::assert-equal 0 (length (hash-keys tst-hash)))<br>(test::assert-false (hash-haskey tst-hash :key1))<br>(test::assert-false (hash-haskey tst-hash 'key2))<br>(test::assert-false (hash-haskey tst-hash "key3")) | 
 | hash-haskey | Function<br> | root<br><br> | (hash-haskey hashmap key)<br><br>Checks if a key is in a hashmap.<br><br> | (def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-true (hash-haskey tst-hash :key1))<br>(test::assert-true (hash-haskey tst-hash 'key2))<br>(test::assert-true (hash-haskey tst-hash "key3"))<br>(test::assert-false (hash-haskey tst-hash 'key1))<br>(test::assert-false (hash-haskey tst-hash :key2))<br>(test::assert-false (hash-haskey tst-hash "keynone"))<br>(hash-remove! tst-hash :key1)<br>(test::assert-false (hash-haskey tst-hash :key1))<br>(hash-set! tst-hash :key1 "val one b")<br>(test::assert-true (hash-haskey tst-hash :key1)) | 
 | make-hash | Function<br> | root<br><br> | (make-hash associations?)<br><br>Make a new hash map.<br><br>If associations is provided (makes an empty map if not) then it is a list of<br>pairs (key . value) that populate the intial map.<br><br> | (def 'tst-hash (make-hash))<br>(test::assert-equal 0 (length (hash-keys tst-hash)))<br>(def 'tst-hash (make-hash ()))<br>(test::assert-equal 0 (length (hash-keys tst-hash)))<br>(def 'tst-hash (make-hash nil))<br>(test::assert-equal 0 (length (hash-keys tst-hash)))<br>(def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :key1))<br>(test::assert-equal "val two" (hash-get tst-hash 'key2))<br>(test::assert-equal "val three" (hash-get tst-hash "key3"))<br>(def 'tst-hash (make-hash '#((:keyv1 . "val one")(keyv2 . "val two")("keyv3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :keyv1))<br>(test::assert-equal "val two" (hash-get tst-hash 'keyv2))<br>(test::assert-equal "val three" (hash-get tst-hash "keyv3")) | 
 | hash-keys | Function<br> | root<br><br> | (hash-keys hashmap)<br><br>Returns a vector of all the hashmaps keys.  The keys will be unordered.<br><br> | (def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-true (in? (hash-keys tst-hash) :key1) "Test :key1")<br>(test::assert-true (in? (hash-keys tst-hash) 'key2) "Test key2")<br>; Note string used as a key will be a symbol in the hash-keys list...<br>(test::assert-true (in? (hash-keys tst-hash) 'key3) "Test key3")<br>(test::assert-false (in? (hash-keys tst-hash) :key4)) | 
 | hash-remove! | Function<br> | root<br><br> | (hash-remove! hashmap key)<br><br>Remove a key from a hashmap.  This is a destructive form!<br><br> | (def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :key1))<br>(test::assert-equal "val two" (hash-get tst-hash 'key2))<br>(test::assert-equal "val three" (hash-get tst-hash "key3"))<br>(hash-remove! tst-hash 'key2)<br>(test::assert-equal 2 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :key1))<br>(test::assert-equal "val three" (hash-get tst-hash "key3"))<br>(hash-remove! tst-hash :key1)<br>(test::assert-equal 1 (length (hash-keys tst-hash)))<br>(test::assert-equal "val three" (hash-get tst-hash "key3"))<br>(hash-remove! tst-hash "key3")<br>(test::assert-equal 0 (length (hash-keys tst-hash))) | 
 | hash-set! | Function<br> | root<br><br> | (hash-set! hashmap key value)<br><br>Add or update a hashmap key's value.  This is a destructive form!<br><br> | (def 'tst-hash (make-hash))<br>(test::assert-equal 0 (length (hash-keys tst-hash)))<br>(hash-set! tst-hash :new-key '(1 2 3))<br>(test::assert-equal 1 (length (hash-keys tst-hash)))<br>(test::assert-equal '(1 2 3) (hash-get tst-hash :new-key))<br>(def 'tst-hash (make-hash '((:key1 . "val one")(key2 . "val two")("key3" . "val three"))))<br>(test::assert-equal 3 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :key1))<br>(test::assert-equal "val two" (hash-get tst-hash 'key2))<br>(test::assert-equal "val three" (hash-get tst-hash "key3"))<br>(hash-set! tst-hash :new-key '(1 2 3))<br>(test::assert-equal 4 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one" (hash-get tst-hash :key1))<br>(test::assert-equal "val two" (hash-get tst-hash 'key2))<br>(test::assert-equal "val three" (hash-get tst-hash "key3"))<br>(test::assert-equal '(1 2 3) (hash-get tst-hash :new-key))<br>(hash-set! tst-hash 'key2 "val two b")<br>(hash-set! tst-hash :key1 "val one b")<br>(hash-set! tst-hash "key3" "val three b")<br>(test::assert-equal 4 (length (hash-keys tst-hash)))<br>(test::assert-equal "val one b" (hash-get tst-hash :key1))<br>(test::assert-equal "val two b" (hash-get tst-hash 'key2))<br>(test::assert-equal "val three b" (hash-get tst-hash "key3"))<br>(test::assert-equal '(1 2 3) (hash-get tst-hash :new-key)) | 

## Shell forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | exit | Function<br> | root<br><br> | (exit code?)<br><br>Exit shell with optional status code.<br><br> | ;(exit)<br>;(exit 0)<br>t | 
 | fg | Function<br> | root<br><br> | (fg job-id?)<br><br>Put a job in the foreground.<br><br>If no job id is specified use the last job.<br><br> | ;(fg)<br>t | 
 | version | Function<br> | root<br><br> | (version)<br><br>Produce executable version as string.<br><br> | (test::assert-true (string? (version))) | 
 | form | SpecialForm<br> | root<br><br> | (form exp0 ... expN)<br><br>Like progn but do not execute system commands within this form.<br><br> | (test::assert-equal '#(:error "Not a valid form true, not found.") (get-error (form (true))))<br>(test::assert-equal "Some String" (form (str "Some String"))) | 
 | bg | Function<br> | root<br><br> | (bg job-id?)<br><br>Put a job in the background.<br><br>If no job id is specified use the last job.<br><br> | ;(bg)<br>t | 
 | jobs | Function<br> | root<br><br> | (jobs)<br><br>Print list of jobs with ids.<br><br> | ;(jobs)<br>t | 
 | unexport | Function<br> | root<br><br> | (unexport symbol)<br><br>Remove a var from the current shell environment.<br><br> | (test::assert-equal "ONE" (export 'TEST_EXPORT_ONE "ONE"))<br>(test::assert-equal "ONE"  'TEST_EXPORT_ONE)<br>(test::assert-false  | 
 | loose-symbols | SpecialForm<br> | root<br><br> | (loose-symbols exp0 ... expN)<br><br>Within this form any undefined symbols become strings.<br><br> | (test::assert-equal "Some_Result" (loose-symbols Some_Result)) | 
 | command | SpecialForm<br> | root<br><br> | (command exp0 ... expN)<br><br>Only execute system commands not forms within this form.<br><br> | (test::assert-equal '#(:error "Failed to execute [str string]: No such file or directory (os error 2)") (get-error (command (str "string"))))<br>(test::assert-equal "Some String<br>" (str (command (echo "Some String")))) | 
 | run-bg | SpecialForm<br> | root<br><br> | (run-bg exp0 ... expN)<br><br>Like progn except any system commands started within form will be in the background.<br><br> | ;(run-bg gitk)<br>t | 
 | export | Function<br> | root<br><br> | (export symbol string) -> string<br><br>Export a key and value to the shell environment.  Second arg will be made a string and returned.<br><br> | (test::assert-equal "ONE" (export 'TEST_EXPORT_ONE "ONE"))<br>(test::assert-equal "ONE"  | 

## Core forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | eval | Function<br> | root<br><br> | (eval expression)<br><br>Evalute the provided expression.<br><br>If expression is a string read it to make an ast first to evaluate otherwise<br>evaluate the expression (note eval is a function not a special form, the<br>provided expression will be evaluated as part of call).<br><br> | (def 'test-eval-one nil)<br>(eval "(set 'test-eval-one \"ONE\")")<br>(test::assert-equal "ONE" test-eval-one)<br>(eval '(set 'test-eval-one "TWO"))<br>(test::assert-equal "TWO" test-eval-one) | 
 | load | Function<br> | root<br><br> | (load path) -> [last form value]<br><br>Read and eval a file (from path- a string).<br><br> | (def 'test-load-one nil)<br>(def 'test-load-two nil)<br>(write-line (open "/tmp/slsh-test-load.testing" :create :truncate) "(set 'test-load-one \"LOAD TEST\") '(1 2 3)")<br>(set 'test-load-two (load "/tmp/slsh-test-load.testing"))<br>(test::assert-equal "LOAD TEST" test-load-one)<br>(test::assert-equal '(1 2 3) test-load-two) | 
 | doc | Function<br> | root<br><br> | (doc symbol)<br><br>Return the doc string for a symbol or nil if no string.<br><br> | ;(doc 'car)<br>t | 
 | expand-macro1 | SpecialForm<br> | root<br><br> | (expand-macro1 expression)<br><br>Expands a macro expression.  Only expand the first macro.<br><br>Just returns the expression if not a macro.<br><br> | (test::assert-equal '(apply def 'xx '#("value")) (expand-macro1 (defq xx "value")))<br>(test::assert-equal '(core::let<br>    ((i))<br>    (if<br>        (> (length '(1 2 3)) 0)<br>        (core::loop<br>            (plist)<br>            ('(1 2 3))<br>            (progn<br>                (core::setq i (core::first plist)) nil<br>                (if<br>                    (> (length plist) 1)<br>                    (recur (core::rest plist)))))))<br>    (expand-macro1 (for i '(1 2 3) ())))<br>(test::assert-equal '(1 2 3) (expand-macro1 (1 2 3))) | 
 | quote | SpecialForm<br> | root<br><br> | (quote expression) -> expression<br><br>Return expression without evaluation.  The reader macro ' will expand to a quote form.<br><br> | (test::assert-equal (list 1 2 3) (quote (1 2 3)))<br>(test::assert-equal (list 1 2 3) '(1 2 3))<br>(test::assert-equal '(1 2 3) (quote (1 2 3))) | 
 | get-error | Function<br> | root<br><br> | (get-error exp0 ... expN)<br><br>Evaluate each form (like progn) but on error return #(:error msg) instead of aborting.<br><br>If there is no error will return the value of the last expression.<br><br> | (test::assert-equal '#(:error "Some Error") (get-error (err "Some Error")))<br>(test::assert-equal "Some String" (get-error "Some String"))<br>(test::assert-equal "Some Other String" (get-error (def 'test-get-error "Some ") (str test-get-error "Other String"))) | 
 | err | Function<br> | root<br><br> | (err string) -> raises an error<br><br>Raise an error with the supplied string.<br><br> | (def 'test-err-err (get-error (err "Test Error")))<br>(test::assert-equal '#(:error "Test Error") test-err-err) | 
 | set | Function<br> | root<br><br> | (set symbol expression) -> expression<br><br>Sets an existing expression in the current scope(s).  Return the expression that was set.<br><br> | (def 'test-progn-one nil)<br>(def 'test-progn-two nil)<br>(def 'test-progn-three (progn (set 'test-progn-one "One")(set 'test-progn-two "Two")"Three"))<br>(test::assert-equal "One" test-progn-one)<br>(test::assert-equal "Two" test-progn-two)<br>(test::assert-equal "Three" test-progn-three)<br>(let ((test-progn-one nil))<br>    ; set the currently scoped value.<br>    (test::assert-equal "1111" (set 'test-progn-one "1111"))<br>    (test::assert-equal "1111" test-progn-one))<br>; Original outer scope not changed.<br>(test::assert-equal "One" test-progn-one) | 
 | symbol-name | Function<br> | root<br><br> | (symbol-name symbol) -> string<br><br>Convert a symbol to its string representation.<br><br>The string will be the symbol name as a string.<br><br> | (def 'test-symbol-name-sym nil)<br>(test::assert-true (string? (symbol-name 'test-symbol-name-sym)))<br>(test::assert-equal "test-symbol-name-sym" (symbol-name 'test-symbol-name-sym)) | 
 | block | SpecialForm<br> | root<br><br> | (block name form*)<br><br>Create a block with name (name is not evaluted), if no return-from encountered then<br>return last expression (like progn).<br><br> | (test::assert-equal '(4 5) (block xxx '(1 2) (return-from xxx '(4 5)) '(a b) '(2 3)))<br>(test::assert-equal '(4 5) (block xxx '(1 2) (return-from nil '(4 5)) '(a b) '(2 3)))<br>(test::assert-equal '(5 6) (block xxx '(1 2) (block yyy (return-from xxx '(5 6)) '(a b)) '(2 3)))<br>(test::assert-equal '(5 6) (block xxx '(1 2) (block yyy ((fn (p) (return-from xxx p)) '(5 6)) '(a b)) '(2 3)))<br>(test::assert-equal '(2 3) (block xxx '(1 2) (block yyy (return-from yyy t) '(a b)) '(2 3))) | 
 | error-stack-on | Function<br> | root<br><br> | (error-stack-on)<br><br>Print the eval stack on error.<br><br> | ;(error-stack-on)<br>t | 
 | eprintln | Function<br> | root<br><br> | (eprintln arg0 ... argN) -> nil<br><br>Print the arguments (as strings) to *stderr* and then a newline.<br><br> | ; Use a file for stderr for test.<br>(dyn '*stderr* (open "/tmp/sl-sh.eprintln.test" :create :truncate) (eprintln "eprintln test out"))<br>(test::assert-equal "eprintln test out<br>" (read-line (open "/tmp/sl-sh.eprintln.test" :read))) | 
 | format | Function<br> | root<br><br> | (format arg0 ... argN) -> string<br><br>Build a formatted string from arguments.<br><br>Arguments will be turned into strings.<br><br> | (test::assert-equal "stringsome" (format "string" "some"))<br>(test::assert-equal "string" (format "string" ""))<br>(test::assert-equal "string 50" (format "string" " " 50))<br>(test::assert-equal "string 50 100.5" (format "string" " " 50 " " 100.5)) | 
 | expand-macro | SpecialForm<br> | root<br><br> | (expand-macro expression)<br><br>Expands a macro expression.  If that expansion is also a macro then expand it recursively.<br><br>Just returns the expression if not a macro.<br><br> | (test::assert-equal '(apply def 'xx '#("value")) (expand-macro (defq xx "value")))<br>(test::assert-equal '(<br>    (fn<br>        #(i)<br>        (progn<br>            (if<br>                (> (length '(1 2 3)) 0)<br>                (core::loop<br>                    (plist)<br>                    ('(1 2 3))<br>                    (progn<br>                        (core::setq i (core::first plist)) nil<br>                        (if<br>                            (> (length plist) 1)<br>                            (recur (core::rest plist)))))))) nil)<br>    (expand-macro (for i '(1 2 3) ())))<br>(test::assert-equal '(1 2 3) (expand-macro (1 2 3))) | 
 | bquote | SpecialForm<br> | root<br><br> | (bquote expression) -> expression<br><br>Return expression without evaluation.  The reader macro ` will expand to a bquote form.<br><br>The bquote form (unlike quote) allows for symbol/form evaluation using , or ,@.<br><br> | (test::assert-equal (list 1 2 3) (bquote (1 2 3)))<br>(test::assert-equal (list 1 2 3) `(1 2 3))<br>(test::assert-equal `(1 2 3) (bquote (1 2 3)))<br>(test::assert-equal `(1 2 3) '(1 2 3))<br>(def 'test-bquote-one 1)<br>(def 'test-bquote-list '(1 2 3))<br>(test::assert-equal (list 1 2 3) (bquote (,test-bquote-one 2 3)))<br>(test::assert-equal (list 1 2 3) (bquote (,@test-bquote-list))) | 
 | intern-stats | SpecialForm<br> | root<br><br> | (intern-stats)<br><br>Prints the stats for interned symbols.<br><br> | ;(intern-stats)<br>t | 
 | eprint | Function<br> | root<br><br> | (eprint arg0 ... argN) -> nil<br><br>Print the arguments (as strings) to *stderr*.<br><br> | ; Use a file for stderr for test.<br>(dyn '*stderr* (open "/tmp/sl-sh.eprint.test" :create :truncate) (eprint "eprint test out"))<br>(test::assert-equal "eprint test out" (read-line (open "/tmp/sl-sh.eprint.test" :read))) | 
 | gensym | Function<br> | root<br><br> | (gensym) -> symbol<br><br>Generate a unique symbol.<br><br>Gensym uses a prefix of gs@@ followed by an incrementing counter.<br>It is useful to generate unique symbol names when writing macros (for instance).<br><br> | (def 'test-gensym-one (gensym))<br>(def 'test-gensym-two (gensym))<br>(def 'test-gensym-three (gensym))<br>(test::assert-equal "gs@@1" (symbol-name test-gensym-one))<br>(test::assert-equal "gs@@2" (symbol-name test-gensym-two))<br>(test::assert-equal "gs@@3" (symbol-name test-gensym-three))<br>(test::assert-true (symbol? (gensym)))<br>(test::assert-true (symbol? test-gensym-one))<br>(test::assert-true (symbol? test-gensym-two))<br>(test::assert-true (symbol? test-gensym-three)) | 
 | fncall | Function<br> | root<br><br> | (fncall function arg0 ... argN)<br><br>Call the provided function with the suplied arguments.<br><br> | (def 'test-fncall-one nil)<br>(fncall set 'test-fncall-one "ONE")<br>(test::assert-equal "ONE" test-fncall-one)<br>(test::assert-equal 10 (fncall + 1 2 7)) | 
 | progn | SpecialForm<br> | root<br><br> | (progn exp0 ... expN) -> expN<br><br>Evalutate each form and return the last.<br><br> | (def 'test-progn-one nil)<br>(def 'test-progn-two nil)<br>(def 'test-progn-three (progn (set 'test-progn-one "One")(set 'test-progn-two "Two")"Three"))<br>(test::assert-equal "One" test-progn-one)<br>(test::assert-equal "Two" test-progn-two)<br>(test::assert-equal "Three" test-progn-three) | 
 | meta-file-name | SpecialForm<br> | root<br><br> | (meta-file-name)<br><br>File name of the file this came from.<br><br> | ;(meta-file-name)<br>t | 
 | meta-line-no | SpecialForm<br> | root<br><br> | (meta-line-no)<br><br>Line number from the file this came from.<br><br> | ;(meta-line-no)<br>t | 
 | meta-column-no | SpecialForm<br> | root<br><br> | (meta-column-no)<br><br>Column number from the file this came from.<br><br> | ;(meta-column-no)<br>t | 
 | println | Function<br> | root<br><br> | (println arg0 ... argN) -> nil<br><br>Print the arguments (as strings) to *stdout* and then a newline.<br><br> | ; Use a file for stdout for test.<br>(dyn '*stdout* (open "/tmp/sl-sh.println.test" :create :truncate) (println "Println test out"))<br>(test::assert-equal "Println test out<br>" (read-line (open "/tmp/sl-sh.println.test" :read))) | 
 | length | Function<br> | root<br><br> | (length expression) -> int<br><br>Return length of suplied expression.<br><br> | (test::assert-equal 0 (length nil))<br>(test::assert-equal 5 (length "12345"))<br>; Note the unicode symbol is only one char even though it is more then one byte.<br>(test::assert-equal 6 (length "12345Î£"))<br>(test::assert-equal 3 (length '(1 2 3)))<br>(test::assert-equal 3 (length '#(1 2 3)))<br>(test::assert-equal 3 (length (list 1 2 3)))<br>(test::assert-equal 3 (length (vec 1 2 3)))<br>(test::assert-equal 1 (length 100))<br>(test::assert-equal 1 (length 100.0))<br>(test::assert-equal 1 (length #\x)) | 
 | def? | Function<br> | root<br><br> | (def? expression) -> t|nil<br><br>Return true if symbol is defined.<br><br>Expression will be evaluated and if a symbol or string it will look up that<br>name in the symbol table and return true if it exists.<br><br> | (def 'test-is-def t)<br>(test::assert-true (def? 'test-is-def))<br>(test::assert-true (def? "test-is-def"))<br>(test::assert-true (def? (symbol-name 'test-is-def)))<br>(test::assert-false (def? 'test-is-def-not-defined))<br>(test::assert-false (def? "test-is-def-not-defined")) | 
 | print | Function<br> | root<br><br> | (print arg0 ... argN) -> nil<br><br>Print the arguments (as strings) to *stdout*.<br><br> | ; Use a file for stdout for test.<br>(dyn '*stdout* (open "/tmp/sl-sh.print.test" :create :truncate) (print "Print test out"))<br>(test::assert-equal "Print test out" (read-line (open "/tmp/sl-sh.print.test" :read))) | 
 | undef | Function<br> | root<br><br> | (undef symbol)<br><br>Remove a symbol from the current scope (if it exists).<br><br> | (def 'test-undef nil)<br>(test::assert-true (def? 'test-undef))<br>(undef 'test-undef)<br>(test::assert-false (def? 'test-undef)) | 
 | expand-macro-all | SpecialForm<br> | root<br><br> | (expand-macro-all expression)<br><br>Expands a macro expression like expand-macro but also expand any embedded macros.  <br><br>Just returns the expression if not a macro.<br><br> | (test::assert-equal '(apply def 'xx '#("value")) (expand-macro-all (defq xx "value")))<br>(test::assert-equal '(<br>    (fn<br>        #(i)<br>        (progn<br>            (if<br>                (> (length '(1 2 3)) 0)<br>                (<br>                    (fn<br>                        (plist)<br>                        (progn<br>                            (apply set 'i '#((core::first plist))) nil<br>                            (if<br>                                (> (length plist) 1)<br>                                (recur (core::rest plist)))))<br>                    '(1 2 3))))) nil)<br>    (expand-macro-all (for i '(1 2 3) ())))<br>(test::assert-equal '(1 2 3) (expand-macro-all (1 2 3))) | 
 | to-symbol | Function<br> | root<br><br> | (to-symbol expression) -> symbol<br><br>Convert a string, symbol, int or float to a symbol.<br><br>If the symbol is new it will be interned.<br><br> | (def 'test-to-symbol-sym nil)<br>(test::assert-true (symbol? (to-symbol 55)))<br>(test::assert-true (symbol? (to-symbol 55.0)))<br>(test::assert-true (symbol? (to-symbol "to-symbol-test-new-symbol")))<br>(test::assert-true (symbol? (to-symbol (str-buf "to-symbol-test-new-symbol-buf"))))<br>(test::assert-true (symbol? (to-symbol 'test-to-symbol-sym)))<br>(test::assert-true (symbol? (to-symbol (symbol-name 'test-to-symbol-sym)))) | 
 | def | Function<br> | root<br><br> | (def symbol expression) -> expression<br><br>Adds an expression to the current scope.  Return the expression that was defined.<br><br> | (def 'test-progn-one nil)<br>(def 'test-progn-two nil)<br>(def 'test-progn-three (progn (set 'test-progn-one "One")(set 'test-progn-two "Two")"Three"))<br>(test::assert-equal "One" test-progn-one)<br>(test::assert-equal "Two" test-progn-two)<br>(test::assert-equal "Three" test-progn-three)<br>(let ((test-progn-one nil))<br>    ; Add this to tthe let's scope (shadow the outer test-progn-two).<br>    (test::assert-equal "Default" (def 'test-progn-two "Default"))<br>    ; set the currently scoped value.<br>    (set 'test-progn-one "1111")<br>    (set 'test-progn-two "2222")<br>    (test::assert-equal "1111" test-progn-one)<br>    (test::assert-equal "2222" test-progn-two))<br>; Original outer scope not changed.<br>(test::assert-equal "One" test-progn-one) | 
 | return-from | SpecialForm<br> | root<br><br> | (return-from name expression?)<br><br>Causes enclosing block with name (name is not evaluted) to evaluate to expression.<br><br> | (test::assert-equal '(4 5) (block xxx '(1 2) (return-from xxx '(4 5)) '(a b) '(2 3)))<br>(test::assert-equal '(4 5) (block xxx '(1 2) (return-from nil '(4 5)) '(a b) '(2 3)))<br>(test::assert-equal '(5 6) (block xxx '(1 2) (block yyy (return-from xxx '(5 6)) '(a b)) '(2 3)))<br>(test::assert-equal '(5 6) (block xxx '(1 2) (block yyy ((fn (p) (return-from xxx p)) '(5 6)) '(a b)) '(2 3)))<br>(test::assert-equal '(2 3) (block xxx '(1 2) (block yyy (return-from yyy t) '(a b)) '(2 3))) | 
 | dyn | Function<br> | root<br><br> | (dyn key value expression) -> nil<br><br>Creates a dynamic binding for key, assigns value to it and evals expression under it.<br><br>The binding is gone once the dyn form ends.  The binding will take precedent over<br>any other binding in any scope with that name for any form that evalute as a <br>result of the dynamic binging (for instance creating a dynamic binding for<br>*stdout* will cause all output to stdout to use the new binding in any print's<br>used indirectly).<br><br> | (defn test-dyn-fn () (print "Print dyn out"))<br>(dyn '*stdout* (open "/tmp/sl-sh.dyn.test" :create :truncate) (test-dyn-fn))<br>(test::assert-equal "Print dyn out" (read-line (open "/tmp/sl-sh.dyn.test" :read))) | 
 | apply | Function<br> | root<br><br> | (apply function arg* list)<br><br>Call the provided function with the suplied arguments, last is a list that will be expanded.<br><br> | (def 'test-apply-one nil)<br>(apply set '('test-apply-one "ONE"))<br>(test::assert-equal "ONE" test-apply-one)<br>(test::assert-equal 10 (apply + 1 '(2 7))) | 
 | doc-raw | Function<br> | root<br><br> | (doc-raw symbol)<br><br>Return the raw (unexpanded) doc string for a symbol or nil if no string.<br><br> | ;(doc-raw 'car)<br>t | 
 | unwind-protect | Function<br> | root<br><br> | (unwind-protect protected cleanup*) -> [protected result]<br><br>After evaluation first form, make sure the following cleanup forms run (returns first form's result).<br><br> | (def 'test-unwind-one nil)<br>(def 'test-unwind-err (get-error<br>(unwind-protect (err "Some protected error") (set 'test-unwind-one "got it"))))<br>(test::assert-equal '#(:error "Some protected error") test-unwind-err)<br>(test::assert-equal "got it" test-unwind-one)<br><br>(def 'test-unwind-one nil)<br>(def 'test-unwind-two nil)<br>(def 'test-unwind-three nil)<br>(def 'test-unwind-four nil)<br>(def 'test-unwind-err (get-error<br>(unwind-protect<br>    (progn (set 'test-unwind-one "set one")(err "Some protected error two")(set 'test-unwind-two "set two"))<br>    (set 'test-unwind-three "set three")(set 'test-unwind-four "set four"))))<br>(test::assert-equal '#(:error "Some protected error two") test-unwind-err)<br>(test::assert-equal "set one" test-unwind-one)<br>(test::assert-equal nil test-unwind-two)<br>(test::assert-equal "set three" test-unwind-three)<br>(test::assert-equal "set four" test-unwind-four) | 
 | error-stack-off | Function<br> | root<br><br> | (error-stack-off)<br><br>Do not print the eval stack on error.<br><br> | ;(error-stack-off)<br>t | 

## Type forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | file? | Function<br> | root<br><br> | (file? expression)<br><br>True if the expression is a file, false otherwise.<br><br> | (test::assert-true (file? (open :stdout)))<br>(test::assert-false (file? (fn () ())))<br>(test::assert-false (file? copy-seq))<br>(test::assert-false (file? 1)) | 
 | true? | Function<br> | root<br><br> | (true? expression)<br><br>True if the expression is true (true type NOT non-null), false otherwise.<br><br> | (test::assert-true (true? t))<br>(test::assert-false (true? nil))<br>(test::assert-false (true? 1))<br>(test::assert-false (true? "str")) | 
 | builtin? | Function<br> | root<br><br> | (builtin? expression)<br><br>True if the expression is a builtin function or special form, false otherwise.<br><br> | (test::assert-true (builtin? type))<br>(test::assert-true (builtin? if))<br>(test::assert-false (builtin? (fn () ())))<br>(test::assert-false (builtin? copy-seq))<br>(test::assert-false (builtin? 1)) | 
 | pair? | Function<br> | root<br><br> | (pair? expression)<br><br>True if the expression is a pair, false otherwise.<br><br> | (test::assert-true (pair? '(1 . 2)) "reader macro")<br>(test::assert-true (pair? (join 1 2)) "join") <br>(test::assert-true (pair? '(1 2)))<br>(test::assert-false (pair? 1))<br>(test::assert-false (pair? '#(1 2 3)))<br>(test::assert-false (pair? (vec))) | 
 | int? | Function<br> | root<br><br> | (int? expression)<br><br>True if the expression is an int, false otherwise.<br><br> | (test::assert-true (int? 1))<br>(test::assert-false (int? 1.5)) | 
 | symbol? | Function<br> | root<br><br> | (symbol? expression)<br><br>True if the expression is a symbol, false otherwise.<br><br> | (test::assert-true (symbol? 'symbol))<br>(test::assert-false (symbol? 1)) | 
 | vec? | Function<br> | root<br><br> | (vec? expression)<br><br>True if the expression is a vector, false otherwise.<br><br> | (test::assert-true (vec? '#(1 2 3)) "reader macro")<br>(test::assert-true (vec? (make-vec)) "make-vec") <br>(test::assert-true (vec? (vec 1 2 3)) "vec") <br>(test::assert-false (vec? 1))<br>(test::assert-false (vec? '(1 2 3)))<br>(test::assert-false (vec? (list))) | 
 | nil? | Function<br> | root<br><br> | (nil? expression)<br><br>True if the expression is nil, false otherwise.<br><br> | (test::assert-true (nil? nil))<br>(test::assert-false (nil? t)) | 
 | lambda? | Function<br> | root<br><br> | (lambda? expression)<br><br>True if the expression is a lambda, false otherwise.<br><br> | (test::assert-true (lambda? (fn () ())))<br>(test::assert-true (lambda? copy-seq))<br>(test::assert-false (lambda? 1))<br>(test::assert-false (lambda? if)) | 
 | type | Function<br> | root<br><br> | (type expression)<br><br>Return the type of the given expression as a string.<br><br>Types are:<br>    True<br>    Float<br>    Int<br>    Symbol<br>    String<br>    StringBuf<br>    Char<br>    Lambda<br>    Macro<br>    Process<br>    SpecialForm<br>    Function<br>    Vector<br>    Pair<br>    Nil<br>    HashMap<br>    File<br><br> | (test::assert-equal "True" (type t))<br>(test::assert-equal "Float" (type 1.1))<br>(test::assert-equal "Int" (type 1))<br>(test::assert-equal "Symbol" (type 'symbol))<br>(def 'type-sym 'symbol)<br>(test::assert-equal "Symbol" (type type-sym))<br>(test::assert-equal "String" (type "string"))<br>(test::assert-equal "StringBuf" (type (str-buf "buffer")))<br>(test::assert-equal "Char" (type #\a))<br>(test::assert-equal "Lambda" (type (fn () ())))<br>(test::assert-equal "Macro" (type (macro () ())))<br>(test::assert-equal "Process" (type (true)))<br>(test::assert-equal "SpecialForm" (type if))<br>(test::assert-equal "Function" (type type))<br>(test::assert-equal "Vector" (type '#(1 2 3)))<br>(def 'type-vec '#(4 5 6))<br>(test::assert-equal "Vector" (type type-vec))<br>(test::assert-equal "Pair" (type '(1 . 2)))<br>(test::assert-equal "Pair" (type '(1 2 3)))<br>(test::assert-equal "Nil" (type nil))<br>(test::assert-equal "Nil" (type '()))<br>(test::assert-equal "HashMap" (type (make-hash)))<br>(test::assert-equal "File" (type (open :stdin))) | 
 | float? | Function<br> | root<br><br> | (float? expression)<br><br>True if the expression is a float, false otherwise.<br><br> | (test::assert-true (float? 1.5))<br>(test::assert-false (float? 1)) | 
 | string-buf? | Function<br> | root<br><br> | (string-buf? expression)<br><br>True if the expression is a string buffer, false otherwise.<br><br> | (test::assert-true (string-buf? (str-buf "string")))<br>(test::assert-false (string-buf? "string"))<br>(test::assert-false (string-buf? 1)) | 
 | char? | Function<br> | root<br><br> | (char? expression)<br><br>True if the expression is a char, false otherwise.<br><br> | (test::assert-true (char? #\a))<br>(test::assert-false (char? 1))<br>(test::assert-false (char? "a")) | 
 | hash? | Function<br> | root<br><br> | (hash? expression)<br><br>True if the expression is a hash map, false otherwise.<br><br> | (test::assert-true (hash? (make-hash)) "make-vec") <br>(test::assert-false (hash? 1))<br>(test::assert-false (hash? '(1 2 3)))<br>(test::assert-false (hash? (list)))<br>(test::assert-false (hash? (vec))) | 
 | string? | Function<br> | root<br><br> | (string? expression)<br><br>True if the expression is a string, false otherwise.<br><br> | (test::assert-true (string? "string"))<br>(test::assert-false (string? 1)) | 
 | process? | Function<br> | root<br><br> | (process? expression)<br><br>True if the expression is a process, false otherwise.<br><br> | (test::assert-true (process? (true)))<br>(test::assert-false (process? (fn () ())))<br>(test::assert-false (process? copy-seq))<br>(test::assert-false (process? 1)) | 
 | macro? | Function<br> | root<br><br> | (macro? expression)<br><br>True if the expression is a macro, false otherwise.<br><br> | (test::assert-true (macro? (macro () ())))<br>(test::assert-true (macro? defn))<br>(test::assert-false (macro? 1))<br>(test::assert-false (macro? if)) | 
 | list? | Function<br> | root<br><br> | (list? expression)<br><br>True if the expression is a list, false otherwise.<br><br> | (test::assert-true (list? '(1 2 3)) "reader macro")<br>(test::assert-true (list? (list 1 2 3)) "list") <br>(test::assert-false (list? 1))<br>(test::assert-false (list? '#(1 2 3)))<br>(test::assert-false (list? (vec)))<br>(test::assert-false (list? '(1 . 2))) | 

## Char forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | char> | Function<br> | root<br><br> | (char> char0 char1 ... charN) -> t/nil<br><br>Test chars for greater than.<br><br> | (test::assert-false (char> #\  #\ ))<br>(test::assert-false (char> #\a #\b))<br>(test::assert-false (char> #\a #\b #\a))<br>(test::assert-true (char> #\z #\a))<br>(test::assert-true (char> #\c #\b #\a))<br>(test::assert-true (char> #\z #\Z))<br>(test::assert-false (char> #\a (char-lower #\A))) | 
 | char< | Function<br> | root<br><br> | (char< char0 char1 ... charN) -> t/nil<br><br>Test chars for less than.<br><br> | (test::assert-false (char< #\  #\ ))<br>(test::assert-false (char< #\b #\b))<br>(test::assert-false (char< #\a #\b #\a))<br>(test::assert-true (char< #\a #\z))<br>(test::assert-true (char< #\a #\b #\c))<br>(test::assert-true (char< #\Z #\z))<br>(test::assert-true (char< #\A (char-lower #\A))) | 
 | char-lower | Function<br> | root<br><br> | (char-lower char) -> char<br><br>Get ascii lower case character for a character.<br><br> | (test::assert-equal #\a (char-lower #\A))<br>(test::assert-equal #\a (char-lower #\a))<br>(test::assert-not-equal #\a (char-lower #\Z)) | 
 | char= | Function<br> | root<br><br> | (char= char0 char1 ... charN) -> t/nil<br><br>Test chars for equality.<br><br> | (test::assert-true (char= #\  #\ ))<br>(test::assert-true (char= #\a #\a))<br>(test::assert-true (char= #\a #\a #\a))<br>(test::assert-false (char= #\z #\a))<br>(test::assert-false (char= #\z #\a #\a))<br>(test::assert-false (char= #\z #\Z))<br>(test::assert-true (char= #\a (char-lower #\A))) | 
 | char!= | Function<br> | root<br><br> | (char!= char0 char1 ... charN) -> t/nil<br><br>Test chars for in-equality.<br><br> | (test::assert-false (char!= #\  #\ ))<br>(test::assert-false (char!= #\a #\a))<br>(test::assert-false (char!= #\a #\a #\a))<br>(test::assert-true (char!= #\z #\a))<br>(test::assert-true (char!= #\z #\a #\a))<br>(test::assert-true (char!= #\z #\Z))<br>(test::assert-false (char!= #\a (char-lower #\A))) | 
 | char<= | Function<br> | root<br><br> | (char<= char0 char1 ... charN) -> t/nil<br><br>Test chars for less than or equal.<br><br> | (test::assert-true (char<= #\  #\ ))<br>(test::assert-true (char<= #\b #\b))<br>(test::assert-false (char<= #\a #\b #\a))<br>(test::assert-true (char<= #\a #\z))<br>(test::assert-false (char<= #\z #\a))<br>(test::assert-true (char<= #\a #\b #\c))<br>(test::assert-true (char<= #\Z #\z))<br>(test::assert-true (char<= #\A (char-lower #\A))) | 
 | char-upper | Function<br> | root<br><br> | (char-upper char) -> char<br><br>Get ascii upper case character for a character.<br><br> | (test::assert-equal #\A (char-upper #\A))<br>(test::assert-equal #\A (char-upper #\a))<br>(test::assert-not-equal #\A (char-upper #\Z)) | 
 | char-whitespace? | Function<br> | root<br><br> | (char-whitespace? char) -> t/nil<br><br>Returns true if a character is whitespace, false/nil otherwise.<br><br> | (test::assert-true (char-whitespace? #\ ))<br>(test::assert-true (char-whitespace? #\tab))<br>(test::assert-false (char-whitespace? #\s)) | 
 | char>= | Function<br> | root<br><br> | (char>= char0 char1 ... charN) -> t/nil<br><br>Test chars for greater than or equal.<br><br> | (test::assert-true (char>= #\  #\ ))<br>(test::assert-false (char>= #\a #\b))<br>(test::assert-false (char>= #\a #\b #\a))<br>(test::assert-true (char>= #\z #\a))<br>(test::assert-true (char>= #\c #\b #\a))<br>(test::assert-true (char>= #\z #\Z))<br>(test::assert-true (char>= #\a (char-lower #\A))) | 

## String forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | str-buf-push! | Function<br> | root<br><br> | (str-buf-push! string-buffer arg0 ... argN) -> string-buffer<br><br>Push the args (as strings) onto the string-buffer.  This is a destructive form.<br><br>Arguments will be turned into strings.  Returns the string-buffer it was given.<br><br> | (test::assert-equal "stringsome" (str-buf-push! (str-buf "string") "some"))<br>(def 'test-str-buf-push (str-buf "def-string"))<br>(test::assert-equal "def-stringsome" (str-buf-push! test-str-buf-push "some"))<br>(test::assert-equal "def-stringsome" test-str-buf-push) | 
 | str-rsplit | Function<br> | root<br><br> | (str-rsplit split-pattern string) -> vector<br> <br>Use a pattern to split a string into reverse order.<br><br> | (test::assert-equal '("some" "yyy" "string") (str-rsplit "xxx" "stringxxxyyyxxxsome"))<br>(test::assert-equal '("" "some" "yyy" "string") (str-rsplit "xxx" "stringxxxyyyxxxsomexxx"))<br>(test::assert-equal '("some" "yyy" "string") (str-rsplit " " "string yyy some"))<br>(test::assert-equal '("somexxxyyyxxxstring") (str-rsplit :whitespace "somexxxyyyxxxstring"))<br>(test::assert-equal '("somexxxyyyxxxstring") (str-rsplit "zzz" "somexxxyyyxxxstring")) | 
 | str-lower | Function<br> | root<br><br> | (str-lower string) -> string<br><br>Get all lower case string from a string.<br><br> | (test::assert-equal "stau" (str-lower "STAU"))<br>(test::assert-equal "stau" (str-lower "stau"))<br>(test::assert-equal "stau" (str-lower "Stau"))<br>(test::assert-equal "stau" (str-lower "StaU"))<br>(test::assert-equal "stau" (str-lower "sTaU")) | 
 | str-append | Function<br> | root<br><br> | (str-append string string) -> string<br><br>Make a new string by appending two strings.<br><br> | (test::assert-equal "stringsome" (str-append "string" "some"))<br>(test::assert-equal "string" (str-append "string" ""))<br>(test::assert-equal "string " (str-append "string" " ")) | 
 | str-starts-with | Function<br> | root<br><br> | (str-starts-with pattern string) -> t/nil<br><br>True if string start with pattern (both strings).<br><br> | (test::assert-true (str-starts-with "Stau" "Stausomething"))<br>(test::assert-false (str-starts-with "StaU" "Stausomething")) | 
 | str-buf-clear! | Function<br> | root<br><br> | (str-buf-clear! string-buffer) -> string-buffer<br><br>Clears a string-buffer.  This is a destructive form.<br><br>Returns the string-buffer it was given.<br><br> | (test::assert-equal "" (str-buf-clear! (str-buf "string")))<br>(def 'test-str-buf-clear (str-buf "def-string"))<br>(test::assert-equal "" (str-buf-clear! test-str-buf-clear))<br>(test::assert-equal "" test-str-buf-clear) | 
 | str-trim | Function<br> | root<br><br> | (str-trim string) -> string<br> <br>Trim right and left whitespace from string.<br><br> | (test::assert-equal "some string" (str-trim "   some string"))<br>(test::assert-equal "some string" (str-trim "   some string   "))<br>(test::assert-equal "some string" (str-trim (str-buf "   some string   ")))<br>(test::assert-equal "some string" (str-trim "some string   "))<br>(test::assert-equal "some string" (str-trim "some string")) | 
 | str-splitn | Function<br> | root<br><br> | (str-splitn n split-pattern string) -> vector<br> <br>Use a pattern to split a string with at most n items.<br><br> | (test::assert-equal '("some" "yyy" "string") (str-splitn 3 "xxx" "somexxxyyyxxxstring"))<br>(test::assert-equal '("some" "yyy" "string") (str-splitn 4 "xxx" "somexxxyyyxxxstring"))<br>(test::assert-equal '("some" "yyy" "stringxxxother") (str-splitn 3 "xxx" "somexxxyyyxxxstringxxxother"))<br>(test::assert-equal '("somexxxyyyxxxstringxxxother") (str-splitn 1 "xxx" "somexxxyyyxxxstringxxxother"))<br>(test::assert-equal '() (str-splitn 0 "xxx" "somexxxyyyxxxstringxxxzero")) | 
 | str-map | Function<br> | root<br><br> | (str-map lambda string) -> string<br><br>Make a new string by applying lambda to each char.<br><br> | (test::assert-equal "XstringXstrX" (str-map (fn (ch) (if (char= #\x ch) #\X ch)) "xstringxstrx"))<br>(def 'test-str-map (str-map (fn (ch) (if (char= #\x ch) #\X ch)) "xstringxstrx"))<br>(test::assert-equal "XstringXstrX" test-str-map)<br>(test::assert-true (string? test-str-map))<br>(def 'test-str-map (str-map (fn (ch) (if (char= #\x ch) #\X ch)) (str-buf "xstringxstrx")))<br>(test::assert-equal "XstringXstrX" test-str-map)<br>(test::assert-true (string? test-str-map)) | 
 | str-buf-map | Function<br> | root<br><br> | (str-buf-map lambda string) -> string-buffer<br><br>Make a new string buffer by applying lambda to each char.<br><br> | (def 'test-str-buf-map (str-buf-map (fn (ch) (if (char= #\x ch) #\X ch)) "xstringxstrx"))<br>(test::assert-equal "XstringXstrX" test-str-buf-map)<br>(test::assert-true (string-buf? test-str-buf-map))<br>(def 'test-str-buf-map (str-buf-map (fn (ch) (if (char= #\x ch) #\X ch)) (str-buf "xstringxstrx")))<br>(test::assert-equal "XstringXstrX" test-str-buf-map)<br>(test::assert-true (string-buf? test-str-buf-map)) | 
 | str-nth | Function<br> | root<br><br> | (str-nth n string) -> char<br><br>Get the nth char of a string.<br><br> | (test::assert-equal #\a (str-nth 2 "stau"))<br>(test::assert-equal #\s (str-nth 0 "stau"))<br>(test::assert-equal #\u (str-nth 3 "stau")) | 
 | str-upper | Function<br> | root<br><br> | (str-upper string) -> string<br><br>Get all upper case string from a string.<br><br> | (test::assert-equal "STAU" (str-upper "STAU"))<br>(test::assert-equal "STAU" (str-upper "stau"))<br>(test::assert-equal "STAU" (str-upper "Stau"))<br>(test::assert-equal "STAU" (str-upper "StaU"))<br>(test::assert-equal "STAU" (str-upper "sTaU")) | 
 | str-cat-list | Function<br> | root<br><br> | (str-cat-list join-pattern sequence) -> string<br><br>Build a string by concatting a sequence with a join string.<br><br> | (test::assert-equal "stringxxxyyyxxxsome" (str-cat-list "xxx" '("string" "yyy" "some")))<br>(test::assert-equal "string yyy some" (str-cat-list " " '("string" "yyy" "some")))<br>(test::assert-equal "stringyyysome" (str-cat-list "" '("string" "yyy" "some"))) | 
 | str-replace | Function<br> | root<br><br> | (str-replace string old-pattern new-pattern) -> string<br> <br>Replace occurances of second string with third in the first string.<br><br> | (test::assert-equal "some yyy string" (str-replace "some xxx string" "xxx" "yyy"))<br>(test::assert-equal "some yyy string yyy" (str-replace "some xxx string xxx" "xxx" "yyy"))<br>(test::assert-equal "yyy some yyy string yyy" (str-replace "xxx some xxx string xxx" "xxx" "yyy")) | 
 | str-empty? | Function<br> | root<br><br> | (str-empty?) -> t/nil<br><br>Is a string empty?  Let's find out...<br><br> | (test::assert-true (str-empty? ""))<br>(test::assert-true (str-empty? (str-trim "   ")))<br>(test::assert-false (str-empty? " "))<br>(test::assert-false (str-empty? "string")) | 
 | str-rsplitn | Function<br> | root<br><br> | (str-rsplitn n split-pattern string) -> vector<br> <br>Use a pattern to split a string with at most n items returned in reverse order.<br><br> | (test::assert-equal '("some" "yyy" "string") (str-rsplitn 3 "xxx" "stringxxxyyyxxxsome"))<br>(test::assert-equal '("some" "yyy" "string") (str-rsplitn 4 "xxx" "stringxxxyyyxxxsome"))<br>(test::assert-equal '("other" "string" "somexxxyyy") (str-rsplitn 3 "xxx" "somexxxyyyxxxstringxxxother"))<br>(test::assert-equal '("somexxxyyyxxxstringxxxother") (str-rsplitn 1 "xxx" "somexxxyyyxxxstringxxxother"))<br>(test::assert-equal '() (str-rsplitn 0 "xxx" "somexxxyyyxxxstringxxxzero")) | 
 | str-sub | Function<br> | root<br><br> | (str-sub start length string) -> string<br><br>Return a substring from a string given start (0 based) and length.<br><br> | (test::assert-equal "string" (str-sub 0 6 "stringxxxyyyxxxsome"))<br>(test::assert-equal "some" (str-sub 15 4 "stringxxxyyyxxxsome"))<br>(test::assert-equal "yyy" (str-sub 9 3 "stringxxxyyyxxxsome")) | 
 | str-ltrim | Function<br> | root<br><br> | (str-ltrim string) -> string<br> <br>Trim left whitspace from string.<br><br> | (test::assert-equal "some string" (str-ltrim "   some string"))<br>(test::assert-equal "some string   " (str-ltrim "   some string   "))<br>(test::assert-equal "some string   " (str-ltrim (str-buf "   some string   ")))<br>(test::assert-equal "some string   " (str-ltrim "some string   "))<br>(test::assert-equal "some string" (str-ltrim "some string")) | 
 | str | Function<br> | root<br><br> | (str arg0 ... argN) -> string<br><br>Make a new string with it's arguments.<br><br>Arguments will be turned into strings.  If an argument is a process then the<br>output of the process will be captured and put into the string.<br><br> | (test::assert-equal "stringsome" (str "string" "some"))<br>(test::assert-equal "string" (str "string" ""))<br>(test::assert-equal "string 50" (str "string" " " 50))<br>(test::assert-equal "string 50 test<br>" (str "string" " " 50 " " (echo "test"))) | 
 | str-contains | Function<br> | root<br><br> | (str-contains pattern string) -> t/nil<br><br>True if string contains pattern (both strings).<br><br> | (test::assert-true (str-contains "Stau" "Stausomething"))<br>(test::assert-false (str-contains "StaU" "Stausomething"))<br>(test::assert-true (str-contains "some" "Stausomething"))<br>(test::assert-false (str-contains "Some" "Stausomething"))<br>(test::assert-true (str-contains "thing" "Stausomething"))<br>(test::assert-false (str-contains "Thing" "Stausomething"))<br>(test::assert-true (str-contains "someÎ£" "StausomeÎ£thing")) | 
 | str-rtrim | Function<br> | root<br><br> | (str-rtrim string) -> string<br> <br>Trim right whitespace from string.<br><br> | (test::assert-equal "   some string" (str-rtrim "   some string"))<br>(test::assert-equal "   some string" (str-rtrim "   some string   "))<br>(test::assert-equal "   some string" (str-rtrim (str-buf "   some string   ")))<br>(test::assert-equal "some string" (str-rtrim "some string   "))<br>(test::assert-equal "some string" (str-rtrim "some string")) | 
 | str-buf | Function<br> | root<br><br> | (str-buf arg0 ... argN) -> string-buffer<br><br>Make a new string buffer with it's arguments.<br><br>Arguments will be turned into strings.  If an argument is a process then the<br>output of the process will be captured and put into the string buffer.<br><br> | (test::assert-equal "stringsome" (str-buf "string" "some"))<br>(test::assert-equal "StringBuf" (type (str-buf "string" "some")))<br>(test::assert-true (string-buf? (str-buf "string" "some")))<br>(test::assert-equal "string" (str-buf "string" ""))<br>(test::assert-equal "string 50" (str-buf "string" " " 50))<br>(test::assert-equal "string 50 test<br>" (str-buf "string" " " 50 " " (echo "test"))) | 
 | str-ignore-expand | Function<br> | root<br><br> | (str-ignore-expand exp0 ... expN) -> [final expression]<br><br>Like progn but any strings in the form will not be expanded.<br><br> | (export 'TST-IGNORE "TST")<br>(test::assert-equal "some TST stuff" "some  stuff")<br>(test::assert-equal "some $TST-IGNORE stuff" (str-ignore-expand "some  stuff")) | 
 | str-split | Function<br> | root<br><br> | (str-split split-pattern string) -> vector<br> <br>Use a pattern to split a string (:whitespace to split on whitespace).<br><br> | (test::assert-equal '("some" "yyy" "string") (str-split "xxx" "somexxxyyyxxxstring"))<br>(test::assert-equal '("some" "yyy" "string" "") (str-split "xxx" "somexxxyyyxxxstringxxx"))<br>(test::assert-equal '("" "some" "yyy" "string" "") (str-split "xxx" "xxxsomexxxyyyxxxstringxxx"))<br>(test::assert-equal '("some" "yyy" "string") (str-split :whitespace "some yyy string"))<br>(test::assert-equal '("somexxxyyyxxxstring") (str-split :whitespace "somexxxyyyxxxstring"))<br>(test::assert-equal '("somexxxyyyxxxstring") (str-split "zzz" "somexxxyyyxxxstring")) | 
 | str-bytes | Function<br> | root<br><br> | (str-bytes string) -> int<br><br>Return number of bytes in a string (may be more then length).<br><br>Strings are utf8 so it chars and bytes may not be a one to one match.<br><br> | (test::assert-equal 4 (str-bytes "Stau"))<br>(test::assert-equal 0 (str-bytes ""))<br>; Note 5 chars and 6 bytes because of the final char.<br>(test::assert-equal 6 (str-bytes "StauÎ£")) | 

## File forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | write-string | Function<br> | root<br><br> | (write-string file string)<br><br>Write a string to a file.<br><br> | (def 'tst-file (open "/tmp/slsh-tst-open.txt" :create :truncate))<br>(write-string tst-file "Test Line Write String")<br>(flush tst-file)<br>(def 'tst-file (open "/tmp/slsh-tst-open.txt" :read))<br>(test::assert-equal "Test Line Write String" (read-line tst-file))<br>(close tst-file) | 
 | flush | Function<br> | root<br><br> | (flush file)<br><br>Flush a file.<br><br> | (def 'tst-file (open "/tmp/slsh-tst-open.txt" :create :truncate))<br>(write-line tst-file "Test Line Three")<br>(flush tst-file)<br>(def 'tst-file (open "/tmp/slsh-tst-open.txt" :read))<br>(test::assert-equal "Test Line Three<br>" (read-line tst-file))<br>(close tst-file) | 
 | read | Function<br> | root<br><br> | (read file|string) -> list<br><br>Read a file or string and return the list representation.<br><br>Unlike most lisp readers this one will put loose symbols in a list (i.e. you<br>enter things at the repl without the enclosing parens).<br><br> | (def 'tst-file (open "/tmp/slsh-tst-open.txt" :create :truncate))<br>(write-line tst-file "(1 2 3)")<br>;(write-string tst-file "Test Line Read Line Two")<br>(flush tst-file)<br>(def 'tst-file (open "/tmp/slsh-tst-open.txt" :read))<br>(test::assert-equal '(1 2 3) (read tst-file))<br>(close tst-file)<br>(test::assert-equal '(4 5 6) (read "(4 5 6)"))<br>(test::assert-equal '(7 8 9) (read "7 8 9"))<br>(test::assert-equal '(x y z) (read "(x y z)")) | 
 | close | Function<br> | root<br><br> | (close file)<br><br>Close a file.<br><br> | (def 'tst-file (open "/tmp/slsh-tst-open.txt" :create :truncate))<br>(write-line tst-file "Test Line Two")<br>(close tst-file)<br>(def 'tst-file (open "/tmp/slsh-tst-open.txt" :read))<br>(test::assert-equal "Test Line Two<br>" (read-line tst-file))<br>(close tst-file) | 
 | open | Function<br> | root<br><br> | (open filename option*)<br><br>Open a file.<br><br>Options are:<br>    :read<br>    :write<br>    :append<br>    :truncate<br>    :create<br>    :create-new<br>    :on-error-nil<br><br> | (write-line (open "/tmp/slsh-tst-open.txt" :create :truncate) "Test Line One")<br>(test::assert-equal "Test Line One<br>" (read-line (open "/tmp/slsh-tst-open.txt"))) | 
 | write-line | Function<br> | root<br><br> | (write-line file string)<br><br>Write a line to a file.<br><br> | (def 'tst-file (open "/tmp/slsh-tst-open.txt" :create :truncate))<br>(write-line tst-file "Test Line Write Line")<br>(flush tst-file)<br>(def 'tst-file (open "/tmp/slsh-tst-open.txt" :read))<br>(test::assert-equal "Test Line Write Line<br>" (read-line tst-file))<br>(close tst-file) | 
 | read-line | Function<br> | root<br><br> | (read-line file) -> string<br><br>Read a line from a file.<br><br> | (def 'tst-file (open "/tmp/slsh-tst-open.txt" :create :truncate))<br>(write-line tst-file "Test Line Read Line One")<br>(write-string tst-file "Test Line Read Line Two")<br>(flush tst-file)<br>(def 'tst-file (open "/tmp/slsh-tst-open.txt" :read))<br>(test::assert-equal "Test Line Read Line One<br>" (read-line tst-file))<br>(test::assert-equal "Test Line Read Line Two" (read-line tst-file))<br>(close tst-file) | 

## Pair forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | list | Function<br> | root<br><br> | (list item0 item1 .. itemN)<br><br>Create a proper list from pairs with items 0 - N.<br><br> | (test::assert-equal '(1 2 3) (list 1 2 3)) | 
 | car | Function<br> | root<br><br> | (car pair)<br><br>Return the car (first item) from a pair.  If used on a proper list this will be the first element.<br><br> | (def 'tst-pairs-two (list 'x 'y 'z))<br>(test::assert-equal 'x (car tst-pairs-two))<br>(test::assert-equal 10 (car '(10)))<br>(test::assert-equal 9 (car '(9 11 13))) | 
 | xar! | Function<br> | root<br><br> | (xar! pair expression)<br><br>Destructive form thst replaces the car (first item) in a pair with a new expression.<br><br>If used on a proper list will replace the first item.  Can be used on nil to<br>create a pair (expression . nil).<br><br> | (def 'tst-pairs-three (list 'x 'y 'z))<br>(test::assert-equal '(x y z) tst-pairs-three)<br>(test::assert-equal '(s y z) (xar! tst-pairs-three 's))<br>(test::assert-equal '(s y z) tst-pairs-three)<br>(def 'tst-pairs-four nil)<br>(test::assert-equal '() tst-pairs-four)<br>(test::assert-equal '(t) (xar! tst-pairs-four 't))<br>(test::assert-equal '(t) tst-pairs-four) | 
 | xdr! | Function<br> | root<br><br> | (xdr! pair expression)<br><br>Destructive form that replaces the cdr (second item) in a pair with a new expression.<br><br>If used on a proper list will replace everthing after the first item.<br>Can be used on nil to create a pair (nil . expression).<br><br> | (def 'tst-pairs-five (list 'a 'b 'c))<br>(test::assert-equal '(a b c) tst-pairs-five)<br>(test::assert-equal '(a y z) (xdr! tst-pairs-five '(y z)))<br>(test::assert-equal '(a y z) tst-pairs-five)<br>(def 'tst-pairs-six nil)<br>(test::assert-equal '() tst-pairs-six)<br>(test::assert-equal '(nil . v) (xdr! tst-pairs-six 'v))<br>(test::assert-equal '(nil . v) tst-pairs-six) | 
 | join | Function<br> | root<br><br> | (join car cdr)<br> <br>Create a pair with the provided car and cdr.<br><br> | (def 'tst-pair-one (join 1 2))<br>(test::assert-equal 1 (car tst-pair-one))<br>(test::assert-equal 2 (cdr tst-pair-one))<br>(test::assert-equal '(1 2 3) (join 1 (join 2 (join 3 nil)))) | 
 | cdr | Function<br> | root<br><br> | (cdr pair)<br><br>Return the cdr (second item) from a pair.  If used on a proper list this will be the list minus the first element.<br><br> | (def 'tst-pairs-three (list 'x 'y 'z))<br>(test::assert-equal '(y z) (cdr tst-pairs-three))<br>(test::assert-equal nil (cdr '(10)))<br>(test::assert-equal '(13) (cdr '(9 13)))<br>(test::assert-equal '(11 13) (cdr '(9 11 13))) | 

## Unknown forms


 | form | type | namespace | usage | example | 
 | ---- | ---- | ---- | ---- | ---- | 
 | and | SpecialForm<br> | root<br><br> | (and exp0 ... expN) -> [nil or expN result]<br><br>Evaluates each form until one produces nil (false), produces nil if any form is nil or the result of the last expression.<br><br>The and form will stop evaluting when the first expression produces nil.<br><br> | (test::assert-false (and nil (err "and- can not happen")))<br>(test::assert-equal "and- done" (and t "and- done"))<br>(test::assert-equal "and- done" (and t t "and- done"))<br>(test::assert-equal 6 (and t t (+ 1 2 3)))<br>(test::assert-equal 6 (and (/ 10 5) (* 5 2) (+ 1 2 3))) | 
 | = | Function<br> | root<br><br> | (= val0 ... valN)<br><br>Equals.  Works for int, float or string.<br><br> | (test::assert-false (= 1 2))<br>(test::assert-true (= 2 2))<br>(test::assert-true (= 2 2 2))<br>(test::assert-false (= 3 2 2))<br>(test::assert-false (= 3.0 2.0))<br>(test::assert-true (= 2.0 2.0))<br>(test::assert-true (= 2.0 2.0 2.0))<br>(test::assert-false (= 3.0 2.0 2.0))<br>(test::assert-false (= 2.1 2.0 3.0))<br>(test::assert-false (= 2 1))<br>(test::assert-false (= 3 2 1))<br>(test::assert-false (= 1.1 1.0))<br>(test::assert-true (= 1.1 1.1))<br>(test::assert-false (= 3 2 3))<br>(test::assert-false (= "aab" "aaa"))<br>(test::assert-true (= "aaa" "aaa"))<br>(test::assert-true (= "aaa" "aaa" "aaa"))<br>(test::assert-false (= "aaa" "aaaa" "aaa"))<br>(test::assert-false (= "ccc" "aab" "aaa"))<br>(test::assert-false (= "aaa" "aab")) | 
 | <= | Function<br> | root<br><br> | (<= val0 ... valN)<br><br>Less than or equal.  Works for int, float or string.<br><br> | (test::assert-true (<= 1 2))<br>(test::assert-true (<= 2 2))<br>(test::assert-true (<= 2 2 2))<br>(test::assert-true (<= 2 2 3))<br>(test::assert-true (<= 1.0 2.0))<br>(test::assert-true (<= 2.0 2.0))<br>(test::assert-true (<= 2.0 2.0 2.0))<br>(test::assert-true (<= 2.0 2.0 3.0))<br>(test::assert-false (<= 2.1 2.0 3.0))<br>(test::assert-false (<= 2 1))<br>(test::assert-false (<= 3 2 3))<br>(test::assert-true (<= "aaa" "aab"))<br>(test::assert-true (<= "aaa" "aaa"))<br>(test::assert-true (<= "aaa" "aab" "ccc"))<br>(test::assert-false (<= "baa" "aab")) | 
 | >= | Function<br> | root<br><br> | (>= val0 ... valN)<br><br>Greater than or equal.  Works for int, float or string.<br><br> | (test::assert-false (>= 1 2))<br>(test::assert-true (>= 2 2))<br>(test::assert-true (>= 2 2 2))<br>(test::assert-true (>= 3 2 2))<br>(test::assert-true (>= 3.0 2.0))<br>(test::assert-true (>= 2.0 2.0))<br>(test::assert-true (>= 2.0 2.0 2.0))<br>(test::assert-true (>= 3.0 2.0 2.0))<br>(test::assert-false (>= 2.1 2.0 3.0))<br>(test::assert-true (>= 2 1))<br>(test::assert-true (>= 1.1 1.0))<br>(test::assert-false (>= 3 2 3))<br>(test::assert-true (>= "aab" "aaa"))<br>(test::assert-true (>= "aaa" "aaa"))<br>(test::assert-true (>= "ccc" "aab" "aaa"))<br>(test::assert-false (>= "aaa" "aab")) | 
 | if | SpecialForm<br> | root<br><br> | (if condition then-form else-form?) -> [evaled form result]<br><br>If then else conditional.<br><br> | (def 'test-if-one<br>    (if t "ONE TRUE" "ONE FALSE"))<br>(def 'test-if-two<br>    (if nil "TWO TRUE" "TWO FALSE"))<br>(test::assert-equal "ONE TRUE" test-if-one)<br>(test::assert-equal "TWO FALSE" test-if-two)<br><br>(def 'test-if-one2<br>    (if t "ONE2 TRUE"))<br>(def 'test-if-two2<br>    (if nil "TWO2 TRUE"))<br>(test::assert-equal "ONE2 TRUE" test-if-one2)<br>(test::assert-equal nil test-if-two2) | 
 | or | SpecialForm<br> | root<br><br> | (or exp0 ... expN) -> [nil or first non nil expression]<br><br>Evaluates each form until one produces a non-nil result, produces nil if all expressions are nil.<br><br>The or form will stop evaluting when the first expression produces non-nil.<br><br> | (test::assert-true (or nil nil t (err "and- can not happen")))<br>(test::assert-false (or nil nil nil))<br>(test::assert-equal "or- done" (or nil "or- done"))<br>(test::assert-equal "or- done" (or nil nil "or- done"))<br>(test::assert-equal 6 (or nil nil (+ 1 2 3)))<br>(test::assert-equal 2 (or (/ 10 5) (* 5 2) (+ 1 2 3))) | 
 | null | Function<br> | root<br><br> | (null expression)<br><br>Return true if expression is nil (null).<br><br> | (test::assert-true (null nil))<br>(test::assert-false (null 10))<br>(test::assert-false (null t))<br>(test::assert-false (null (+ 1 2 3))) | 
 | not | Function<br> | root<br><br> | (not expression)<br><br>Return true if expression is nil.<br><br> | (test::assert-true (not nil))<br>(test::assert-false (not 10))<br>(test::assert-false (not t))<br>(test::assert-false (not (+ 1 2 3))) | 
 | > | Function<br> | root<br><br> | (> val0 ... valN)<br><br>Greater than.  Works for int, float or string.<br><br> | (test::assert-false (> 1 2))<br>(test::assert-false (> 2 2))<br>(test::assert-false (> 2 2 2))<br>(test::assert-false (> 3 2 2))<br>(test::assert-true (> 3.0 2.0))<br>(test::assert-false (> 2.0 2.0))<br>(test::assert-false (> 2.0 2.0 2.0))<br>(test::assert-false (> 3.0 2.0 2.0))<br>(test::assert-false (> 2.1 2.0 3.0))<br>(test::assert-true (> 2 1))<br>(test::assert-true (> 3 2 1))<br>(test::assert-true (> 1.1 1.0))<br>(test::assert-false (> 3 2 3))<br>(test::assert-true (> "aab" "aaa"))<br>(test::assert-false (> "aaa" "aaa"))<br>(test::assert-true (> "ccc" "aab" "aaa"))<br>(test::assert-false (> "aaa" "aab")) | 
 | < | Function<br> | root<br><br> | (< val0 ... valN)<br><br>Less than.  Works for int, float or string.<br><br> | (test::assert-true (< 1 2))<br>(test::assert-true (< 1 2 3 4))<br>(test::assert-false (< 2 2))<br>(test::assert-false (< 2 2 2))<br>(test::assert-false (< 2 2 3))<br>(test::assert-true (< 1.0 2.0))<br>(test::assert-false (< 2.0 2.0))<br>(test::assert-false (< 2.0 2.0 2.0))<br>(test::assert-false (< 2.0 2.0 3.0))<br>(test::assert-false (< 2.1 2.0 3.0))<br>(test::assert-false (< 2 1))<br>(test::assert-false (< 3 2 3))<br>(test::assert-true (< "aaa" "aab"))<br>(test::assert-false (< "aaa" "aaa"))<br>(test::assert-true (< "aaa" "aab" "ccc"))<br>(test::assert-false (< "baa" "aab")) | 

