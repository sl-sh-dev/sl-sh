<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="TODO PC MACROS crate wish list"><title>bridge_macros - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bridge_macros" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bridge_macros/index.html">bridge_<wbr>macros</a><span class="version">0.11.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#enums">Crate Items</a></h3><ul class="block"><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bridge_macros</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bridge_macros/lib.rs.html#1-1982">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>TODO PC MACROS crate wish list</p>
<ol>
<li>The macro should fail if the structure of the docs is not as expected. e.g. Type/Namespace/…/Usage/Example/</li>
<li>type aliasing, need a gensym type macro so I do not conflict with names.</li>
<li>trybuild tests!</li>
<li>worry about inlining, e.g. are the mechanisms in place to do the type conversions constant time,
and inlined? or is there a way to make them so?</li>
<li>can yet another crate solve the problem of housing typehandle/passingstyle/param/errorstrings/typedwrapper in the same place?</li>
<li>EVERY macro doesn’t need the check for VarArgs, only signatures that have
VarArgs, this can be addressed in the macro.</li>
<li>Port tuple tests: <a href="https://github.com/sl-sh-dev/sl-sh/blob/83cd1c93d1eea726ba138a83610155bdbfcab7aa/src/builtins_types.rs#L628">https://github.com/sl-sh-dev/sl-sh/blob/83cd1c93d1eea726ba138a83610155bdbfcab7aa/src/builtins_types.rs#L628</a></li>
<li>To avoid needing to do lifetimes, if the return value is one of the INPUT values have
that marked in the annotation… OTHERWISE data may be copied!
OR allow for simple lifetimes?</li>
<li>VMError should not be new_vm</li>
<li>Optional duplicates code. With the ownership model from SlFromRef, being <em>the</em> primary mechanism
for crossing the boundary, it’s possible having Some and None blocks multiple times is not necessary.</li>
<li>Support for slices? to avoid Vec allocation? Is it a big deal to only be able to accept Vec?
The decision should at least be documented.</li>
<li>SINCE WHEN is it a requirement like that it <em>has</em> to return VMResult or Option</li>
</ol>
</div></details><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.RustType.html" title="enum bridge_macros::RustType">Rust<wbr>Type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="enum" href="enum.SupportedGenericReturnTypes.html" title="enum bridge_macros::SupportedGenericReturnTypes">Supported<wbr>Generic<wbr>Return<wbr>Types</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.POSSIBLE_ARG_TYPES.html" title="constant bridge_macros::POSSIBLE_ARG_TYPES">POSSIBLE_<wbr>ARG_<wbr>TYPES</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="constant" href="constant.POSSIBLE_RETURN_TYPES.html" title="constant bridge_macros::POSSIBLE_RETURN_TYPES">POSSIBLE_<wbr>RETURN_<wbr>TYPES</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="constant" href="constant.SPECIAL_ARG_TYPES.html" title="constant bridge_macros::SPECIAL_ARG_TYPES">SPECIAL_<wbr>ARG_<wbr>TYPES</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.are_args_valid.html" title="fn bridge_macros::are_args_valid">are_<wbr>args_<wbr>valid</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>Optional and VarArgs types are supported to create the idea of items that might be provided or
for providing a list of zero or more items that can be passed in.
The nature of optional and varargs are context dependent because variable numbers of
arguments have to be at the end of the function signature. This method verifies that items
marked as Optional are last, and VarArgs is supported but only in the last position, which can
be after any number of Optional arguments. This means non Optional/VarArgs types must
come before all Optional and VarArgs types.</dd><dt><a class="fn" href="fn.embed_params_vec.html" title="fn bridge_macros::embed_params_vec">embed_<wbr>params_<wbr>vec</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>create a vec literal of the expected Param types so code can check its arguments at runtime for
API arity/type correctness.</dd><dt><a class="fn" href="fn.generate_assertions_code_for_return_type_conversions.html" title="fn bridge_macros::generate_assertions_code_for_return_type_conversions">generate_<wbr>assertions_<wbr>code_<wbr>for_<wbr>return_<wbr>type_<wbr>conversions</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.generate_builtin_fn.html" title="fn bridge_macros::generate_builtin_fn">generate_<wbr>builtin_<wbr>fn</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>write the builtin_ version of the provided function. This function is the function that makes
a direct call to the original rust native function to which the macro was applied. To accomplish
this the builtin_ function generates takes some number of ArgType structs (the wrapper enum that
enables passing optional and varargs). the body of the function handles unwrapping the ArgType
variables and then unwrapping the Expressions those contain into the proper rust native
function. The process is done in a for loop but it recursively builds the body of builtin_
by passing around a token stream.</dd><dt><a class="fn" href="fn.generate_inner_fn_signature_to_orig_fn_call.html" title="fn bridge_macros::generate_inner_fn_signature_to_orig_fn_call">generate_<wbr>inner_<wbr>fn_<wbr>signature_<wbr>to_<wbr>orig_<wbr>fn_<wbr>call</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>create two lists that can be joined by macro syntax to create the inner part of a function
signature, e.g. (arg_0: a_type, arg_1: b_type, …) in some existing rust function:
fn myfn(arg_0: a_type, arg_1: b_type, …) { … }</dd><dt><a class="fn" href="fn.generate_intern_fn.html" title="fn bridge_macros::generate_intern_fn">generate_<wbr>intern_<wbr>fn</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>write the intern_ function code. This code is generated to be called within sl-sh to avoid writing
boilerplate code to submit a function symbol and the associated code to the runtime. Every builtin
function must be inserted into a hashmap where the key is the name of the function and the value
is a function expression that stores the name of the rust function to call and its documentation.
It looks like the following in all cases:</dd><dt><a class="fn" href="fn.generate_parse_fn.html" title="fn bridge_macros::generate_parse_fn">generate_<wbr>parse_<wbr>fn</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>write the parse_ version of the provided function. The function it generates takes an environment
and a list of Value, evaluates those expressions and then maps the provided list of expressions
to a list of ArgType values. To accomplish this information from compile time, arg_types,
is manually inserted into this function. This way the evaluated list of args and the expected
list of args can be compared and the appropriate vector of arguments can be created and
passed to the builtin function. To map a vector of ArgType structs to an actual function
call the ExpandVecToArgs trait is used. A sample parse_ function for a function that takes
one argument is shown below.</dd><dt><a class="fn" href="fn.generate_sl_sh_fn.html" title="fn bridge_macros::generate_sl_sh_fn">generate_<wbr>sl_<wbr>sh_<wbr>fn</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>this function outputs all the generated code, it is composed into two different functions:
intern_&lt;original_fn_name&gt;
parse_&lt;original_fn_name&gt;</dd><dt><a class="fn" href="fn.get_arg_pos.html" title="fn bridge_macros::get_arg_pos">get_<wbr>arg_<wbr>pos</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_attribute_name_value.html" title="fn bridge_macros::get_attribute_name_value">get_<wbr>attribute_<wbr>name_<wbr>value</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_attribute_value_with_key.html" title="fn bridge_macros::get_attribute_value_with_key">get_<wbr>attribute_<wbr>value_<wbr>with_<wbr>key</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_bool_attribute_value_with_key.html" title="fn bridge_macros::get_bool_attribute_value_with_key">get_<wbr>bool_<wbr>attribute_<wbr>value_<wbr>with_<wbr>key</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_const_params_len_ident.html" title="fn bridge_macros::get_const_params_len_ident">get_<wbr>const_<wbr>params_<wbr>len_<wbr>ident</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_documentation_for_fn.html" title="fn bridge_macros::get_documentation_for_fn">get_<wbr>documentation_<wbr>for_<wbr>fn</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>Pull out every #doc attribute on the target fn for the proc macro attribute.
Ignore any other attributes and only Err if there are no #doc attributes.</dd><dt><a class="fn" href="fn.get_generic_argument_from_type.html" title="fn bridge_macros::get_generic_argument_from_type">get_<wbr>generic_<wbr>argument_<wbr>from_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_generic_argument_from_type_path.html" title="fn bridge_macros::get_generic_argument_from_type_path">get_<wbr>generic_<wbr>argument_<wbr>from_<wbr>type_<wbr>path</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_intern_fn_name.html" title="fn bridge_macros::get_intern_fn_name">get_<wbr>intern_<wbr>fn_<wbr>name</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>return the function names the macro will create. Given a base name, <base>
return intern_<base> Ident to be used as function name</dd><dt><a class="fn" href="fn.get_param_from_type.html" title="fn bridge_macros::get_param_from_type">get_<wbr>param_<wbr>from_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_parse_fn_name.html" title="fn bridge_macros::get_parse_fn_name">get_<wbr>parse_<wbr>fn_<wbr>name</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>return the function names the macro will create. Given a base name, <base>
return parse_<base> Ident to be used as function name</dd><dt><a class="fn" href="fn.get_parser_for_type_handle.html" title="fn bridge_macros::get_parser_for_type_handle">get_<wbr>parser_<wbr>for_<wbr>type_<wbr>handle</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_return_type.html" title="fn bridge_macros::get_return_type">get_<wbr>return_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>returns the option of inner type and the wrapped generic type (None if it’s
not generic. If there is no return type None, None is returned. Throws
an error if the generic return type is not in the list of predefined
constants POSSIBLE_RESULT_TYPES.</dd><dt><a class="fn" href="fn.get_type_handle.html" title="fn bridge_macros::get_type_handle">get_<wbr>type_<wbr>handle</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.get_type_or_wrapped_type.html" title="fn bridge_macros::get_type_or_wrapped_type">get_<wbr>type_<wbr>or_<wbr>wrapped_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>at this point the macro is only operating on types it expects
which are any rust types, any rust types wrapped in Option,
and any rust types wrapped in Vec. If in the future this is
confusing wrapper types can be made, i.e. SlshVarArgs,
so normal rust Vec could be used without being turned into
a SlshVarArgs</dd><dt><a class="fn" href="fn.is_valid_generic_type.html" title="fn bridge_macros::is_valid_generic_type">is_<wbr>valid_<wbr>generic_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.is_vec.html" title="fn bridge_macros::is_vec">is_vec</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>None if not Rust type vec</dd><dt><a class="fn" href="fn.make_orig_fn_call.html" title="fn bridge_macros::make_orig_fn_call">make_<wbr>orig_<wbr>fn_<wbr>call</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>generate an (optionally inlined) call to the original fn with the names of all of the variables,
arg_names, filled in,, e.g. <code>fn myfn(arg_0, arg_1, arg_2, ...) { ... }</code>.
This function also inserts a dynamic check to throw an error if too many
arguments were provided based on the signature of the target function.</dd><dt><a class="fn" href="fn.no_parse_param.html" title="fn bridge_macros::no_parse_param">no_<wbr>parse_<wbr>param</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.num_required_args.html" title="fn bridge_macros::num_required_args">num_<wbr>required_<wbr>args</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.opt_is_valid_generic_type.html" title="fn bridge_macros::opt_is_valid_generic_type">opt_<wbr>is_<wbr>valid_<wbr>generic_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.parse_attributes.html" title="fn bridge_macros::parse_attributes">parse_<wbr>attributes</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.parse_direct_type.html" title="fn bridge_macros::parse_direct_type">parse_<wbr>direct_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>for regular Value values (no Optional/VarArgs) ref_exp
just needs to be matched based on it’s ExpEnum variant.</dd><dt><a class="fn" href="fn.parse_fn_arg_type.html" title="fn bridge_macros::parse_fn_arg_type">parse_<wbr>fn_<wbr>arg_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>recursively wrap the received sl_sh args at the given idx in callback functions that parse the Expressions
into the a variable with a predefined  name with the same type as the corresponding parameter
in the rust native function.</dd><dt><a class="fn" href="fn.parse_optional_type.html" title="fn bridge_macros::parse_optional_type">parse_<wbr>optional_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>for <a href="https://doc.rust-lang.org/1.88.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;Value&gt;</code></a> values the ref_exp must first be parsed as an
Option, and only in the case that the option is Some will it be
necessary to match against every ExpEnum variant.</dd><dt><a class="fn" href="fn.parse_param.html" title="fn bridge_macros::parse_param">parse_<wbr>param</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.parse_src_function_arguments.html" title="fn bridge_macros::parse_src_function_arguments">parse_<wbr>src_<wbr>function_<wbr>arguments</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>Create a <a href="https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;Param&gt;</code></a> from the original fn’s signature. Information is needed at compile and
run time to translate the list of sl_sh expressions to rust native types. This Arg types
stores the information about the rust native type (Value/Option/Var) as well as whether it’s moved, passed
by reference, or passed by mutable reference.</dd><dt><a class="fn" href="fn.parse_type.html" title="fn bridge_macros::parse_type">parse_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>create the nested match statements to parse rust types into sl_sh types.
the rust types will determine what sl_sh functions will be used for
transformation. If this function throws errors it means that the
inputs, val/passing style are wrong and aren’t matching to the ArgType(s)
properly, or the rust type lookup function is busted.</dd><dt><a class="fn" href="fn.parse_type_tuple.html" title="fn bridge_macros::parse_type_tuple">parse_<wbr>type_<wbr>tuple</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.parse_variadic_args_type.html" title="fn bridge_macros::parse_variadic_args_type">parse_<wbr>variadic_<wbr>args_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>if expecting a Vec then the actual expression itself should be iterable
(Pair/Vector/Nil), set arg_name_itself_is_iter = true. Otherwise it’s
varargs which means the original args vector is passed in and
iterated over. the implication of passing in Vec is that if the Exp
doesn’t match one of a few underlying sl-sh types passing it to
this function is an error.</dd><dt><a class="fn" href="fn.tokens_for_matching_references.html" title="fn bridge_macros::tokens_for_matching_references">tokens_<wbr>for_<wbr>matching_<wbr>references</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>return a code for how to refer to the inner exp enum referent type in
an function call.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.MacroResult.html" title="type bridge_macros::MacroResult">Macro<wbr>Result</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><dl class="item-table"><dt><a class="attr" href="attr.sl_sh_fn.html" title="attr bridge_macros::sl_sh_fn">sl_<wbr>sh_<wbr>fn</a></dt><dd>macro that creates a bridge between rust native code and sl-sh code. Specify the lisp
function name to be interned with the “fn_name” attribute. This macro outputs
a function with a slosh compatible signature as well as a helper intern function
to be called with the environment to add the function.</dd></dl></section></div></main></body></html>