searchState.loadedDescShard("sl_compiler", 0, "Data for the current namespace\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemoves a key from the map, returning the value at the key …\nSet a given function’s original <code>Value</code> function so that …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompile a value “out of the way” of the let bindings …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhen doing destructuring we need to turn ‘vec’ and ‘…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCall lambda with args, this is re-entrant.\nBuiltin eval implementation.  Tries to avoid compilation …\nExecute a chunk that may not be rooted, will make sure any …\nTakes a PathBuf, if it contains ~ then replaces it with …\nFind file name the first time it appears in the global …\nWith the given reader, for each sexp compile then load and …\nPeek the next char and return Ok(true) if it signals an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReader for the ‘#’ builtin reader macro.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume the Reader and return the internal Char iter.")