searchState.loadedDescShard("slvm", 0, "This module controls access to two different floating …\nFast, non-cryptographic hash used by rustc and Firefox.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe F56 struct represents a 56-bit floating point number …\nThis module contains F56, a 7-byte struct that represents …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe F56 struct represents a 56-bit floating point number …\nTODO PC #125 this ticket is outdated now but this may need …\nReturns true if the F56 is NaN. Note that there are many …\nReturns true if the relative difference between the two …\nReturns true if the two F56s’s decimal forms are equal …\nReturns true if the two F56s are bitwise identical\nTODO PC #125 this ticket is outdated now but this may need …\nType alias for a hashmap using the <code>fx</code> hash algorithm.\nType alias for a hashmap using the <code>fx</code> hash algorithm.\nA speedy hash algorithm for use within rustc. The hashmap …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the line number that corresponds to the current_ip …\nReturn the current offset (IP) for the frame using …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf val is on the heap is it still alive after GC Return …\nPause garbage collection. Each pause_gc must have an …\nUnPause garbage collection. Each pause_gc must have an …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nMark the object at index immutable.\nCalls <code>U::from(self)</code>.\nIs the object at index still alive after GC.\nIs the object at index mutable.\nFor any dead, live bit not set, objects in heap set them …\nWrapper class for a HashMap&lt;Value, Value&gt;.  We need this …\nIterator over the key vals in a HashMap.\nIterator over the keys in a HashMap.\nProvides a wrapper to allow us to build a hashmap with …\nClear (remove all key/values) from the HashMap.\nDoes this HashMap contain key?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMake a ValHash from a Value.\nGet the value at key, requires the current VM for hashing.\nInsert the value at key, requires the current VM for …\nInsert val at the key id provided.  This allows calling …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this HashMap empty?\nReturn an iterator over all the (key, value) pairs in the …\nReturns an iterator over all the keys in the HashMap.\nNumber of items in the HashMap.\nCreate a new empty HashMap.\nRemove key from the HashMap.  Return the old value if it …\nRemove the key from HashMap (like remove) except caller …\nCreate a new empty HashMap with an initial capacity.\nReturn the amount of memory allocated by the interner.\nTrue if name is an interned symbol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf name is interned then return it, otherwise None.\nIntern name in this interner.  Will return the existing …\nIntern name in this interner.  Will return the existing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre there no symbols in this interner?\nReturn the number of symbols in the interner.\nReturn the amount of memory used to store symbols in the …\nCreate an interner with capacity cap (to the next power of …\nADD A B - set R(A) = R(A) + R(B)\nAPND A B C - R(A) = append lists R(B)..R(C) (R(B) and R(C) …\nCALL A B C - Call fn R(A) with B args with R(C) as first …\nCALLG A B C - Call fn G[A] with B args with R(C) as first …\nCALLM A B - Call current fn with B args with R(C) as first …\nCAR A B - R(A) = car(R(B))\nCCC A B - call with continuation, R(A) must be a lambda …\nCDR A B - R(A) = cdr(R(B))\nCLR A - Clear the collection in R(A)\nCONS A B C - R(A) = conscell(R(B), R(C))\nCons cells\nDEC A B - Decrement the integer in R(A) by B\nDFR A - Add a lambda, R(A) to the deferred list.\nDFRPOP - Pop and call the last deferred lambda.\nDIV A B - set R(A) = R(A) / R(B)\nEQ A B C - R[A] is #t if objects in R[B] - R[C] …\nEQUAL A B C - R[A] is #t if objects in R[B] - R[C] …\nERR A B - raise error with key R(A) (must be keyword) and …\nFlow control\nINC A B - Increment the integer in R(A) by B\nISERR A B - R(A) is #t if R(B) is an error type, #f …\nISOK A B - R(A) is #f if R(B) is an error type, #t …\nJumps, all jumps use a signed 24 bit OFFSET (high bit is …\nJMPEQ A B OFFSET - compare A and B and jump to IP + OFFSET …\nJMPF A OFFSET - Jump to current IP + OFFSET if R(A) is …\nJMPGT A B OFFSET - compare A and B and jump to IP + OFFSET …\nJMPLT A B OFFSET - compare A and B and jump to IP + OFFSET …\nJMPNU A OFFSET - Jump to current IP + OFFSET if R(A) is …\nJMPRNU A B OFFSET - Jump to current IP + OFFSET if any in …\nJMPRU A B OFFSET - Jump to current IP + OFFSET if any in …\nJMPT A OFFSET - Jump to current IP + OFFSET if R(A) is …\nJMPU A OFFSET - Jump to current IP + OFFSET if R(A) is …\nLEN A B - R(A) = length of data in R(B)\nLIST A B C - R(A) = list(elements R(B)..R(C)) (R(B) and …\nMAPMK A B C - R(A) = map(elements R(B)..R(C)) (R(B) …\nMKERR A B C - R(A) = error with key R(B) (must be keyword) …\nMUL A B - set R(A) = R(A) * R(B)\nNOT A B - R[A] is #t if R[B] is falsey and #f otherwise\nNUMEQ A B C - compare (=) in register B (inclusive) to C …\nNUMGT A B C - compare (&gt;) in register B (inclusive) to C …\nNUMGTE A B C - compare (&gt;=) in register B (inclusive) to C …\nNUMLT A B C - compare (&lt;) in register B (inclusive) to C …\nNUMLTE A B C - compare (&lt;=) in register B (inclusive) to C …\nONERR A - Make R(A) the current error handler and put the …\nSTR A B C - R(A) = string concatenated from objects in …\nStrings\nSUB A B - set R(A) = R(A) - R(B)\nTCALL A B - Tail Call fn R(A) with B args with existing …\nTCALLG A B - Tail Call fn G[A] with B args with existing …\nTCALLM B - Tail Call current fn with B args with existing …\nTYPE A B - R(A) = type(R(B)) as a StringConst\nTypes\nVEC A B C - R(A) = vec(elements R(B)..R(C)) (R(B) …\nVECELS A B - make the length of vec in R(A) R(B)\nVECMK A B - make a vector with R(B) elements and put it in …\nVECPOP A B - pop from vec in R(A) to R(B)\nVECPSH A B - push R(B) into vec in R(A)\nXAR A B - car(R(A)) = R(B)\nXDR A B - cdr(R(A)) = R(B)\nHandle points to a String on the heap.\nReplace with float::F32Wrap if desired\nStore a 7 byte int (i56…).\nIntended for symbols that are compiled.\nValue is a placeholder only, should never appear at …\nEnum representing the various types of values in Slosh.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTake the inner representation of <code>Value</code>::Int, and turn it …\nGet the hash of a value making sure that strings (whether …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn an <code>i64</code> into the inner representation of <code>Value</code>::Int\nReturns an iterator over all values in the list, vector, …\nReturns an iterator over all values in the list, vector, …\nSets a global to val.  The value needs have local numbers …\nMap a <code>Value</code> to a <code>ValueType</code> which can be written to a debug …\nSize (in elements/Values) of the stack.\nHold state of the VM, this is for making re-entrant calls …\nAllocate an Error on the heap.\nAllocate a Value on the heap.  Moving a value to the heap …\nAllocate a Value on the heap.  Moving a value to the heap …\nVm functions to handle runtime calling of anything …\nClear out the unused optional regs. Will clear working set …\nImplementation of the DEC bytecode.\nRuns a lambda.  Will save and restore the VM state even on …\nExecutes chunk.  Will save the current VM state and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the builtin function at idx. Note, will panic if …\nImplementation of the INC bytecode.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ntest if the operands are = (more lenient than identical)\nMain function to match and execute anything that is …\nBuild a call frame to be placed on the stack before …\nSet the internal registers pointer, do this when the …\nPause garbage collection. Each pause_gc must have an …\nReturn the register for idx.\nReturn the int representation of register idx or error if …\nReturn the current register for idx, if it is stored on …\nReset the VM to default settings.  Useful for cleaning up …\nRestore saved VM state (for cleaning up after re-entrant …\nReturn the current VM state (for re-entrant VM calls).\nSetup the rest (&amp;) arguments for a callable.\nVm code to access storage, heap, stack, globals, etc.\nIf we are tail calling a builtin with no call frame then …\nUnPause garbage collection. Each pause_gc must have an …\nVerify the number of args provided will work with a chunk.\nSpecial macro for NUMEQ that uses approximate equality for …\nConvert a numeric Value into an f64 float primitive\nConvert a Value into an i64 integer primitive if possible\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")