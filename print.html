<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Slosh Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Slosh Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>This is a real shell and scripting language that at least two people really
use each day. They really use it on the CLI and they really use it to write
scripts because they want to use a real language in the terminal and they want
that same language to be available for scripting. There's one huge and
wonderful catch, it's a lisp!</p>
<h1 id="as-a-shell"><a class="header" href="#as-a-shell">As a shell</a></h1>
<p>As a shell slosh does not differ much from bash at all. It supports pipes,
redirects, ... etc.  You could replace your grandmother's shell with slosh and
as long as you ported her prompt verbatim she probably would not notice.</p>
<h1 id="as-a-language"><a class="header" href="#as-a-language">As a language</a></h1>
<p>Slosh is inspired by clojure and scheme. It is a type 1 lisp.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Lisp is a truly novel family of languages. Every year new developers
discover <a href="https://xkcd.com/297/">what many people have discovered long before
them</a>.</p>
<p>Some of them go on to realize that using a lisp regularly in the terminal could
not only enhance their skills as a developer but potentially open them up to a
whole world of automation and fun by interacting with software that sparks joy.
This could result in a renaissance of custom functionality spread lovingly throughout
their systems. Despite its portability, we do not believe we should write any
more bash code because it has never, and will never, result in "library" code;
it's been decades! This means everything you do with it is a dead-end. There
is no momentum, and no standing on the shoulders of those that came before you.
Over time, we hope to change that.</p>
<p>The docs are heavily under development as we transition from our old legacy
tree based interpreter (sl-sh) to the register based virtual machine
implementation of the language (slosh).</p>
<h1 id="docs-todos"><a class="header" href="#docs-todos">DOCS todos</a></h1>
<p><a href="https://github.com/sl-sh-dev/sl-sh/wiki/">wiki of under construction / todo docs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-readme"><a class="header" href="#the-readme">The Readme</a></h1>
<img src="https://raw.githubusercontent.com/sl-sh-dev/sl-sh/gh-pages-legacy/images/sl-sh-ascii-logo.png" alt="sl-sh logo" style="max-width:100%;">
<h1 id="simple-lisp-shell-pronounced-slosh"><a class="header" href="#simple-lisp-shell-pronounced-slosh">Simple Lisp Shell (pronounced slosh)</a></h1>
<p><a href="https://github.com/sl-sh-dev/sl-sh/actions/workflows/rust.yml"><img src="https://github.com/sl-sh-dev/sl-sh/actions/workflows/rust.yml/badge.svg" alt="Rust" /></a></p>
<h2 id="note-this-is-a-new-experimental-version-see-legacy-for-the-original-version-slush"><a class="header" href="#note-this-is-a-new-experimental-version-see-legacy-for-the-original-version-slush">Note this is a new experimental version, see ./legacy/ for the original version (slush).</a></h2>
<p>Simple Lisp SHell (slosh) is a lisp based shell written in Rust. It is not POSIX
compliant and makes no effort to be. Sl-sh should run on any *nix platform as
well as macOS (CI currently only tests against ubuntu and macOS).It is a Lisp-1
that is heavily inspired by Clojure and Common Lisp. It is a shell, it is a
scripting language, and it is a REPL.</p>
<p>Some of the more prominent features:</p>
<ul>
<li>
<p>The terminal contains both a shell and a lisp reader so familiar bash-isms like</p>
<pre><code>cat file | tr -s " " | cut -d " " -f 2,4
</code></pre>
<p>"just work", but starting a command with a lisp form (an s-expression) allows:</p>
<pre><code>(dotimes 10 (prn "hello world"))
</code></pre>
<p>and the "boundary" can be easily crossed, the <code>$()</code> syntax calls out to the shell from within slosh code.</p>
<pre><code>(let ([pid, out] $(ls :&gt;)) (iter::for l in (iter::iter out) (pr l)))
</code></pre>
</li>
<li>
<p>Support for an rc/init file, <code>~/.config/slosh/init.slosh</code>, to set up environment and fully customize your prompt.</p>
</li>
<li>
<p>Common Lisp style macro system with support for quote and backquote (with clojure style ~ and ~@ expansion).</p>
</li>
<li>
<p>Dynamically Typed</p>
</li>
<li>
<p>Note lacks many features from legacy sl-sh but catching up (std lib is currently tiny).</p>
</li>
</ul>
<p>Contains these crates:</p>
<ul>
<li>slosh: a REPL with debugger and extensions that use compiler, includes shell functionality.</li>
<li>compiler: the core compiler code</li>
<li>compile_state: helper crate with state contained by a VM for use with compiler</li>
<li>vm: this is the bytecode VM that is target of the compiler</li>
<li>builtins: set of some core builtins</li>
<li>shell: contains shell specific code, this includes a shell reader (parser), job control etc</li>
<li>bridge_macros: macros for exported Rust functions as slosh functions</li>
<li>bridge_types: helper types for code using bridge_macros</li>
<li>slosh_test: everything in slosh plus some additional functionality and dependencies related to debugging.</li>
<li>legacy (excluded): original sl-sh version, more complete but slower and worse core shell support</li>
</ul>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>cargo run -p slosh</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="1-get-sl-sh"><a class="header" href="#1-get-sl-sh">1. Get sl-sh</a></h3>
<ul>
<li><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Install git</a>
<pre><code>git clone https://github.com/sl-sh-dev/sl-sh
cd slsh
</code></pre>
</li>
</ul>
<h3 id="2-build-sl-sh"><a class="header" href="#2-build-sl-sh">2. Build sl-sh</a></h3>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a> and build from source:
<pre><code>
cargo build -p slosh --release
./target/release/slosh
</code></pre>
</li>
</ul>
<h3 id="3-use-sl-sh-as-primary-shell"><a class="header" href="#3-use-sl-sh-as-primary-shell">3. Use sl-sh as primary shell</a></h3>
<ul>
<li>install binary</li>
</ul>
<pre><code>mkdir -p /usr/local/bin
sudo install -m 755 target/release/slosh /usr/local/bin/
</code></pre>
<ul>
<li>add slosh to /etc/shells and change login shell to slosh</li>
</ul>
<pre><code>echo /usr/local/bin/slosh | sudo tee -a /etc/shells
chsh -s /usr/local/bin/slosh
</code></pre>
<h3 id="4-optional-configure-slosh"><a class="header" href="#4-optional-configure-slosh">4. (Optional) Configure slosh</a></h3>
<p>The slosh configuration file lives at ~/.config/slosh/init.slosh. <br>
If you run slosh and the file does not exist, a default one will be created for you. <br>
Review your existing shell configuration files like ~/.bashrc and ~/.bash_profile and manually translate them to slosh syntax and add to your init.slosh file <br>
For example, <code>export JAVA_HOME="/usr/local/opt/openjdk@11/bin/java"</code> becomes <code>(sh "export JAVA_HOME='/usr/local/opt/openjdk@11/bin/java'")</code></p>
<h2 id="compiler"><a class="header" href="#compiler">Compiler</a></h2>
<p>These are a subset of sl-sh forms and most work exactly the same. See the
sl-sh docs at:
https://sl-sh-dev.github.io/sl-sh/</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h3>
<ul>
<li>True</li>
<li>False</li>
<li>Nil</li>
<li>String Constant</li>
<li>Symbol</li>
<li>Keyword</li>
<li>Character (chars are grapheme clusters)</li>
<li>Float (56 bit float)</li>
<li>Integer (56 bit signed integer)</li>
<li>Byte</li>
</ul>
<h3 id="heap-allocated-objects-complex-types"><a class="header" href="#heap-allocated-objects-complex-types">Heap allocated objects (complex types)</a></h3>
<ul>
<li>Pair/ConsCell</li>
<li>Vector</li>
<li>HashMap</li>
<li>String</li>
</ul>
<h3 id="special-forms"><a class="header" href="#special-forms">Special Forms</a></h3>
<p>The following special forms are currently in the compiler:</p>
<ul>
<li>def</li>
<li>set!</li>
<li>do</li>
<li>fn</li>
<li>macro</li>
<li>if</li>
<li>quote (')</li>
<li>back-quote (` supports ~ ~@)</li>
<li>and</li>
<li>or</li>
<li>err</li>
<li>let</li>
<li>call/cc</li>
<li>defer</li>
<li>on-error</li>
<li>while</li>
</ul>
<h3 id="compiled-forms"><a class="header" href="#compiled-forms">Compiled Forms</a></h3>
<p>Normal forms follow normal calling evaluation.
Note: These are all compiled to bytecode and once compiled are not dynamic anymore.</p>
<ul>
<li>not</li>
<li>recur</li>
<li>this-fn</li>
<li>type</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>*</li>
<li>/</li>
<li>inc!</li>
<li>dec!</li>
<li>list</li>
<li>list-append</li>
<li>cons</li>
<li>car</li>
<li>cdr</li>
<li>xar!</li>
<li>xdr!</li>
<li>vec</li>
<li>make-vec</li>
<li>vec-push!</li>
<li>vec-pop!</li>
<li>str</li>
<li>=</li>
<li>/=</li>
<li>&lt;</li>
<li>&lt;=</li>
<li>&gt;</li>
<li>&gt;=</li>
<li>eq?</li>
<li>equal?</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<ul>
<li>Lisp reader (no reader macros yet)</li>
<li>Lisp lists (pair/conscell based)</li>
<li>Vectors</li>
<li>Tail call optimization</li>
<li>Continuations (call/cc)</li>
<li>Lambda/Closures (supports optional and variadic arguments)</li>
<li>Garbage collection (basic but should function)</li>
<li>Lisp back quotes (including nested back quotes)</li>
<li>Macros</li>
</ul>
<h2 id="slosh"><a class="header" href="#slosh">slosh</a></h2>
<p>Slosh is the shell and scripting language REPL using the compiler, vm and shell crates.</p>
<h3 id="built-in-forms"><a class="header" href="#built-in-forms">Built-in Forms</a></h3>
<p>These forms (written in Rust but callable from Lisp) are supported.</p>
<ul>
<li>pr (print)</li>
<li>prn (println)</li>
<li>dasm (disassemble a lambda or closure)</li>
<li>load (load a lisp file and execute it)</li>
<li>vec-slice (new vec that is a slice of old vec)</li>
<li>vec-&gt;list (turn a vec to a list)</li>
<li>get-prop (get a property from an object- either a global variable or a heap object)</li>
<li>set-prop (set a property on an object- either a global variable or a heap object)</li>
<li>eval (eval an expression)</li>
</ul>
<h3 id="features-1"><a class="header" href="#features-1">Features</a></h3>
<ul>
<li>Line editor with history</li>
<li>Debug on error, currently useful for probing VM state only</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li>sl-sh legacy shell: https://github.com/sl-sh-dev/sl-sh/legacy</li>
</ul>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<ul>
<li>Install <a href="https://bencher.dev/docs/tutorial/quick-start/">bencher</a></li>
<li>To run benchmarks locally: <code>cargo bench</code></li>
<li>To upload benchmarks to bencher.dev: <code>bencher run "cargo bench"</code></li>
<li>Consider using iai in cloud: https://bencher.dev/learn/benchmarking/rust/iai/</li>
</ul>
<h3 id="generated-documentation"><a class="header" href="#generated-documentation">Generated documentation</a></h3>
<p>The <a href="https://sl-sh-dev.github.io/sl-sh/">documentation site</a> is served from the <code>doc</code> directory
based on the <code>doc/mk-site.sh</code> script referenced in the github action <code>.github/workflows/gh_pages.yml</code>.</p>
<p>Documentation can be built and viewed locally as the documentation site is a static set of html files
generated from the source code.</p>
<p>All of this is covered in <code>doc/README.md</code></p>
<p>Must be compiled in lisp-test mode for appropriate documentation functions to be present (<code>cargo build --features lisp-test</code>).</p>
<h1 id="dev-notes"><a class="header" href="#dev-notes">Dev Notes</a></h1>
<h2 id="development-tools"><a class="header" href="#development-tools">Development Tools</a></h2>
<h3 id="just-and-the-justfile"><a class="header" href="#just-and-the-justfile">Just and the Justfile</a></h3>
<p><a href="https://github.com/casey/just">Just</a> is a command runner much like make, but with a simpler syntax.</p>
<p>Optionally, you can <a href="https://github.com/casey/just?tab=readme-ov-file#packages">install Just</a> and use it to help easily test or build slosh.</p>
<p>You can also read the Justfile in the root directory to see the common commands that we use to test and build the project.</p>
<br>
<p>To verify you've installed Just, run <code>just</code> in the project root which should list all available commands.</p>
<p>Now you can run <code>just test</code> instead of the verbose <code>sh scripts/check-clippy-version.sh &amp;&amp; cargo fmt &amp;&amp; cargo clippy &amp;&amp; cargo test --workspace</code>.</p>
<p>It's also possible to <a href="https://github.com/casey/just?tab=readme-ov-file#shell-completion-scripts">set up shell completion scripts</a> which makes it quite quick to find the right command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-shell-commands-in-lisp"><a class="header" href="#using-shell-commands-in-lisp">Using shell commands in lisp</a></h1>
<p>Slosh can easily be used to launch processes in lisp mode (e.g. in a script).
Interacting with the input and output of those programs can be done in a variety
of ways.</p>
<h2 id="two-main-flavors-of-starting-shell-processes"><a class="header" href="#two-main-flavors-of-starting-shell-processes">Two main flavors of starting shell processes</a></h2>
<ol>
<li><em>The $sh variety</em> which is a little clunky as you directly pass it a string, as seen in the let binding.</li>
<li><em>The $ reader macro</em> which treats everything as a string but allows escaping slosh variables
directly in the shell with macro-like syntax <code>~</code></li>
</ol>
<pre><code>(defn parse-git-branch () (let (branch ($sh "git rev-parse --abbrev-ref HEAD 2&gt;/dev/null"))
    (if (= branch "")
            (str "")
                    (do $(export BRANCH_NAME=~branch)
                                (str "(" branch ")")))))
</code></pre>
<p>~ under construction ~</p>
<p>instead of (sh "wc" "-l")
we have $(wc -l)
(def v "foo")
$(echo ~foo)
$(echo ~v)</p>
<h2 id="calling-shell-commands-in-lisp-code"><a class="header" href="#calling-shell-commands-in-lisp-code">calling shell commands in lisp code</a></h2>
<h3 id="3-ways"><a class="header" href="#3-ways">3 ways</a></h3>
<ul>
<li>
<p>$() - reader-macro - convenient because it interprets everything as a string - can be used with macro like ~</p>
</li>
<li>
<p>(sh "") - regular function, but you have to pass it a string
** $() &amp; (sh) are very similar.</p>
</li>
<li>
<p>($sh ) - like backticks, call to shell, and get back a slosh string, e.g. run this command and give me the output
but we do not have a reader macro yet.</p>
<ul>
<li>this is not implemented w/ a reader macro but could be something like $(( )) except that might be ugly</li>
<li>($sh "git rev-parse --abbrev-ref HEAD 2&gt;/dev/null")</li>
<li>this returns a string, does more work for you</li>
<li>(sh "git rev-parse --abbrev-ref HEAD 2&gt;/dev/null")</li>
<li>Returns the exit status if foreground and the PID if background. Add the '&amp;' to the string to background it.</li>
</ul>
</li>
</ul>
<pre><code>NOTE:
on the CLI typing $() directly on the REPL, but if you wrapped it in say a (do $()) it would work, REPL isn't smart enough yet to
pass the $() to the LISP repl 
</code></pre>
<h3 id="bash-precedent"><a class="header" href="#bash-precedent">bash precedent</a></h3>
<ul>
<li>diff &lt;(echo "1\n2\n3") &lt;(echo "echo 1\n\1\n3")</li>
<li>https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html#Process-Substitution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Still figuring this out currently allows things like this (syntax will probably change):</p>
<p>Current iteration uses :&lt; (same as :0&lt;) to connect a file stdin and :&gt; (same as :1&gt;) to connect a file to stdout. These can also be used with file descriptors (for example :2&gt; will connect a file to stderr). They can be mixed with other shell redirects and will just become part of the redirect stack. Each lisp redirect will return a file in a list (first element will be the PID of the final process).</p>
<p>Examples:
(let ([pid, out] (sh "ls" :&gt;)) (iter::for l in (iter::iter out) (pr l)))</p>
<p>(let ([pid, out, er] (sh "ls vm/src/ sdsdf" :&gt; :2&gt;))(prn "PID: " pid) (iter::for l in (iter::iter out)(pr "from out: " l))(iter::for l in (iter::iter er)(pr "from err: " l)</p>
<p>Set the lisp pipe then use a shell redirect to also send stderr to the same pipe:
(let ([pid, out] (sh "ls vm/src/ sdsdf" :&gt; "2&gt;&amp;1"))(prn "PID: " pid) (iter::for l in (iter::iter out)(pr "from grep: " l)))</p>
<p>(let ([pid, in, out] (sh :&lt; "grep XX" :&gt;))(prn "PID: " pid) (fprn in "XXsls")(fprn in "sls")(fprn in "dfdXX")(fclose in)(iter::for l in (iter::iter out)(pr "from grep: " l)))</p>
<p>(same as above but include a pipe between shell commands)
(let ([pid, in, out] (sh :&lt; "grep XX | cat -" :&gt;)) (fprn in "XXsls")(fprn in "sls")(fprn in "dfdXX")(fclose in)(iter::for l in (iter::iter out)(pr l)))</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slosh-containercomplex-data-types"><a class="header" href="#slosh-containercomplex-data-types">slosh container/complex data types</a></h1>
<p>TODO</p>
<ul>
<li>char/char literal</li>
<li>bytes</li>
<li>vec</li>
<li>numbers / number literals</li>
<li>boolean literals</li>
</ul>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>A string.  Strings in slosh are UTF8 encoded and are composed of chars that are
UTF grapheme clusters.  Because of the encoding strings can be indexed but they
must be traversed to find an index (i.e. they are indexed by 'chars' not bytes).</p>
<p>Read only string constants can be created with double quotes in the Reader.
For instance: (def str-const "Some String Const")</p>
<p>A mutable string can be created with the 'str' form, for instance:
(def string (str "Some val: " val))</p>
<p>Characters at index can be accessed with dot notation (see Vector).</p>
<p>Other string functions:</p>
<ul>
<li>str: concats all the values provided (as strings) to produce a new string (mutable)</li>
<li>str-replace</li>
<li>str-trim</li>
<li>str-trim!</li>
<li>str-contains</li>
<li>str-push!</li>
<li>str-map</li>
<li>str-empty?</li>
<li>str-starts-with</li>
<li>str-split</li>
<li>char-whitespace?</li>
</ul>
<h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<p>A vector (dynamic array) of values.  Typically a vector will be created with the
'[' reader macro (expands to (vec ...)) for instance:
(def vector[1 2 3])
Vectors can be indexed with 'dot' notation (dot is a reader macro that expends
to a (get x index) for x.index.  For example:
(let (v [1 2 3])
(prn v.0 ", " v.1 ", " v.2))
Dot notation can also be used with set! to set elements:
(let (v [1 2 3])
(set! v.0 10)
(set! v.1 20)
(set! v.2 30)
(prn v.0 ", " v.1 ", " v.2))</p>
<p>Other vector functions:</p>
<ul>
<li>vec: longform for '[]' syntax, prefer using brackets</li>
<li>make-vec: takes a capacity and default value, makes a vector of that size with all values set to default</li>
<li>vec-push!: destructive, pushes a new value to the end of a vec (increases len by one)</li>
<li>vec-pop!: destructive, pops the last value from a vector and returns it (decreases vector len by one)</li>
<li>vec-slice: takes a vector, start index and optional end index (defaults to end of vector), returns a new vec of elements start (inclusive) end (exclusive)</li>
</ul>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>A map of key/value pairs.  Use the '{' reader macro to create a hashmap:
(def hm {:x 1, :y 2, :z 3})
Use dot notation (see vectors) to access and set keys:
(let (hm {:x 1, :y 2, :z 3})
(set! hm.:x 10)
(set! hm.:y 20)
(set! hm.:z 30)
(prn hm.:x ", " hm.:y ", " hm.:z))</p>
<p>Other hashmap function:</p>
<ul>
<li>make-hash: longform for '{}' reader macro, prefer '{}'</li>
</ul>
<h2 id="pairconscelllist"><a class="header" href="#pairconscelllist">Pair/ConsCell/List</a></h2>
<p>This is a traditional Lisp conscell data type, pair of values (car, cdr).  It can
be used to create a linked list of values.</p>
<p>Other Pair function:</p>
<ul>
<li>car</li>
<li>cdr</li>
<li>list</li>
<li>list-append</li>
<li>cons</li>
<li>xar!</li>
<li>xdr!</li>
</ul>
<h2 id="common-functions"><a class="header" href="#common-functions">Common functions</a></h2>
<p>These should all work on any of the containers.</p>
<ul>
<li>len: return the length of the container</li>
<li>clear!: destructive form to remove all elements from the container</li>
<li>set!: with dot notation to set an element of a container (see Vector and HashMap)</li>
<li>dot notation: this is a reader macro the expends to (get val index) for val.index</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality"><a class="header" href="#equality">Equality</a></h1>
<p>The most common way to test equality is with <code>=</code>
For numeric equality (IEEE) use <code>==</code>
For bytewise equality use <code>identical?</code></p>
<p>The behavior and names are based on Clojure's implementation. Read their docs here: https://clojure.org/guides/equality
Also check out <code>slosh/tests/equality.slosh</code> for some examples.</p>
<ul>
<li>
<p><code>=</code></p>
<ul>
<li>
<p><code>(= 2 0x2)</code> is <code>true</code> (comparing an int to a byte)</p>
</li>
<li>
<p><code>(= 2 2.0)</code> is <code>false</code> (comparing an int to a float)</p>
</li>
<li>
<p><code>(= 0.0 -0.0)</code> is <code>true</code></p>
</li>
<li>
<p><code>(= NaN NaN)</code> is <code>false</code></p>
</li>
<li>
<p><code>state.rs</code> defines special forms object with key <code>equal</code> mapped to the name <code>=</code>.</p>
</li>
<li>
<p><code>compile.rs</code> matches on <code>env.specials().equal</code> and generates opcode <code>EQUAL</code></p>
</li>
<li>
<p><code>exec_loop.rs</code> maps opcode <code>EQUAL</code> to function <code>is_equal</code></p>
</li>
<li>
<p><code>vm.rs</code> <code>is_equal</code> converts each arg to a <code>Value</code> (in case it needs to be dereferenced) and calls <code>is_equal_pair</code></p>
</li>
<li>
<p><code>vm.rs</code> <code>is_equal_pair</code> does a complex test for equality</p>
<ul>
<li>check if both args are Byte or Int and if so, converts both to <code>i64</code> with <code>Value::get_int</code> and compares with
rust native <code>==</code></li>
<li>check if both args are numbers (Byte, Int, or Float) and if so, converts both to <code>f64</code> with <code>Value::get_float</code>
and compares with rust native <code>==</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>==</code></p>
<ul>
<li>
<p><code>(== 1 1.0)</code> is <code>true</code> (comparing an int to a float)</p>
</li>
<li>
<p><code>(== 0.0 -0.0)</code> is <code>true</code></p>
</li>
<li>
<p><code>(== NaN NaN)</code> is <code>false</code></p>
</li>
<li>
<p>returns true whenever <code>=</code> does, but also returns true for numbers that are numerically equal</p>
</li>
<li>
<p>when comparing two floats, converts two both to <code>f64</code> and compares with native f64 <code>==</code></p>
</li>
<li>
<p>does not use F56::PartialEq implementation</p>
</li>
<li>
<p><code>state.rs</code> defines special forms object with key <code>numeq</code> mapped to the name <code>==</code>.</p>
</li>
<li>
<p><code>compile.rs</code> calls <code>compile_list</code> which calls <code>compile_special</code> which calls <code>compile_math</code> in <code>compile_math.rs</code></p>
</li>
<li>
<p><code>compile_math.rs</code> <code>compile_math</code> matches on <code>env.specials().numeq</code> and generates opcode <code>NUMEQ</code></p>
</li>
<li>
<p><code>exec_loop.rs</code> maps opcode <code>NUMEQ</code> to function <code>compare_numeric</code> and passes a comparator <code>|a,b| a == b</code></p>
</li>
<li>
<p><code>macros.rs</code> <code>compare_numeric</code></p>
<ul>
<li>checks if either argument is a <code>Float</code> and if so, converts both to <code>f64</code> with <code>get_primitive_float</code> macro and
uses the comparator</li>
<li>checks if either argument is a <code>Int</code> and if so, converts both to <code>i64</code> with <code>get_primitive_int</code> macro and uses
the comparator</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>identical?</code></p>
<ul>
<li>
<p><code>(identical? 1 1)</code> is <code>true</code></p>
</li>
<li>
<p><code>(identical? 1 1.0)</code> is <code>false</code> (different types)</p>
</li>
<li>
<p><code>(identical? 0.0 -0.0)</code> is <code>false</code> (comparing floats with different bit patterns)</p>
</li>
<li>
<p><code>(identical? NaN NaN)</code> might be <code>true</code> or <code>false</code>. There are trillions of different bit patterns that represent
NaN in IEEE 754</p>
</li>
<li>
<p>is the only equality comparison that uses <code>Value::PartialEq</code> implementation which is always false for different
types of Values</p>
</li>
<li>
<p>using identical equality for floats causes problems with hashing.
<a href="https://github.com/sl-sh-dev/sl-sh/issues/125">#125</a>
identical equality is 'too strict' in that you probably expect that +0 and -0 should hash to the same thing, but
they don't
rendering hash tables</p>
</li>
<li>
<p><code>state.rs</code> defines special forms object with key <code>eq</code> mapped to the name <code>identical?</code>.</p>
</li>
<li>
<p><code>compile.rs</code> matches on <code>env.specials().eq</code> and generates opcode <code>EQ</code></p>
</li>
<li>
<p><code>exec_loop.rs</code> maps opcode <code>EQ</code> to function <code>is_identical</code></p>
</li>
<li>
<p><code>vm.rs</code> <code>is_identical</code> converts each arg to a <code>Value</code> (in case it needs to be dereferenced) and
compares <code>val1 == val2</code> which uses <code>Value::PartialEq</code> implementation</p>
</li>
</ul>
</li>
<li>
<p><code>assert-equal</code></p>
<ul>
<li>based on <code>=</code></li>
<li>is a macro defined in core.slosh which checks if the arguments are <code>=</code> and throws an error if they are not</li>
</ul>
</li>
<li>
<p><code>not=</code></p>
<ul>
<li>defined in <code>vm/core.slosh</code> as the negation of <code>=</code></li>
</ul>
</li>
<li>
<p><code>not==</code></p>
<ul>
<li>defined in <code>vm/core.slosh</code> as the negation of <code>==</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">ERRORS</a></h1>
<h2 id="error-type"><a class="header" href="#error-type">Error Type</a></h2>
<p>The error type consists of an identifying keyword and a data/payload value.  This
value is typically a string but can be any valid value.</p>
<p>(type [error]) returns :Error
The form (car [error]) returns the keyword identifying this error.
The form (cdr [error]) returns the data value for the error.
Note the use of car/cdr to pull apart an error even though it is not of the pair type.
Use (mk-err :[ID] value) to create an error type or (err :[ID] value) to "raise" an error (see below).</p>
<h2 id="raising-an-error"><a class="header" href="#raising-an-error">Raising an error</a></h2>
<p>Runtime errors will be "raised".  This means the program execution will halt and the debugger will be entered.  Currently this only allows examining the running state but will eventually include the ability to modify state and restart as other Lisps allow.  Code can raise an error with the err form, for instance (err :some-error-type "This is my error") will raise an error and interrupt the program.</p>
<p>Note, the (get-error FORM+) form can be used to programmatically return a raised error instead of breaking to the debugger.</p>
<h2 id="returning-an-error"><a class="header" href="#returning-an-error">Returning an error</a></h2>
<p>Code can return an error instead of breaking into the debugger.  Use the (mk-err :[ERROR ID] vallue) to create an error and then use it as any other value (return it from a function for instance).  This may be appropriate for a common error that does not warrent breaking to the debugger.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>See the docs string for:</p>
<ul>
<li>err</li>
<li>mk-err</li>
<li>err?</li>
<li>ok?</li>
<li>get-error</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sloshlisp-syntax-and-macros"><a class="header" href="#sloshlisp-syntax-and-macros">Slosh/Lisp syntax and macros</a></h1>
<p>The core unit of a Lisp is a form:</p>
<pre><code class="language-slosh">42

;; =&gt; 42
</code></pre>
<pre><code class="language-slosh">+

;; =&gt; #&lt;SpecialFn(+)&gt;
</code></pre>
<pre><code class="language-slosh">(list 1 2)

;; =&gt; (1 2)
</code></pre>
<pre><code class="language-slosh">;; The quote symbol means return the literal form after the character
;; This is identical to the form above.
'(1 2)

;; =&gt; (1 2)
</code></pre>
<p>are forms. All
lisp code is structured as a sequence of forms inside forms separated by whitespace.</p>
<p>Expressions are enclosed in parentheses and Lisp uses prefix notation to parse expressions.
A parenthesized expression is a list of forms: <code>(list 1 2 3 4)</code> where the first
form, the head, should generally be a function or a macro and dictates what the expression will do,
and the subsequent children are arguments to the head.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Single-line comments start with a <code>;</code> character and continue till the end of the line</p>
<pre><code class="language-slosh">; (prn "hello")
(prn "world")

;; =&gt; "world"
</code></pre>
<p>Multi-line comments start with the <code>#|</code> characters to start and ends with the sample symbols reversed <code>|#</code>.</p>
<pre><code class="language-slosh">#|
(prn "oh")
(prn "hello")
|#
(prn "world")

;; =&gt; "world"
</code></pre>
<p>Single forms can be commented out with <code>#;</code> characters. This directive tells the reader to discard the form.</p>
<pre><code class="language-slosh">#;(prn "oh")
#;(prn "hello")
(prn "world")

;; =&gt; "world"
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Any symbol that is used with <code>def</code> or <code>defn</code> can also bind documentation. Documentation
is multiline and is delimited with <code>#%</code> characters to start and ends with the same symbols reversed <code>%#</code>.</p>
<pre><code class="language-slosh">#%
Usage: (login SECRET)

Returns true if logged in false if not. Must use `SECRET`

Section: secrets

Example:
(assert-false (login "foo"))
%#
(defn login (secret)
    (if (= secret "helloworld")
        #t
        #f))


#%
Usage: (login SECRET)

Returns documentation for given symbol as map. Keyword is a documentation fragment
(usage, section, description, example) and value is text describing given fragment.

Section: secrets

Example:

(assert-false (login SECRET))
%#
(def SECRET "helloworld")
(prn (login SECRET))

;; =&gt; "true"
</code></pre>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Helper macros syntax exists like in other lips such as:
quote (<code>'</code>),
quasiquote (<code>`</code>),
unquote (<code>~</code>),
unquote-splice (<code>~@</code>),
macro, and
defmacro.</p>
<pre><code>(defmacro dotimes
    ;; This macro accepts times, some number, as well as some number of forms to be evaluated.
    (times &amp; body)

    ;; To avoid creating a variable name in the existing scope (gensym helps
    ;; with the creation of hygenic macros in slosh) is used and
    ;; the symbol i-name is assigned some random name.
    (let (i-name (gensym))

    ;; The quasiquote is used within the body of the macro to specify that all forms
    ;; inside the parentheses should have an implicit quote in front of them. This
    ;; way, by default, the macro will return an ast with the literal forms, as opposed to the
    ;; evaulauted forms; forms can be evaluated in the resultant ast with the unquote.

    `(let (~i-name 0)

        ;; i-iname and times are unquoted so they are evaluated ("escaping the
        ;; quasiquote") in the resultant ast returning numerical values instead
        ;; of symbols that evaluate to themselves.
        (while (&lt; ~i-name ~times)

            ;; Since body is a list, it utilizes the unquote-splice operator, to
            ;; expand each of its elements into the resultant ast, in the case
            ;; of dotimes `body` in intended to be some number of forms that
            ;; should be executed on each invocation.
            ~@body

            ;; because i-name is a symbol defined in the outer scope use unquote
            ;; so the resultant ast outputs `(inc! random-var-nmae)` rather than
            ;; (inc! i-name). `i-name` is not a symbol in scope in the resultant ast,
            ;; ~i-name evaluates to a symbol that is in scope in the resultant
            ;; ast.
            (inc! ~i-name)))))
</code></pre>
<p>NOTE:
The quasiquote is a quality of life macro helper, that obviates the need to
add a single quote to every list and every form in the body of your macro. It
is particularly useful in macros because often times many of the symbols you
want returned in a macro are the literal symbols you want in the output ast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<h1 id="todo-pcsls-docs"><a class="header" href="#todo-pcsls-docs">TODO PC/sls docs</a></h1>
<p><a href="https://github.com/sl-sh-dev/sl-sh/pull/181">this is the PR where iterators first went in to slosh</a>
<a href="https://www.tfeb.org/fragments/2024/05/15/an-iteration-construct-for-common-lisp/">inspiration for our iterators</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-lisp-debugger"><a class="header" href="#simple-lisp-debugger">Simple Lisp Debugger</a></h1>
<ul>
<li><code>:abort</code>
<ul>
<li>exit the debugger.</li>
</ul>
</li>
<li><code>:globals</code>
<ul>
<li>prints all the globals</li>
</ul>
</li>
<li><code>:dasm</code>
<ul>
<li>show the bytecode</li>
</ul>
</li>
<li><code>:regs</code>
<ul>
<li>show stack that's available, e.g. the view of the stack your function has</li>
</ul>
</li>
<li><code>:stack</code>
<ul>
<li>show call stack</li>
</ul>
</li>
<li><code>:regs-raw</code>
<ul>
<li>TODO sls fix me</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-bindings"><a class="header" href="#let-bindings">LET Bindings</a></h1>
<h2 id="basic-form"><a class="header" href="#basic-form">Basic form</a></h2>
<p>(let ([name value]<em>) forms</em>)</p>
<p>Let will create a new lexical scope and will bind names to local variables with provided values. After the binding it is
an implicit do form. The bound symbols will only be in scope within this implicit do. Afterwards they will be unbound
or will revert to their previous shadowed value.</p>
<p>Note all bindings are required to be pairs (name value), name is a symbol and value can be any form (it will be
evaluated).</p>
<p>Let will shadow any variable names from outer scopes (including globals), it does not interact with dynamic scopes at
all.
Let is similar to let-rec in scheme, the bindings are created in order and later binding can see the values of previous
bindings. It will also allow an early reference to "see" a later binding (like let-rec) allowing some recursive forms to
be bound easily. Note that when doing this the later form must NOT be something being shadowed or the existing binding
will be used not the new one in the let.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-slosh">(let (a 1, b 2, c 3) `(~a ~b ~c))

;; =&gt; (1 2 3)
</code></pre>
<p>Produces (1 2 3)</p>
<pre><code class="language-slosh">(let (a 1, b 2, c 3) (let (b 20, c (+ b 10)) `(~a ~b ~c)))

;; =&gt; (1 20 30)
</code></pre>
<p>Produces (1 20 30)</p>
<pre><code class="language-slosh">(let (a 1, b 2, c 3) (let (x (+ b 1), b 20, c (+ b 10)) `(~a ~x ~b ~c)))

;; =&gt; (1 3 20 30)
</code></pre>
<p>Produces (1 3 20 30)</p>
<pre><code class="language-slosh">(let (fnx (fn (x) (if (= x 0) #t (fny (- x 1))))
      fny (fn (y) (if (= y 0) #t (fnx (- y 1)))))
    (fnx 10))

;; =&gt; true
</code></pre>
<p>Example of recursive references (a dumb one). It will produce #t (true) after ping ponging between fnx and fny.</p>
<pre><code class="language-slosh">(let (fny (fn (y) y))
    (let (fnx (fn (x) (if (= x 0) #t (fny (- x 1))))
          fny (fn (y) (if (= y 0) #t (fnx (- y 1)))))
        (fny 10)))

;; =&gt; 8
</code></pre>
<p>This example will produce 8 because fnx will use the outer fny instead of the next fny.</p>
<h2 id="destructure-bindings"><a class="header" href="#destructure-bindings">Destructure bindings</a></h2>
<p>Let supports destructure bindings of sequences (list, vector) and hashmaps. It can support optional bindings as well
as rest (&amp;) for sequences.</p>
<p>For sequences use [name+], if &amp; is before the last name then it will get all the leftover values. A % indicates that all
the names after are optional (default to nil) and you can use := to set the default value. Patterns must match exactly,
for instance [a b c] requires a sequence with exactly three elements.  [a b c &amp; rest] requires a sequence with at least
three elements.  [% a b c &amp; rest] will take any sequence and bind the first, second and third values to a b and c if
available.</p>
<p>For maps use {[name key]+} (i.e. a map of symbols to keys), if this map contains :or then it's value will be a map of
key to default value used for any missing keys. It requires all keys to be included in the destructured map or to have a
default.</p>
<p>Note that destructures can be applied recursively and sequence destructure can contain map destructures and vice versa.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-slosh">(def x '(1 2 3))
(let ([a b c] x) `(~a ~b ~c))

;; =&gt; (1 2 3)
</code></pre>
<p>Produces (1 2 3).</p>
<pre><code class="language-slosh">(let ([a b % c d] '(1 2)) (list a b c d))

;; =&gt; (1 2 nil nil)
</code></pre>
<p>Produces (1 2 nil nil).</p>
<pre><code class="language-slosh">(let ({a :one, b 'two, c "three" [d e] :vec} {:one 1, 'two 2, "three" 3, :vec [4 5]}) (list a b c d e))

;; =&gt; (1 2 3 4 5)
</code></pre>
<p>Produces (1 2 3 4 5).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Namespaces are compiler bookkeeping for organizing global symbols.  When in a namespace then any symbols that are defined will have the current NAMESPACE:: prepended to the symbol.  When symbols are resolved the compiler will also try to prepend the current namespace first in order to find the symbol.</p>
<h2 id="entering-a-namespace"><a class="header" href="#entering-a-namespace">Entering a namespace</a></h2>
<p>From code use the <code>with-ns</code> form.</p>
<pre><code class="language-slosh">(doc 'with-ns)

;; =&gt; "Usage: (with-ns SYMBOL sexp+)
;;    
;;    Create a namespace and compile sexp+ within it.  Restore the previous namespace when scope ends.
;;    THe symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
;;    This will cause all globals defined to have namespace:: prepended.
;;    This will also clear any existing imports.
;;    
;;    Section: namespace
;;    
;;    Example:
;;    (with-ns test-with-ns
;;        (def ttf (fn () '(1 2 3)))
;;        (test::assert-equal '(1 2 3) (ttf))
;;        (test::assert-equal '(1 2 3) (test-out::ttf)))
;;    (test::assert-equal '(1 2 3) (test-out::ttf))
;;    "
</code></pre>
<p>From the top-level REPL you can use 'ns'.</p>
<pre><code class="language-slosh">(doc 'ns)

;; =&gt; "Usage: (ns SYMBOL)
;;    
;;    Changes to namespace.  This is "open-ended" change and is intended for use with
;;    the REPL prefer with-ns for scripts.
;;    The symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
;;    This will cause all globals defined to have namespace:: prepended.
;;    This will also clear any existing imports.
;;    
;;    Section: namespace
;;    
;;    Example:
;;    (ns testing)
;;    (def x #t)
;;    (test::assert-true x)
;;    (ns ::)
;;    (test::assert-true testing::x)
;;    "
</code></pre>
<p>This is an open-ended namespace change intended for the repl, prefer with-ns for a scoped namespace in code.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Other namespaces can be imported to allow its symbols to be accessed in a shorter form.  Use the 'import' form for this .</p>
<pre><code class="language-slosh">(doc 'import)

;; =&gt; "Usage: (import namespace [:as symbol])
;;    
;;    Will import a namespace.  Without an :as then all symbols in the namespace will become available in the current
;;    namespace as if local.  With [:as symbol] then all namespace symbols become available with symbol:: prepended.
;;    
;;    Section: namespace
;;    
;;    Example:
;;    (ns testing)
;;    (def x #t)
;;    (test::assert-true x)
;;    (ns ::)
;;    (test::assert-true testing::x)
;;    (import testing)
;;    (test::assert-true x)
;;    (import testing :as t)
;;    (test::assert-true t::x)
;;    "
</code></pre>
<p>For instance using <code>(import iter)</code> will allow any symbols in the iter namespace to be used without prepending 'iter::'.  You can also use the <code>(import iter :as i)</code>, the :as form allows the namespace to be given a different name.  In this case the iter namespace could be replaced with 'i', (i::for ...) instead of (iter::for ...) for example.  Imports are resolved in the order they are compiled in case of conflict (i.e. the first import that resolves a symbol wins).  Imports are attached to the current namespace, changing namespaces will clear imports (note that 'with-ns' saves and restores the previous namespace with imports).</p>
<h2 id="loading-code"><a class="header" href="#loading-code">Loading code</a></h2>
<p>To load new code into your environment use load or run-script.</p>
<h3 id="load"><a class="header" href="#load">Load</a></h3>
<p>The load form should generally be preferred.  It will compile the code at compile time (vs runtime) and execute it at runtime.  This means:</p>
<ul>
<li>The path parameter has to be known at compile time: a string const, defined global or form that does not need local inputs.</li>
<li>Any symbols defined in the loaded code will be known to the compiler at compile time and available for use.</li>
</ul>
<pre><code class="language-slosh">(doc 'load)

;; =&gt; "Usage: (load path) -&gt; [last form value]
;;    
;;    Read and eval a file (from path- a string).  The load special form executes at compile time.
;;    This means it's parameter must resolve at compile time.  Most of the time you will want to use
;;    this in conjunction with 'with-ns' to namespace the contents.
;;    Note: on it's own does nothing with namespaces.
;;    
;;    Section: core
;;    
;;    Example:
;;    (comp-time (def test-temp-file (get-temp-file)) nil)
;;    (defer (fs-rm test-temp-file))
;;    (let (tst-file (fopen test-temp-file :create))
;;        (defer (fclose tst-file))
;;        (fprn tst-file "(with-ns test-load")
;;        (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
;;    (load test-temp-file) ; put stuff in it's own namespace
;;    (test::assert-equal '(1 2 3) (test-load::test-fn))
;;    
;;    
;;    (with-ns test-out2
;;        (comp-time
;;            (def test-temp-file (get-temp-file))
;;            (let (tst-file (fopen test-temp-file :create))
;;                (defer (fclose tst-file))
;;                (fprn tst-file "(defn test-fn () '(1 2 3))"))
;;            nil)
;;        (defer (fs-rm test-temp-file))
;;        (load test-temp-file) ; put new stuff in current namespace
;;        (test::assert-equal '(1 2 3) (test-fn))
;;        (test::assert-equal '(1 2 3) (test-out2::test-fn)))
;;    "
</code></pre>
<h3 id="run-script"><a class="header" href="#run-script">Run Script</a></h3>
<p>The run-script form loads each form in the file, compiles and executes it at runtime.  This means:</p>
<ul>
<li>It can take any parameter since it is resolved at runtime.</li>
<li>Globals it defines will NOT be known until after it runs at runtime.</li>
</ul>
<pre><code class="language-slosh">(doc 'run-script)

;; =&gt; "Usage: (run-script path) -&gt; [last form value]
;;    
;;    Read and eval a file (from path- a string).
;;    
;;    Section: scripting
;;    
;;    Example:
;;    (def test-load::test-fn)
;;    (with-temp-file (fn (tmp)
;;        (let (tst-file (fopen tmp :create))
;;            (defer (fclose tst-file))
;;            (fprn tst-file "(with-ns test-load")
;;            (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
;;        (run-script tmp)
;;        (test::assert-equal '(1 2 3) (test-load::test-fn))))
;;    "
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end-example-of-slosh-execution"><a class="header" href="#end-to-end-example-of-slosh-execution">End to End example of Slosh execution</a></h1>
<ol>
<li>Start with the lisp program <code>(1.1)</code></li>
<li>In <code>reader.rs</code></li>
</ol>
<ul>
<li>The <code>read_inner</code> function controls most parsing.
<ul>
<li>Numeric parsing happens at the end in the catch-all of the match statement.</li>
</ul>
</li>
<li>The <code>do_atom</code> function attempts to parse 1.1 as an i64 and fails, so it parses it as f64 and then calls <code>.into()</code> to convert to a <code>Value</code></li>
</ul>
<ol start="3">
<li>In <code>main.rs</code></li>
</ol>
<ul>
<li>The <code>exec_expression</code> function calls <code>pass1</code></li>
<li>And then it calls <code>compile</code></li>
</ul>
<ol start="4">
<li>In <code>pass1.rs</code></li>
</ol>
<ul>
<li>The <code>pass1</code> function initially operates on (1.1) as a pair or list</li>
<li>It iterates over each element of the list and recursively calls <code>pass1</code> on each element</li>
<li>So then <code>pass1</code> is called on 1.1 which is then handled in the catch-all of the match statement</li>
<li>and this is where we add 1.1 to the heap and add it is a constant to the vm</li>
</ul>
<ol start="5">
<li>In <code>state.rs</code></li>
</ol>
<ul>
<li><code>add_constant</code> is called which inserts the <code>Value</code> of 1.1 into <code>pub struct CompileState</code>'s <code>pub constants: HashMap&lt;Value, usize&gt;</code></li>
<li>Since constants are stored in a hashmap, if two different numeric constants hash to the same thing, they will be stored as the same constant</li>
</ul>
<ol start="6">
<li>In <code>float_56.rs</code></li>
</ol>
<ul>
<li><code>F56</code> impl's the <code>Hash</code> trait and has a custom implementation of <code>hash</code> that converts the <code>F56</code> to a <code>u64</code> and then hashes the result</li>
</ul>
<ol start="7">
<li>In <code>compile.rs</code></li>
</ol>
<ul>
<li>Recall that <code>exec_expression</code> called <code>compile</code> after <code>pass1</code></li>
<li>calls to <code>compile</code> trickle down into <code>compile_list</code>, <code>compile_special</code>, <code>compile_math</code>, and others.</li>
<li><code>compile_list</code> handles a single value like this and the match statement catch-all prints Boo and the value itself</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<details>
    <summary><strong>Does the syntax on the CLI differ from bash that much if at all?</strong></summary>
    <p>
    No, not really.
    </p>
</details>
<details>
    <summary><strong>Will sl-sh be supported on windows?</strong></summary>
    <p>
    Work is being done in <a href="https://github.com/sl-sh-dev/sl-liner">sl-liner</a> and <a href="https://github.com/sl-sh-dev/sl-console">sl-console</a> to make this possible but currently it is not supported.
    </p>
</details>
<details>
    <summary><strong>Is it any good?</strong></summary>
    <p>
    Yes
    </p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slosh-forms"><a class="header" href="#slosh-forms">Slosh Forms</a></h1>
<p>List of sections:</p>
<p><a href="src/generated-sections/all-slosh%20forms.html#section-char">char</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-collection">collection</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-conditional">conditional</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-conversion">conversion</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-core">core</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-doc">doc</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-file">file</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-hashmap">hashmap</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-io">io</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-iterator">iterator</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-math">math</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-namespace">namespace</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-pair">pair</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-random">random</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-scripting">scripting</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-sequence">sequence</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-shell">shell</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-string">string</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-system">system</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-test">test</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-type">type</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-undocumented">undocumented</a>, <a href="src/generated-sections/all-slosh%20forms.html#section-vector">vector</a></p>
<h2 id="section-char"><a class="header" href="#section-char">Section: char</a></h2>
<p><a href="src/generated-sections/char.html#char-lower">char-lower</a>, <a href="src/generated-sections/char.html#char-upper">char-upper</a>, <a href="src/generated-sections/char.html#char-whitespace">char-whitespace?</a></p>
<h2 id="section-collection"><a class="header" href="#section-collection">Section: collection</a></h2>
<p><a href="src/generated-sections/collection.html#clear">clear!</a>, <a href="src/generated-sections/collection.html#empty">empty?</a>, <a href="src/generated-sections/collection.html#flatten">flatten</a>, <a href="src/generated-sections/collection.html#in">in?</a>, <a href="src/generated-sections/collection.html#not-empty">not-empty?</a>, <a href="src/generated-sections/collection.html#reverse">reverse</a></p>
<h2 id="section-conditional"><a class="header" href="#section-conditional">Section: conditional</a></h2>
<p><a href="src/generated-sections/conditional.html#">&lt;</a>, <a href="src/generated-sections/conditional.html#">&lt;=</a>, <a href="src/generated-sections/conditional.html#">==</a>, <a href="src/generated-sections/conditional.html#">&gt;</a>, <a href="src/generated-sections/conditional.html#">&gt;=</a>, <a href="src/generated-sections/conditional.html#and">and</a>, <a href="src/generated-sections/conditional.html#cond">cond</a>, <a href="src/generated-sections/conditional.html#if">if</a>, <a href="src/generated-sections/conditional.html#match">match</a>, <a href="src/generated-sections/conditional.html#not">not</a>, <a href="src/generated-sections/conditional.html#or">or</a>, <a href="src/generated-sections/conditional.html#when">when</a></p>
<h2 id="section-conversion"><a class="header" href="#section-conversion">Section: conversion</a></h2>
<p><a href="src/generated-sections/conversion.html#-key">-&gt;key</a>, <a href="src/generated-sections/conversion.html#-sym">-&gt;sym</a>, <a href="src/generated-sections/conversion.html#def">def?</a>, <a href="src/generated-sections/conversion.html#ref">ref</a></p>
<h2 id="section-core"><a class="header" href="#section-core">Section: core</a></h2>
<p><a href="src/generated-sections/core.html#euid"><em>euid</em></a>, <a href="src/generated-sections/core.html#last-command"><em>last-command</em></a>, <a href="src/generated-sections/core.html#last-status"><em>last-status</em></a>, <a href="src/generated-sections/core.html#uid"><em>uid</em></a>, <a href="src/generated-sections/core.html#">=</a>, <a href="src/generated-sections/core.html#apply">apply</a>, <a href="src/generated-sections/core.html#back-quote">back-quote</a>, <a href="src/generated-sections/core.html#block">block</a>, <a href="src/generated-sections/core.html#comp-time">comp-time</a>, <a href="src/generated-sections/core.html#dec">dec!</a>, <a href="src/generated-sections/core.html#def">def</a>, <a href="src/generated-sections/core.html#defmacro">defmacro</a>, <a href="src/generated-sections/core.html#defn">defn</a>, <a href="src/generated-sections/core.html#do">do</a>, <a href="src/generated-sections/core.html#doc">doc</a>, <a href="src/generated-sections/core.html#doc-raw">doc-raw</a>, <a href="src/generated-sections/core.html#dotimes">dotimes</a>, <a href="src/generated-sections/core.html#dotimes-i">dotimes-i</a>, <a href="src/generated-sections/core.html#dump-globals">dump-globals</a>, <a href="src/generated-sections/core.html#dyn">dyn</a>, <a href="src/generated-sections/core.html#env">env</a>, <a href="src/generated-sections/core.html#err">err</a>, <a href="src/generated-sections/core.html#eval">eval</a>, <a href="src/generated-sections/core.html#exit">exit</a>, <a href="src/generated-sections/core.html#expand-macro">expand-macro</a>, <a href="src/generated-sections/core.html#fn">fn</a>, <a href="src/generated-sections/core.html#gensym">gensym</a>, <a href="src/generated-sections/core.html#get-error">get-error</a>, <a href="src/generated-sections/core.html#get-globals">get-globals</a>, <a href="src/generated-sections/core.html#get-prop">get-prop</a>, <a href="src/generated-sections/core.html#identity">identity</a>, <a href="src/generated-sections/core.html#inc">inc!</a>, <a href="src/generated-sections/core.html#is-noop">is-noop</a>, <a href="src/generated-sections/core.html#len">len</a>, <a href="src/generated-sections/core.html#let">let</a>, <a href="src/generated-sections/core.html#let-while">let-while</a>, <a href="src/generated-sections/core.html#load">load</a>, <a href="src/generated-sections/core.html#load-rc">load-rc</a>, <a href="src/generated-sections/core.html#loop">loop</a>, <a href="src/generated-sections/core.html#macro">macro</a>, <a href="src/generated-sections/core.html#mk-err">mk-err</a>, <a href="src/generated-sections/core.html#noop">noop</a>, <a href="src/generated-sections/core.html#noop-fn">noop-fn</a>, <a href="src/generated-sections/core.html#not">not=</a>, <a href="src/generated-sections/core.html#not">not==</a>, <a href="src/generated-sections/core.html#nsubstitute">nsubstitute!</a>, <a href="src/generated-sections/core.html#occurs">occurs</a>, <a href="src/generated-sections/core.html#on-raised-error">on-raised-error</a>, <a href="src/generated-sections/core.html#platform">platform</a>, <a href="src/generated-sections/core.html#quote">quote</a>, <a href="src/generated-sections/core.html#recur">recur</a>, <a href="src/generated-sections/core.html#set">set!</a>, <a href="src/generated-sections/core.html#set-env">set-env</a>, <a href="src/generated-sections/core.html#set-prop">set-prop</a>, <a href="src/generated-sections/core.html#sizeof-heap-object">sizeof-heap-object</a>, <a href="src/generated-sections/core.html#sizeof-value">sizeof-value</a>, <a href="src/generated-sections/core.html#substitute">substitute</a>, <a href="src/generated-sections/core.html#to-list">to-list</a>, <a href="src/generated-sections/core.html#to-vec">to-vec</a>, <a href="src/generated-sections/core.html#un-noop-fn">un-noop-fn</a>, <a href="src/generated-sections/core.html#unset-env">unset-env</a>, <a href="src/generated-sections/core.html#usage">usage</a></p>
<h2 id="section-doc"><a class="header" href="#section-doc">Section: doc</a></h2>
<p><a href="src/generated-sections/doc.html#build-doc">build-doc</a>, <a href="src/generated-sections/doc.html#doc-map">doc-map</a>, <a href="src/generated-sections/doc.html#doc-search">doc-search</a>, <a href="src/generated-sections/doc.html#get-exemptions">get-exemptions</a>, <a href="src/generated-sections/doc.html#get-globals-sorted">get-globals-sorted</a>, <a href="src/generated-sections/doc.html#legacy-report">legacy-report</a>, <a href="src/generated-sections/doc.html#legacyforms">legacy_forms</a></p>
<h2 id="section-file"><a class="header" href="#section-file">Section: file</a></h2>
<p><a href="src/generated-sections/file.html#cd">cd</a>, <a href="src/generated-sections/file.html#fclose">fclose</a>, <a href="src/generated-sections/file.html#fflush">fflush</a>, <a href="src/generated-sections/file.html#fopen">fopen</a>, <a href="src/generated-sections/file.html#fs-accessed">fs-accessed</a>, <a href="src/generated-sections/file.html#fs-base">fs-base</a>, <a href="src/generated-sections/file.html#fs-crawl">fs-crawl</a>, <a href="src/generated-sections/file.html#fs-dir">fs-dir?</a>, <a href="src/generated-sections/file.html#fs-exists">fs-exists?</a>, <a href="src/generated-sections/file.html#fs-file">fs-file?</a>, <a href="src/generated-sections/file.html#fs-fullpath">fs-fullpath</a>, <a href="src/generated-sections/file.html#fs-len">fs-len</a>, <a href="src/generated-sections/file.html#fs-modified">fs-modified</a>, <a href="src/generated-sections/file.html#fs-parent">fs-parent</a>, <a href="src/generated-sections/file.html#fs-rm">fs-rm</a>, <a href="src/generated-sections/file.html#fs-same">fs-same?</a>, <a href="src/generated-sections/file.html#get-temp">get-temp</a>, <a href="src/generated-sections/file.html#get-temp-file">get-temp-file</a>, <a href="src/generated-sections/file.html#glob">glob</a>, <a href="src/generated-sections/file.html#read">read</a>, <a href="src/generated-sections/file.html#read-all">read-all</a>, <a href="src/generated-sections/file.html#read-line">read-line</a>, <a href="src/generated-sections/file.html#temp-dir">temp-dir</a>, <a href="src/generated-sections/file.html#with-temp">with-temp</a>, <a href="src/generated-sections/file.html#with-temp-file">with-temp-file</a></p>
<h2 id="section-hashmap"><a class="header" href="#section-hashmap">Section: hashmap</a></h2>
<p><a href="src/generated-sections/hashmap.html#hash-clear">hash-clear!</a>, <a href="src/generated-sections/hashmap.html#hash-haskey">hash-haskey?</a>, <a href="src/generated-sections/hashmap.html#hash-keys">hash-keys</a>, <a href="src/generated-sections/hashmap.html#hash-remove">hash-remove!</a>, <a href="src/generated-sections/hashmap.html#make-hash">make-hash</a></p>
<h2 id="section-io"><a class="header" href="#section-io">Section: io</a></h2>
<p><a href="src/generated-sections/io.html#fs-meta">fs-meta</a></p>
<h2 id="section-iterator"><a class="header" href="#section-iterator">Section: iterator</a></h2>
<p><a href="src/generated-sections/iterator.html#enumerate">enumerate</a>, <a href="src/generated-sections/iterator.html#enumerate">enumerate</a>, <a href="src/generated-sections/iterator.html#file-iter">file-iter</a>, <a href="src/generated-sections/iterator.html#file-iter">file-iter</a>, <a href="src/generated-sections/iterator.html#filter">filter</a>, <a href="src/generated-sections/iterator.html#filter">filter</a>, <a href="src/generated-sections/iterator.html#for">for</a>, <a href="src/generated-sections/iterator.html#for">for</a>, <a href="src/generated-sections/iterator.html#iter">iter</a>, <a href="src/generated-sections/iterator.html#iter">iter</a>, <a href="src/generated-sections/iterator.html#iter-or-single">iter-or-single</a>, <a href="src/generated-sections/iterator.html#iter-or-single">iter-or-single</a>, <a href="src/generated-sections/iterator.html#iter">iter?</a>, <a href="src/generated-sections/iterator.html#iter">iter?</a>, <a href="src/generated-sections/iterator.html#list-iter">list-iter</a>, <a href="src/generated-sections/iterator.html#list-iter">list-iter</a>, <a href="src/generated-sections/iterator.html#map">map</a>, <a href="src/generated-sections/iterator.html#map">map</a>, <a href="src/generated-sections/iterator.html#mk-iter">mk-iter</a>, <a href="src/generated-sections/iterator.html#mk-iter">mk-iter</a>, <a href="src/generated-sections/iterator.html#once-iter">once-iter</a>, <a href="src/generated-sections/iterator.html#once-iter">once-iter</a>, <a href="src/generated-sections/iterator.html#range">range</a>, <a href="src/generated-sections/iterator.html#range">range</a>, <a href="src/generated-sections/iterator.html#reduce">reduce</a>, <a href="src/generated-sections/iterator.html#reduce">reduce</a>, <a href="src/generated-sections/iterator.html#repeat-iter">repeat-iter</a>, <a href="src/generated-sections/iterator.html#repeat-iter">repeat-iter</a>, <a href="src/generated-sections/iterator.html#string-iter">string-iter</a>, <a href="src/generated-sections/iterator.html#string-iter">string-iter</a>, <a href="src/generated-sections/iterator.html#vec-iter">vec-iter</a>, <a href="src/generated-sections/iterator.html#vec-iter">vec-iter</a>, <a href="src/generated-sections/iterator.html#vec-iter-pair">vec-iter-pair</a>, <a href="src/generated-sections/iterator.html#vec-iter-pair">vec-iter-pair</a>, <a href="src/generated-sections/iterator.html#vec-iter-rev">vec-iter-rev</a>, <a href="src/generated-sections/iterator.html#vec-iter-rev">vec-iter-rev</a></p>
<h2 id="section-math"><a class="header" href="#section-math">Section: math</a></h2>
<p><a href="src/generated-sections/math.html#">%</a>, <a href="src/generated-sections/math.html#">*</a>, <a href="src/generated-sections/math.html#euler"><em>euler</em></a>, <a href="src/generated-sections/math.html#pi"><em>pi</em></a>, <a href="src/generated-sections/math.html#">+</a>, <a href="src/generated-sections/math.html#-">-</a>, <a href="src/generated-sections/math.html#">/</a>, <a href="src/generated-sections/math.html#pow">2pow</a>, <a href="src/generated-sections/math.html#abs">abs</a>, <a href="src/generated-sections/math.html#arccos">arccos</a>, <a href="src/generated-sections/math.html#arcsin">arcsin</a>, <a href="src/generated-sections/math.html#arctan">arctan</a>, <a href="src/generated-sections/math.html#ceil">ceil</a>, <a href="src/generated-sections/math.html#cos">cos</a>, <a href="src/generated-sections/math.html#exp">exp</a>, <a href="src/generated-sections/math.html#floor">floor</a>, <a href="src/generated-sections/math.html#fract">fract</a>, <a href="src/generated-sections/math.html#log">log</a>, <a href="src/generated-sections/math.html#log">log2</a>, <a href="src/generated-sections/math.html#max">max</a>, <a href="src/generated-sections/math.html#min">min</a>, <a href="src/generated-sections/math.html#pow">pow</a>, <a href="src/generated-sections/math.html#rem">rem</a>, <a href="src/generated-sections/math.html#rem-euclid">rem-euclid</a>, <a href="src/generated-sections/math.html#round">round</a>, <a href="src/generated-sections/math.html#sin">sin</a>, <a href="src/generated-sections/math.html#sqrt">sqrt</a>, <a href="src/generated-sections/math.html#tan">tan</a></p>
<h2 id="section-namespace"><a class="header" href="#section-namespace">Section: namespace</a></h2>
<p><a href="src/generated-sections/namespace.html#get-in-namespace">get-in-namespace</a>, <a href="src/generated-sections/namespace.html#get-namespaces">get-namespaces</a>, <a href="src/generated-sections/namespace.html#import">import</a>, <a href="src/generated-sections/namespace.html#ns">ns</a>, <a href="src/generated-sections/namespace.html#with-ns">with-ns</a></p>
<h2 id="section-pair"><a class="header" href="#section-pair">Section: pair</a></h2>
<p><a href="src/generated-sections/pair.html#car">car</a>, <a href="src/generated-sections/pair.html#cdr">cdr</a>, <a href="src/generated-sections/pair.html#cons">cons</a>, <a href="src/generated-sections/pair.html#list">list</a>, <a href="src/generated-sections/pair.html#list-append">list-append</a>, <a href="src/generated-sections/pair.html#xar">xar!</a>, <a href="src/generated-sections/pair.html#xdr">xdr!</a></p>
<h2 id="section-random"><a class="header" href="#section-random">Section: random</a></h2>
<p><a href="src/generated-sections/random.html#probool">probool</a>, <a href="src/generated-sections/random.html#random">random</a>, <a href="src/generated-sections/random.html#random-seq">random-seq</a>, <a href="src/generated-sections/random.html#random-str">random-str</a></p>
<h2 id="section-scripting"><a class="header" href="#section-scripting">Section: scripting</a></h2>
<p><a href="src/generated-sections/scripting.html#run-script">run-script</a></p>
<h2 id="section-sequence"><a class="header" href="#section-sequence">Section: sequence</a></h2>
<p><a href="src/generated-sections/sequence.html#butlast">butlast</a>, <a href="src/generated-sections/sequence.html#first">first</a>, <a href="src/generated-sections/sequence.html#last">last</a>, <a href="src/generated-sections/sequence.html#rest">rest</a>, <a href="src/generated-sections/sequence.html#seq-for">seq-for</a></p>
<h2 id="section-shell"><a class="header" href="#section-shell">Section: shell</a></h2>
<p><a href="src/generated-sections/shell.html#sh">$sh</a>, <a href="src/generated-sections/shell.html#args"><em>args</em></a>, <a href="src/generated-sections/shell.html#shell-exe"><em>shell-exe</em></a>, <a href="src/generated-sections/shell.html#bg-color-rgb">bg-color-rgb</a>, <a href="src/generated-sections/shell.html#fg-color-rgb">fg-color-rgb</a>, <a href="src/generated-sections/shell.html#sh">sh</a>, <a href="src/generated-sections/shell.html#syntax-off">syntax-off</a>, <a href="src/generated-sections/shell.html#syntax-on">syntax-on</a>, <a href="src/generated-sections/shell.html#sys-command">sys-command?</a></p>
<h2 id="section-string"><a class="header" href="#section-string">Section: string</a></h2>
<p><a href="src/generated-sections/string.html#str">str</a>, <a href="src/generated-sections/string.html#str-append">str-append</a>, <a href="src/generated-sections/string.html#str-bytes">str-bytes</a>, <a href="src/generated-sections/string.html#str-cat-list">str-cat-list</a>, <a href="src/generated-sections/string.html#str-clear">str-clear!</a>, <a href="src/generated-sections/string.html#str-contains">str-contains</a>, <a href="src/generated-sections/string.html#str-empty">str-empty?</a>, <a href="src/generated-sections/string.html#str-lower">str-lower</a>, <a href="src/generated-sections/string.html#str-ltrim">str-ltrim</a>, <a href="src/generated-sections/string.html#str-map">str-map</a>, <a href="src/generated-sections/string.html#str-push">str-push!</a>, <a href="src/generated-sections/string.html#str-replace">str-replace</a>, <a href="src/generated-sections/string.html#str-rsplit">str-rsplit</a>, <a href="src/generated-sections/string.html#str-rsplitn">str-rsplitn</a>, <a href="src/generated-sections/string.html#str-rtrim">str-rtrim</a>, <a href="src/generated-sections/string.html#str-split">str-split</a>, <a href="src/generated-sections/string.html#str-splitn">str-splitn</a>, <a href="src/generated-sections/string.html#str-starts-with">str-starts-with</a>, <a href="src/generated-sections/string.html#str-sub">str-sub</a>, <a href="src/generated-sections/string.html#str-trim">str-trim</a>, <a href="src/generated-sections/string.html#str-trim">str-trim!</a>, <a href="src/generated-sections/string.html#str-upper">str-upper</a></p>
<h2 id="section-system"><a class="header" href="#section-system">Section: system</a></h2>
<p><a href="src/generated-sections/system.html#sleep">sleep</a></p>
<h2 id="section-test"><a class="header" href="#section-test">Section: test</a></h2>
<p><a href="src/generated-sections/test.html#assert-compare">assert-compare</a>, <a href="src/generated-sections/test.html#assert-compare">assert-compare</a>, <a href="src/generated-sections/test.html#assert-equal">assert-equal</a>, <a href="src/generated-sections/test.html#assert-equal">assert-equal</a>, <a href="src/generated-sections/test.html#assert-error">assert-error</a>, <a href="src/generated-sections/test.html#assert-error">assert-error</a>, <a href="src/generated-sections/test.html#assert-error-msg">assert-error-msg</a>, <a href="src/generated-sections/test.html#assert-error-msg">assert-error-msg</a>, <a href="src/generated-sections/test.html#assert-false">assert-false</a>, <a href="src/generated-sections/test.html#assert-false">assert-false</a>, <a href="src/generated-sections/test.html#assert-not-compare">assert-not-compare</a>, <a href="src/generated-sections/test.html#assert-not-compare">assert-not-compare</a>, <a href="src/generated-sections/test.html#assert-not-equal">assert-not-equal</a>, <a href="src/generated-sections/test.html#assert-not-equal">assert-not-equal</a>, <a href="src/generated-sections/test.html#assert-true">assert-true</a>, <a href="src/generated-sections/test.html#assert-true">assert-true</a></p>
<h2 id="section-type"><a class="header" href="#section-type">Section: type</a></h2>
<p><a href="src/generated-sections/type.html#-float">-&gt;float</a>, <a href="src/generated-sections/type.html#-int">-&gt;int</a>, <a href="src/generated-sections/type.html#boolean">boolean?</a>, <a href="src/generated-sections/type.html#callable">callable?</a>, <a href="src/generated-sections/type.html#char">char?</a>, <a href="src/generated-sections/type.html#err">err?</a>, <a href="src/generated-sections/type.html#false">false?</a>, <a href="src/generated-sections/type.html#falsey">falsey?</a>, <a href="src/generated-sections/type.html#float">float?</a>, <a href="src/generated-sections/type.html#hash-set">hash-set?</a>, <a href="src/generated-sections/type.html#int">int?</a>, <a href="src/generated-sections/type.html#io">io?</a>, <a href="src/generated-sections/type.html#list">list?</a>, <a href="src/generated-sections/type.html#nil">nil?</a>, <a href="src/generated-sections/type.html#ok">ok?</a>, <a href="src/generated-sections/type.html#pair">pair?</a>, <a href="src/generated-sections/type.html#seq">seq?</a>, <a href="src/generated-sections/type.html#string">string?</a>, <a href="src/generated-sections/type.html#symbol">symbol?</a>, <a href="src/generated-sections/type.html#true">true?</a>, <a href="src/generated-sections/type.html#vec">vec?</a></p>
<h2 id="section-undocumented"><a class="header" href="#section-undocumented">Section: undocumented</a></h2>
<p><a href="src/generated-sections/undocumented.html#bg-black"><em>bg-black</em></a>, <a href="src/generated-sections/undocumented.html#bg-blue"><em>bg-blue</em></a>, <a href="src/generated-sections/undocumented.html#bg-cyan"><em>bg-cyan</em></a>, <a href="src/generated-sections/undocumented.html#bg-default"><em>bg-default</em></a>, <a href="src/generated-sections/undocumented.html#bg-green"><em>bg-green</em></a>, <a href="src/generated-sections/undocumented.html#bg-magenta"><em>bg-magenta</em></a>, <a href="src/generated-sections/undocumented.html#bg-red"><em>bg-red</em></a>, <a href="src/generated-sections/undocumented.html#bg-white"><em>bg-white</em></a>, <a href="src/generated-sections/undocumented.html#bg-yellow"><em>bg-yellow</em></a>, <a href="src/generated-sections/undocumented.html#fg-black"><em>fg-black</em></a>, <a href="src/generated-sections/undocumented.html#fg-blue"><em>fg-blue</em></a>, <a href="src/generated-sections/undocumented.html#fg-cyan"><em>fg-cyan</em></a>, <a href="src/generated-sections/undocumented.html#fg-default"><em>fg-default</em></a>, <a href="src/generated-sections/undocumented.html#fg-green"><em>fg-green</em></a>, <a href="src/generated-sections/undocumented.html#fg-magenta"><em>fg-magenta</em></a>, <a href="src/generated-sections/undocumented.html#fg-red"><em>fg-red</em></a>, <a href="src/generated-sections/undocumented.html#fg-white"><em>fg-white</em></a>, <a href="src/generated-sections/undocumented.html#fg-yellow"><em>fg-yellow</em></a>, <a href="src/generated-sections/undocumented.html#int-bits"><em>int-bits</em></a>, <a href="src/generated-sections/undocumented.html#int-max"><em>int-max</em></a>, <a href="src/generated-sections/undocumented.html#int-min"><em>int-min</em></a>, <a href="src/generated-sections/undocumented.html#ns"><em>ns</em></a>, <a href="src/generated-sections/undocumented.html#linehandler">__line_handler</a>, <a href="src/generated-sections/undocumented.html#callcc">call/cc</a>, <a href="src/generated-sections/undocumented.html#dasm">dasm</a>, <a href="src/generated-sections/undocumented.html#defer">defer</a>, <a href="src/generated-sections/undocumented.html#doc-string">doc-string</a>, <a href="src/generated-sections/undocumented.html#dump-regs">dump-regs</a>, <a href="src/generated-sections/undocumented.html#epr">epr</a>, <a href="src/generated-sections/undocumented.html#eprn">eprn</a>, <a href="src/generated-sections/undocumented.html#fpr">fpr</a>, <a href="src/generated-sections/undocumented.html#fprn">fprn</a>, <a href="src/generated-sections/undocumented.html#get">get</a>, <a href="src/generated-sections/undocumented.html#get-rgb-seq">get-rgb-seq</a>, <a href="src/generated-sections/undocumented.html#identical">identical?</a>, <a href="src/generated-sections/undocumented.html#pr">pr</a>, <a href="src/generated-sections/undocumented.html#prn">prn</a>, <a href="src/generated-sections/undocumented.html#return">return</a>, <a href="src/generated-sections/undocumented.html#this-fn">this-fn</a>, <a href="src/generated-sections/undocumented.html#tok-default-color">tok-default-color</a>, <a href="src/generated-sections/undocumented.html#tok-invalid-color">tok-invalid-color</a>, <a href="src/generated-sections/undocumented.html#tok-slsh-fcn-color">tok-slsh-fcn-color</a>, <a href="src/generated-sections/undocumented.html#tok-slsh-form-color">tok-slsh-form-color</a>, <a href="src/generated-sections/undocumented.html#tok-string-color">tok-string-color</a>, <a href="src/generated-sections/undocumented.html#tok-sys-alias-color">tok-sys-alias-color</a>, <a href="src/generated-sections/undocumented.html#tok-sys-command-color">tok-sys-command-color</a>, <a href="src/generated-sections/undocumented.html#type">type</a>, <a href="src/generated-sections/undocumented.html#while">while</a></p>
<h2 id="section-vector"><a class="header" href="#section-vector">Section: vector</a></h2>
<p><a href="src/generated-sections/vector.html#make-vec">make-vec</a>, <a href="src/generated-sections/vector.html#vec">vec</a>, <a href="src/generated-sections/vector.html#vec-list">vec-&gt;list</a>, <a href="src/generated-sections/vector.html#vec-clear">vec-clear!</a>, <a href="src/generated-sections/vector.html#vec-insert">vec-insert!</a>, <a href="src/generated-sections/vector.html#vec-pop">vec-pop!</a>, <a href="src/generated-sections/vector.html#vec-push">vec-push!</a>, <a href="src/generated-sections/vector.html#vec-remove">vec-remove!</a>, <a href="src/generated-sections/vector.html#vec-slice">vec-slice</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="char"><a class="header" href="#char">char</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/char.html#char-lower">char-lower</a>, <a href="src/generated-sections/char.html#char-upper">char-upper</a>, <a href="src/generated-sections/char.html#char-whitespace">char-whitespace?</a></p>
<h3 id="char-lower"><a class="header" href="#char-lower">char-lower</a></h3>
<p><strong>Usage:</strong> (char-lower char) -&gt; char</p>
<p><strong>Namespace:</strong> root</p>
<p>Get lower case (utf) string for a character.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "a" (char-lower \A))
(test::assert-equal "a" (char-lower \a))
(test::assert-not-equal "a" (char-lower \Z))
(test::assert-equal "λ" (char-lower \Λ))
(test::assert-equal "λ" (char-lower \λ))
(test::assert-equal "ß" (char-lower \ß))
</code></pre>
<h3 id="char-upper"><a class="header" href="#char-upper">char-upper</a></h3>
<p><strong>Usage:</strong> (char-upper char) -&gt; char</p>
<p><strong>Namespace:</strong> root</p>
<p>Get upper case (utf) string for a character.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "A" (char-upper \A))
(test::assert-equal "A" (char-upper \a))
(test::assert-not-equal "A" (char-upper \Z))
(test::assert-equal "Λ" (char-upper \λ))
(test::assert-equal "Λ" (char-upper \Λ))
;; "the" exception and a reason for returning a string
(test::assert-equal "SS" (char-upper \ß))
</code></pre>
<h3 id="char-whitespace"><a class="header" href="#char-whitespace">char-whitespace?</a></h3>
<p><strong>Usage:</strong> (char-whitespace? char) -&gt; t/nil</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns true if a character is whitespace, false/nil otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (char-whitespace? \ ))
(test::assert-true (char-whitespace? \tab))
(test::assert-false (char-whitespace? \s))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="collection"><a class="header" href="#collection">collection</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/collection.html#clear">clear!</a>, <a href="src/generated-sections/collection.html#empty">empty?</a>, <a href="src/generated-sections/collection.html#flatten">flatten</a>, <a href="src/generated-sections/collection.html#in">in?</a>, <a href="src/generated-sections/collection.html#not-empty">not-empty?</a>, <a href="src/generated-sections/collection.html#reverse">reverse</a></p>
<h3 id="clear"><a class="header" href="#clear">clear!</a></h3>
<p><strong>Usage:</strong> (clear! container)</p>
<p><strong>Namespace:</strong> root</p>
<p>Clears a container (vector, hash-map, string).  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-clear-vec (vec 1 2 3))
(test::assert-false (empty? test-clear-vec))
(clear! test-clear-vec)
(test::assert-true (empty? test-clear-vec))
</code></pre>
<h3 id="empty"><a class="header" href="#empty">empty?</a></h3>
<p><strong>Usage:</strong> (empty? v)</p>
<p><strong>Namespace:</strong> root</p>
<p>Usage (empty? s)</p>
<p>No Examples</p>
<h3 id="flatten"><a class="header" href="#flatten">flatten</a></h3>
<p><strong>Usage:</strong> (flatten &amp; rest)</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a sequence composed of individual values or sequences of values and turns
it into one vector of values.</p>
<p>Example:</p>
<pre><code>(test::assert-equal [1 2 3 1 2 3] (flatten 1 2 3 (list 1 2 3)))
(test::assert-equal [1 2 3 1 2 3] (flatten 1 2 3 [1 2 3]))
(test::assert-equal [1 2 3 1 2] (flatten 1 2 3 (list 1 2)))
(test::assert-equal [1 2 3 1 2 3 1 2] (flatten 1 2 3 (list 1 2 3 (list 1 2))))
</code></pre>
<h3 id="in"><a class="header" href="#in">in?</a></h3>
<p><strong>Usage:</strong> (in? needle haystack)</p>
<p><strong>Namespace:</strong> root</p>
<p>In provided sequence, haystack, find a specific value, needle.</p>
<p>Example:</p>
<pre><code>(test::assert-true (in? [1 2 3 4 5] 3))
(test::assert-false (in? [1 2 3 4 5] 9))
(test::assert-true (in? (list 1 2 3 4 5) 3))
(test::assert-true (in? '(1 2 3 4 5) 5))
</code></pre>
<h3 id="not-empty"><a class="header" href="#not-empty">not-empty?</a></h3>
<p><strong>Usage:</strong> (not-empty? v)</p>
<p><strong>Namespace:</strong> root</p>
<p>Usage (not-empty? s)</p>
<p>No Examples</p>
<h3 id="reverse"><a class="header" href="#reverse">reverse</a></h3>
<p><strong>Usage:</strong> (reverse items)</p>
<p><strong>Namespace:</strong> root</p>
<p>Produce a vector that is the reverse of items.</p>
<p>Example:</p>
<pre><code>(let (tmap [1 2 3 0])
(test::assert-false (empty? tmap))
(set! tmap (reverse tmap))
(test::assert-equal 2 (get tmap 2))
(test::assert-equal 1 (get tmap 3))
(test::assert-equal 0 (get tmap 0))
(test::assert-error (reverse "string")))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conditional"><a class="header" href="#conditional">conditional</a></h2>
<p><strong>For additional notes on conditionals involving equality see <a href="src/generated-sections/../equality.html">documentation site's equality section</a></strong></p>
<p>List of symbols:</p>
<p><a href="src/generated-sections/conditional.html#">&lt;</a>, <a href="src/generated-sections/conditional.html#">&lt;=</a>, <a href="src/generated-sections/conditional.html#">==</a>, <a href="src/generated-sections/conditional.html#">&gt;</a>, <a href="src/generated-sections/conditional.html#">&gt;=</a>, <a href="src/generated-sections/conditional.html#and">and</a>, <a href="src/generated-sections/conditional.html#cond">cond</a>, <a href="src/generated-sections/conditional.html#if">if</a>, <a href="src/generated-sections/conditional.html#match">match</a>, <a href="src/generated-sections/conditional.html#not">not</a>, <a href="src/generated-sections/conditional.html#or">or</a>, <a href="src/generated-sections/conditional.html#when">when</a></p>
<h3 id=""><a class="header" href="#">&lt;</a></h3>
<p><strong>Usage:</strong> (&lt; val0 ... valN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Less than.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-true (&lt; 1 2))
(test::assert-true (&lt; 1 2 3 4))
(test::assert-false (&lt; 2 2))
(test::assert-false (&lt; 2 2 2))
(test::assert-false (&lt; 2 2 3))
(test::assert-true (&lt; 1.0 2.0))
(test::assert-false (&lt; 2.0 2.0))
(test::assert-false (&lt; 2.0 2.0 2.0))
(test::assert-false (&lt; 2.0 2.0 3.0))
(test::assert-false (&lt; 2.1 2.0 3.0))
(test::assert-false (&lt; 2 1))
(test::assert-false (&lt; 3 2 3))
(test::assert-true (&lt; 1.0 1.1 ))
(test::assert-true (&lt; 1.0 1.01 ))
(test::assert-true (&lt; 1.0 1.001 ))
(test::assert-true (&lt; 1.0 1.0001 ))
(test::assert-true (&lt; 1.0 1.00001 ))
(test::assert-true (&lt; 1.0 1.000001 ))
(test::assert-true (&lt; 1.0 1.0000001 ))
(test::assert-false (&lt; 1.0 1.00000000000001 ))
</code></pre>
<h3 id="-1"><a class="header" href="#-1">&lt;=</a></h3>
<p><strong>Usage:</strong> (&lt;= val0 ... valN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Less than or equal.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-true (&lt;= 1 2))
(test::assert-true (&lt;= 2 2))
(test::assert-true (&lt;= 2 2 2))
(test::assert-true (&lt;= 2 2 3))
(test::assert-true (&lt;= 1.0 2.0))
(test::assert-true (&lt;= 2.0 2.0))
(test::assert-true (&lt;= 2.0 2.0 2.0))
(test::assert-true (&lt;= 2.0 2.0 3.0))
(test::assert-false (&lt;= 2.1 2.0 3.0))
(test::assert-false (&lt;= 2 1))
(test::assert-false (&lt;= 3 2 3))
(test::assert-true (&lt;= 1.00000000000001 1.0000000000001 ))
(test::assert-true (&lt;= 10.0000000000001 10.000000000001))
(test::assert-true (&lt;= 100.000000000001 100.00000000001))
(test::assert-true (&lt;= 1000.000000000001 1000.00000000001))
</code></pre>
<h3 id="-2"><a class="header" href="#-2">==</a></h3>
<p><strong>Usage:</strong> (== val0 ... valN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Equals.  Works for numeric types (int, float).</p>
<p>Example:</p>
<pre><code>(test::assert-false (== 1 2))
(test::assert-true (== 2 2))
(test::assert-true (== 2 2 2))
(test::assert-false (== 3 2 2))
(test::assert-false (== 3.0 2.0))
(test::assert-true (== 2.0 2.0))
(test::assert-true (== 2.0 2.0 2.0))
(test::assert-false (== 3.0 2.0 2.0))
(test::assert-false (== 2.1 2.0 3.0))
(test::assert-false (== 2 1))
(test::assert-false (== 3 2 1))
(test::assert-false (== 1.1 1.0))
(test::assert-true (== 1.1 1.1))
(test::assert-false (== 3 2 3))
</code></pre>
<h3 id="-3"><a class="header" href="#-3">&gt;</a></h3>
<p><strong>Usage:</strong> (&gt; val0 ... valN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Greater than.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-false (&gt; 1 2))
(test::assert-false (&gt; 2 2))
(test::assert-false (&gt; 2 2 2))
(test::assert-false (&gt; 3 2 2))
(test::assert-true (&gt; 3.0 2.0))
(test::assert-false (&gt; 2.0 2.0))
(test::assert-false (&gt; 2.0 2.0 2.0))
(test::assert-false (&gt; 3.0 2.0 2.0))
(test::assert-false (&gt; 2.1 2.0 3.0))
(test::assert-true (&gt; 2 1))
(test::assert-true (&gt; 3 2 1))
(test::assert-true (&gt; 1.1 1.0))
(test::assert-false (&gt; 3 2 3))
(test::assert-true (&gt; 1.001 1.0))
(test::assert-true (&gt; 1.0000001 1.0))
(test::assert-false (&gt; 1.00000000000001 1.0))
</code></pre>
<h3 id="-4"><a class="header" href="#-4">&gt;=</a></h3>
<p><strong>Usage:</strong> (&gt;= val0 ... valN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Greater than or equal.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-false (&gt;= 1 2))
(test::assert-true (&gt;= 2 2))
(test::assert-true (&gt;= 2 2 2))
(test::assert-true (&gt;= 3 2 2))
(test::assert-true (&gt;= 3.0 2.0))
(test::assert-true (&gt;= 2.0 2.0))
(test::assert-true (&gt;= 2.0 2.0 2.0))
(test::assert-true (&gt;= 3.0 2.0 2.0))
(test::assert-false (&gt;= 2.1 2.0 3.0))
(test::assert-true (&gt;= 2 1))
(test::assert-true (&gt;= 1.1 1.0))
(test::assert-false (&gt;= 3 2 3))
(test::assert-true (&gt;= 1.0000000000001 1.00000000000001))
(test::assert-true (&gt;= 10.000000000001 10.0000000000001))
(test::assert-true (&gt;= 100.00000000001 100.000000000001))
(test::assert-true (&gt;= 1000.00000000001 1000.000000000001))
</code></pre>
<h3 id="and"><a class="header" href="#and">and</a></h3>
<p><strong>Usage:</strong> (and exp0 ... expN) -&gt; [false(#f) or expN result]</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluates each form until one produces nil or false(#f), produces false(#f) if
any form is nil/#f or the result of the last expression.</p>
<p>The and form will stop evaluating when the first expression produces nil/#f.</p>
<p>Example:</p>
<pre><code>(test::assert-equal #f (and nil (err "and- can not happen")))
(test::assert-equal #f (and #f (err "and- can not happen")))
(test::assert-equal "and- done" (and #t "and- done"))
(test::assert-equal "and- done" (and #t #t "and- done"))
(test::assert-equal 6 (and #t #t (+ 1 2 3)))
(test::assert-equal 6 (and (/ 10 5) (* 5 2) (+ 1 2 3)))
</code></pre>
<h3 id="cond"><a class="header" href="#cond">cond</a></h3>
<p><strong>Usage:</strong> (cond ((test form*)*) -&gt; result</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate each test in order.  If it is true then evaluate the form(s) in an
implicit do and return the result.  Stop evaluating at the first true test.
Return nil if no conditions are true.</p>
<p>Example:</p>
<pre><code>(def b 0)
(defn select-option (a)
    (cond ((= a 1) "opt-one")
          ((= a 2) (set! b 5) "opt-two")
          ((= a 3) (str "opt" "-three"))))
(defn select-option-def (a)
    (cond ((= a 1) "opt-one")
          ((= a 2) "opt-two")
          ((= a 3) (str "opt" "-three"))
          (#t "default")))
(test::assert-equal "opt-one" (select-option 1))
(test::assert-equal b 0)
(test::assert-equal "opt-two" (select-option 2))
(test::assert-equal b 5)
(test::assert-equal "opt-three" (select-option 3))
(test::assert-equal nil (select-option 4))
(test::assert-equal "opt-one" (select-option-def 1))
(test::assert-equal "opt-two" (select-option-def 2))
(test::assert-equal "opt-three" (select-option-def 3))
(test::assert-equal "default" (select-option-def 4))
</code></pre>
<h3 id="if"><a class="header" href="#if">if</a></h3>
<p><strong>Usage:</strong> (if p1 a1 p2 a2 ... pn an?) -&gt; [evaled form result]</p>
<p><strong>Namespace:</strong> root</p>
<p>If conditional.  Will evaluate p1 and if true (i.e. not nil or false) then
return the evaluation of a1, if falsey(i.e. nil or false) evaluate p2 and so on.
On an odd number of arguments (an is missing) then evaluate and return pn.
Return false(#f) if no predicate is true.  This degenerates into the traditional
(if predicate then-form else-form).
NOTE: Both nil and false(#f) are 'falsey' for the purposes of if.</p>
<p>Example:</p>
<pre><code>(def test-if-one
    (if #t "ONE TRUE" "ONE FALSE"))
(def test-if-two
    (if nil "TWO TRUE" "TWO FALSE"))
(def test-if-three
    (if #f "THREE TRUE" "THREE FALSE"))
(test::assert-equal "ONE TRUE" test-if-one)
(test::assert-equal "TWO FALSE" test-if-two)
(test::assert-equal "THREE FALSE" test-if-three)

(def test-if-one2
    (if #t "ONE2 TRUE"))
(def test-if-two2
    (if nil "TWO2 TRUE"))
(def test-if-three2
    (if #f "THREE2 TRUE"))
(test::assert-equal "ONE2 TRUE" test-if-one2)
(test::assert-equal #f test-if-two2)
(test::assert-equal #f test-if-three2)

(def test-if-one2
    (if nil "ONE FALSE" #t "ONE TRUE" #t "ONE TRUE2"))
(def test-if-two2
    (if nil "TWO TRUE" #f "TWO FALSE" #t "TWO TRUE2"))
(def test-if-three2
    (if #f "THREE TRUE" nil "THREE FALSE" "THREE DEFAULT"))
(test::assert-equal "ONE TRUE" test-if-one2)
(test::assert-equal "TWO TRUE2" test-if-two2)
(test::assert-equal "THREE DEFAULT" test-if-three2)
(test::assert-equal nil (if nil))
(test::assert-equal #f (if nil #t nil #t nil #t))
</code></pre>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<p><strong>Usage:</strong> (match condition (value form*)*) -&gt; result</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate condition and look for matching value in each branch of type
(value form*). Form(s) will be wrapped in an implicit do. Use nil to take
action if no match (encouraged!).</p>
<p>Example:</p>
<pre><code>(defn select-option (a)
    (match a (1 "opt-one")
             (2 (set! b 5) "opt-two")
             (3 (str "opt" "-three"))))
(defn select-option-def (a)
    (match a (1 "opt-one")
             (2 "opt-two")
             (3 (str "opt" "-three"))
             (nil "default")))
(def b 0)
(test::assert-equal b 0)
(test::assert-equal "opt-one" (select-option 1))
(test::assert-equal "opt-two" (select-option 2))
(test::assert-equal b 5)
(test::assert-equal "opt-three" (select-option 3))
(test::assert-equal #f (select-option 4))
(test::assert-equal "opt-one" (select-option-def 1))
(test::assert-equal "opt-two" (select-option-def 2))
(test::assert-equal "opt-three" (select-option-def 3))
(test::assert-equal "default" (select-option-def 4))
</code></pre>
<h3 id="not"><a class="header" href="#not">not</a></h3>
<p><strong>Usage:</strong> (not expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return true(#t) if expression is nil, false(#f) otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (not nil))
(test::assert-false (not 10))
(test::assert-false (not #t))
(test::assert-false (not (+ 1 2 3)))
</code></pre>
<h3 id="or"><a class="header" href="#or">or</a></h3>
<p><strong>Usage:</strong> (or exp0 ... expN) -&gt; [false(#f) or first non nil expression]</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluates each form until one produces a non-nil/non-false result, produces #f
if all expressions are 'falsey'.</p>
<p>The or form will stop evaluating when the first expression produces non-nil/false.</p>
<p>Example:</p>
<pre><code>(test::assert-true (or nil nil #t (err "and- can not happen")))
(test::assert-true (or #f nil #t (err "and- can not happen")))
(test::assert-true (or #f #f #t (err "and- can not happen")))
(test::assert-equal #f (or nil nil nil))
(test::assert-equal #f (or #f nil nil))
(test::assert-equal #f (or #f nil #f))
(test::assert-equal #f (or #f #f #f))
(test::assert-equal "or- done" (or nil "or- done"))
(test::assert-equal "or- done" (or nil nil "or- done"))
(test::assert-equal 6 (or nil nil (+ 1 2 3)))
(test::assert-equal 2 (or (/ 10 5) (* 5 2) (+ 1 2 3)))
</code></pre>
<h3 id="when"><a class="header" href="#when">when</a></h3>
<p><strong>Usage:</strong> (when provided-condition if-true)</p>
<p><strong>Namespace:</strong> root</p>
<p>when is a convenience function used to check a form, provided-condition,
and run some form, if-true, if provided-condition evaluates to true.</p>
<p>Example:</p>
<pre><code>(test::assert-true (when #t #t))
(test::assert-false (when #t nil))
(test::assert-false (when nil nil))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conversion"><a class="header" href="#conversion">conversion</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/conversion.html#-key">-&gt;key</a>, <a href="src/generated-sections/conversion.html#-sym">-&gt;sym</a>, <a href="src/generated-sections/conversion.html#def">def?</a>, <a href="src/generated-sections/conversion.html#ref">ref</a></p>
<h3 id="-key"><a class="header" href="#-key">-&gt;key</a></h3>
<p><strong>Usage:</strong> (-&gt;key exp) -&gt; keyword</p>
<p><strong>Namespace:</strong> root</p>
<p>Converts exp to a keyword.</p>
<p>No Examples</p>
<h3 id="-sym"><a class="header" href="#-sym">-&gt;sym</a></h3>
<p><strong>Usage:</strong> (-&gt;sym exp) -&gt; symbol</p>
<p><strong>Namespace:</strong> root</p>
<p>Converts exp to a symbol.</p>
<p>No Examples</p>
<h3 id="def"><a class="header" href="#def">def?</a></h3>
<p><strong>Usage:</strong> (def? symbol) -&gt; #t/#f</p>
<p><strong>Namespace:</strong> root</p>
<p>If symbol is defined then return true else false.</p>
<p>No Examples</p>
<h3 id="ref"><a class="header" href="#ref">ref</a></h3>
<p><strong>Usage:</strong> (ref symbol) -&gt; Value</p>
<p><strong>Namespace:</strong> root</p>
<p>If symbol is defined then return the thing it references.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core"><a class="header" href="#core">core</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/core.html#euid"><em>euid</em></a>, <a href="src/generated-sections/core.html#last-command"><em>last-command</em></a>, <a href="src/generated-sections/core.html#last-status"><em>last-status</em></a>, <a href="src/generated-sections/core.html#uid"><em>uid</em></a>, <a href="src/generated-sections/core.html#">=</a>, <a href="src/generated-sections/core.html#apply">apply</a>, <a href="src/generated-sections/core.html#back-quote">back-quote</a>, <a href="src/generated-sections/core.html#block">block</a>, <a href="src/generated-sections/core.html#comp-time">comp-time</a>, <a href="src/generated-sections/core.html#dec">dec!</a>, <a href="src/generated-sections/core.html#def">def</a>, <a href="src/generated-sections/core.html#defmacro">defmacro</a>, <a href="src/generated-sections/core.html#defn">defn</a>, <a href="src/generated-sections/core.html#do">do</a>, <a href="src/generated-sections/core.html#doc">doc</a>, <a href="src/generated-sections/core.html#doc-raw">doc-raw</a>, <a href="src/generated-sections/core.html#dotimes">dotimes</a>, <a href="src/generated-sections/core.html#dotimes-i">dotimes-i</a>, <a href="src/generated-sections/core.html#dump-globals">dump-globals</a>, <a href="src/generated-sections/core.html#dyn">dyn</a>, <a href="src/generated-sections/core.html#env">env</a>, <a href="src/generated-sections/core.html#err">err</a>, <a href="src/generated-sections/core.html#eval">eval</a>, <a href="src/generated-sections/core.html#exit">exit</a>, <a href="src/generated-sections/core.html#expand-macro">expand-macro</a>, <a href="src/generated-sections/core.html#fn">fn</a>, <a href="src/generated-sections/core.html#gensym">gensym</a>, <a href="src/generated-sections/core.html#get-error">get-error</a>, <a href="src/generated-sections/core.html#get-globals">get-globals</a>, <a href="src/generated-sections/core.html#get-prop">get-prop</a>, <a href="src/generated-sections/core.html#identity">identity</a>, <a href="src/generated-sections/core.html#inc">inc!</a>, <a href="src/generated-sections/core.html#is-noop">is-noop</a>, <a href="src/generated-sections/core.html#len">len</a>, <a href="src/generated-sections/core.html#let">let</a>, <a href="src/generated-sections/core.html#let-while">let-while</a>, <a href="src/generated-sections/core.html#load">load</a>, <a href="src/generated-sections/core.html#load-rc">load-rc</a>, <a href="src/generated-sections/core.html#loop">loop</a>, <a href="src/generated-sections/core.html#macro">macro</a>, <a href="src/generated-sections/core.html#mk-err">mk-err</a>, <a href="src/generated-sections/core.html#noop">noop</a>, <a href="src/generated-sections/core.html#noop-fn">noop-fn</a>, <a href="src/generated-sections/core.html#not">not=</a>, <a href="src/generated-sections/core.html#not">not==</a>, <a href="src/generated-sections/core.html#nsubstitute">nsubstitute!</a>, <a href="src/generated-sections/core.html#occurs">occurs</a>, <a href="src/generated-sections/core.html#on-raised-error">on-raised-error</a>, <a href="src/generated-sections/core.html#platform">platform</a>, <a href="src/generated-sections/core.html#quote">quote</a>, <a href="src/generated-sections/core.html#recur">recur</a>, <a href="src/generated-sections/core.html#set">set!</a>, <a href="src/generated-sections/core.html#set-env">set-env</a>, <a href="src/generated-sections/core.html#set-prop">set-prop</a>, <a href="src/generated-sections/core.html#sizeof-heap-object">sizeof-heap-object</a>, <a href="src/generated-sections/core.html#sizeof-value">sizeof-value</a>, <a href="src/generated-sections/core.html#substitute">substitute</a>, <a href="src/generated-sections/core.html#to-list">to-list</a>, <a href="src/generated-sections/core.html#to-vec">to-vec</a>, <a href="src/generated-sections/core.html#un-noop-fn">un-noop-fn</a>, <a href="src/generated-sections/core.html#unset-env">unset-env</a>, <a href="src/generated-sections/core.html#usage">usage</a></p>
<h3 id="euid"><a class="header" href="#euid"><em>euid</em></a></h3>
<p><strong>Usage:</strong> (prn <em>euid</em>)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return effective system uid as a String.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="last-command"><a class="header" href="#last-command"><em>last-command</em></a></h3>
<p><strong>Usage:</strong> (prn <em>last-command</em>)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return last run command as a String.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="last-status"><a class="header" href="#last-status"><em>last-status</em></a></h3>
<p><strong>Usage:</strong> (prn <em>last-status</em>)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return last exit code as an Int.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="uid"><a class="header" href="#uid"><em>uid</em></a></h3>
<p><strong>Usage:</strong> (prn <em>uid</em>)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return system uid as a String.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="-5"><a class="header" href="#-5">=</a></h3>
<p><strong>Usage:</strong> (= val0 val1)</p>
<p><strong>Namespace:</strong> root</p>
<p>Test equality, works for most value types where it makes sense, not just primitives.</p>
<p>Example:</p>
<pre><code>(test::assert-false (= "aab" "aaa"))
(test::assert-true (= "aaa" "aaa"))
(test::assert-true (= "aaa" "aaa" "aaa"))
(test::assert-false (= "aaa" "aaaa" "aaa"))
(test::assert-false (= "ccc" "aab" "aaa"))
(test::assert-false (= "aaa" "aab"))
(test::assert-true (= (get-error (/ 1 0)) (get-error (/ 1 0))))
</code></pre>
<h3 id="apply"><a class="header" href="#apply">apply</a></h3>
<p><strong>Usage:</strong> (apply function arg* list)</p>
<p><strong>Namespace:</strong> root</p>
<p>Call the provided function with the supplied arguments, if last is a list or vector then it will
be "spread" as arguments.  For instance (apply pr 1 2 3 [4 5 6]) is equivalent to (pr 1 2 3 4 5 6).</p>
<p>Example:</p>
<pre><code>(def test-apply-one (apply str "O" "NE"))
(test::assert-equal "ONE" test-apply-one)
(test::assert-equal 10 (apply + 1 2 7))
(test::assert-equal 10 (apply + 1 [2 7]))
(test::assert-equal 10 (apply + 1 '(2 7)))
(test::assert-equal 10 (apply + [1 2 7]))
(test::assert-equal 10 (apply + '(1 2 7)))
(def test-apply-fn1 (fn (&amp; args) (apply + args)))
(test::assert-equal 10 (apply test-apply-fn1 1 2 7))
(test::assert-equal 10 (apply test-apply-fn1 1 [2 7]))
(test::assert-equal 10 (apply test-apply-fn1 1 '(2 7)))
(test::assert-equal 10 (apply test-apply-fn1 [1 2 7]))
(test::assert-equal 10 (apply test-apply-fn1 '(1 2 7)))
(def test-apply-fn2 (fn (x y z) (+ x y z)))
(test::assert-equal 10 (apply test-apply-fn2 1 2 7))
(test::assert-equal 10 (apply test-apply-fn2 1 [2 7]))
(test::assert-equal 10 (apply test-apply-fn2 1 '(2 7)))
(test::assert-equal 10 (apply test-apply-fn2 [1 2 7]))
(test::assert-equal 10 (apply test-apply-fn2 '(1 2 7)))
</code></pre>
<h3 id="back-quote"><a class="header" href="#back-quote">back-quote</a></h3>
<p><strong>Usage:</strong> `expression -&gt; expression</p>
<p><strong>Namespace:</strong> root</p>
<p>Return expression without evaluation.
Always use the ` reader macro or expansion will not work
(i.e. (back-quote expression) will not do , expansion).</p>
<p>Backquote (unlike quote) allows for symbol/form evaluation using , or ,@.</p>
<p>Example:</p>
<pre><code>(test::assert-equal (list 1 2 3) `(1 2 3))
(test::assert-equal `(1 2 3) '(1 2 3))
(def test-bquote-one 1)
(def test-bquote-list '(1 2 3))
(test::assert-equal (list 1 2 3) `(~test-bquote-one 2 3))
(test::assert-equal (list 1 2 3) `(~@test-bquote-list))
</code></pre>
<h3 id="block"><a class="header" href="#block">block</a></h3>
<p><strong>Usage:</strong> (get-error exp0 ... expN) -&gt; pair</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate each form (like do) but on error return (:error msg backtrace) instead of aborting.
On success return (:ok . expN-result).</p>
<p>If there is no error will return the value of the last expression as the cdr of
the pair.  Always returns a pair with the first value either being :ok or :error.</p>
<p>Example:</p>
<pre><code>(let (get-error-t1 (get-error (err (mk-err :string (str "Some Error")))))
    (test::assert-equal :error (car get-error-t1))
    (test::assert-equal "error [string]: \"Some Error\"" (str (cdr get-error-t1))))
(test::assert-equal "Some String" (get-error "Some String"))
(test::assert-equal "Some Other String" (get-error (let (test-get-error "Some ") (str test-get-error "Other String"))))
</code></pre>
<h3 id="comp-time"><a class="header" href="#comp-time">comp-time</a></h3>
<p><strong>Usage:</strong> (comp-time sexp+)</p>
<p><strong>Namespace:</strong> root</p>
<p>Compile and execute sexp+ at compile time.  The result of the final sexp will then be compiled into
the current module being compiled (produce nil to avoid this).</p>
<p>Example:</p>
<pre><code>(with-ns test-out
    (comp-time '(def ttf (fn () '(1 2 3))))
    (comp-time (def ttf2 (fn () '(1 2 3))) nil)
    (test::assert-equal '(1 2 3) (ttf))
    (test::assert-equal '(1 2 3) (test-out::ttf))
    (test::assert-equal '(1 2 3) (ttf2))
    (test::assert-equal '(1 2 3) (test-out::ttf2)))
</code></pre>
<h3 id="dec"><a class="header" href="#dec">dec!</a></h3>
<p><strong>Usage:</strong> (dec! symbol [number]) -&gt; new value</p>
<p><strong>Namespace:</strong> root</p>
<p>Decrement the value in symbol by one or the optional number</p>
<p>Example:</p>
<pre><code>(def *dec-test* 5)
(test::assert-equal 4 (dec! *dec-test*))
(test::assert-equal 4 *dec-test*)
(test::assert-equal 1 (dec! *dec-test* 3))
(test::assert-equal 1 *dec-test*)
(let (dec-test 5)
  (test::assert-equal 4 (dec! dec-test))
  (test::assert-equal 4 dec-test)
  (test::assert-equal 1 (dec! dec-test 3))
  (test::assert-equal 1 dec-test))
</code></pre>
<h3 id="def-1"><a class="header" href="#def-1">def</a></h3>
<p><strong>Usage:</strong> (def symbol doc_string? expression) -&gt; expression</p>
<p><strong>Namespace:</strong> root</p>
<p>Adds an expression to the current namespace.  Return the expression that was defined.
Symbol is not evaluated.  Can take an option doc string (docstrings can only be
set on namespaced (global) symbols).</p>
<p>Example:</p>
<pre><code>(def test-do-one nil)
(def test-do-two nil)
(def test-do-three (do (set! test-do-one "One")(set! test-do-two "Two")"Three"))
(test::assert-equal "One" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
(let (test-do-one nil)
    ; Add this to the let's scope (shadow the outer test-do-two).
    (test::assert-equal "Default" (def test-do-four "Default"))
    ; set the currently scoped value.
    (set! test-do-one "1111")
    (set! test-do-two "2222")
    (test::assert-equal "1111" test-do-one)
    (test::assert-equal "2222" test-do-two)
    (test::assert-equal "Default" test-do-four))
; Original outer scope not changed.
(test::assert-equal "One" test-do-one)
(test::assert-equal "Default" test-do-four)
</code></pre>
<h3 id="defmacro"><a class="header" href="#defmacro">defmacro</a></h3>
<p><strong>Usage:</strong> (defmacro name argument_list body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Create a macro and bind it to a symbol in the current scope.</p>
<p>Example:</p>
<pre><code>(defmacro test-mac (x) `(inc! ~x))
(def test-mac-x 2)
(test-mac test-mac-x)
(test::assert-equal 3 test-mac-x)
(defmacro test-mac (x) `(set! ~x 15))
(test-mac test-mac-x)
(test::assert-equal 15 test-mac-x)
</code></pre>
<h3 id="defn"><a class="header" href="#defn">defn</a></h3>
<p><strong>Usage:</strong> (defn name args body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Define a named function in the current namespace.</p>
<p>Example:</p>
<pre><code>(defn defn-test (x y) (+ x y))
(test::assert-equal 5 (defn-test 2 3))
(defn defn-test (x y) (set! x (* x 2)) (+ x y))
(test::assert-equal 7 (defn-test 2 3))
(defn defn-test (x y) nil)
(test::assert-false (defn-test 2 3))
(defn defn-test (x y) #t)
(test::assert-true (defn-test 2 3))
</code></pre>
<h3 id="do"><a class="header" href="#do">do</a></h3>
<p><strong>Usage:</strong> (do exp0 ... expN) -&gt; expN</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate each form and return the last.</p>
<p>Example:</p>
<pre><code>(def test-do-one nil)
(def test-do-two nil)
(def test-do-three (do (set! test-do-one "One") (set! test-do-two "Two") "Three"))
(test::assert-equal "One" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
</code></pre>
<h3 id="doc"><a class="header" href="#doc">doc</a></h3>
<p><strong>Usage:</strong> (doc sym)</p>
<p><strong>Namespace:</strong> root</p>
<p>Print the documentation for provided symbol.</p>
<p>No Examples</p>
<h3 id="doc-raw"><a class="header" href="#doc-raw">doc-raw</a></h3>
<p><strong>Usage:</strong> (doc-raw sym [SCRATCH] [SCRATCH] docs has-usage)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return the documentation for provided symbol as a string.</p>
<p>No Examples</p>
<h3 id="dotimes"><a class="header" href="#dotimes">dotimes</a></h3>
<p><strong>Usage:</strong> (dotimes times body [SCRATCH] [SCRATCH] i-name)</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate body a number of times equal to times' numerical value.</p>
<p>Example:</p>
<pre><code>(def i 0)
(dotimes 11 (set! i (+ 1 i)))
(test::assert-equal 11 i)
</code></pre>
<h3 id="dotimes-i"><a class="header" href="#dotimes-i">dotimes-i</a></h3>
<p><strong>Usage:</strong> (dotimes-i idx-bind times body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate body a number of times equal to times' numerical value. Includes an
incrementing reference binding, idx-bind, accessible in body.</p>
<p>Example:</p>
<pre><code>(def i 0)
(def i-tot 0)
(dotimes-i idx 11 (do (set! i-tot (+ idx i-tot))(set! i (+ 1 i))))
(test::assert-equal 11 i)
(test::assert-equal 55 i-tot)
</code></pre>
<h3 id="dump-globals"><a class="header" href="#dump-globals">dump-globals</a></h3>
<p><strong>Usage:</strong> (dump-globals)</p>
<p><strong>Namespace:</strong> root</p>
<p>Prints the global variables to stdout.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="dyn"><a class="header" href="#dyn">dyn</a></h3>
<p><strong>Usage:</strong> (dyn key value expression) -&gt; result_of_expression</p>
<p><strong>Namespace:</strong> root</p>
<p>Creates a dynamic binding for key, assigns value to it and evals expression under it.
Note that if key must be a symbol and is not evaluated.</p>
<p>The binding is gone once the dyn form ends. This is basically a set! on the
binding in an unwind protect to reset it when done.  When used on a global will
set the first binding found and reset it when done.
Calls to dyn can be nested and previous dynamic values will
be restored as interior dyn's exit.</p>
<p>Example:</p>
<pre><code>(def *dyn-test* 1)
(defn test-dyn-fn (val) (str *dyn-test* val))
(def out (dyn *dyn-test* 11 (test-dyn-fn 101)))
(test::assert-equal "11101" (str out))
;; when file handling works
;;(defn test-dyn-fn () (prn "Print dyn out"))
;;(dyn *stdout* (open "/tmp/sl-sh.dyn.test" :create :truncate) (test-dyn-fn))
;;(test::assert-equal "Print dyn out" (read-line (open "/tmp/sl-sh.dyn.test" :read)))
</code></pre>
<h3 id="env"><a class="header" href="#env">env</a></h3>
<p><strong>Usage:</strong> (env "NAME_OF_ENVIRONMENT_VARIABLE")</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a string (tries to treat all values like strings), and checks the environment to see if
that string is a valid environment variable and returns the value as a string, otherwise returns
Nil.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="err"><a class="header" href="#err">err</a></h3>
<p><strong>Usage:</strong> (err :keyword value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Raises an error with keyword and value.  By default this will break into the
debugger like a runtime error (use get-error to avoid this).</p>
<p>Example:</p>
<pre><code>(let (error (get-error (err :test "Test error")))
    (test::assert-equal :test (car error))
    (test::assert-equal "Test error" (cdr error))
    (test::assert-true (err? error)))
</code></pre>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p><strong>Usage:</strong> (eval expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate the provided expression.  If expression is a list it will be compiled and executed and the result returned
other values will just be returned (i.e. (eval 1) = 1, (eval "test") = "test", (eval [1 2 3]) = [1 2 3], etc).</p>
<p>Note eval is a function not a special form, the provided expression will be evaluated as part of a call.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "ONE" (eval "ONE"))
(test::assert-equal 10 (eval 10))
(test::assert-equal [1 2 3] (eval [1 2 3]))
(test::assert-equal 10 (eval '(+ 1 2 7)))
(test::assert-equal 10 (eval '(apply + 1 2 7)))
(test::assert-equal 10 (eval '(apply + 1 '(2 7))))
(test::assert-equal 10 (eval '(apply + '(1 2 7))))
(test::assert-equal 10 (eval '(apply + 1 [2 7])))
(test::assert-equal 10 (eval '(apply + [1 2 7])))
</code></pre>
<h3 id="exit"><a class="header" href="#exit">exit</a></h3>
<p><strong>Usage:</strong> (exit int)</p>
<p><strong>Namespace:</strong> root</p>
<p>Exit shell with provided exit code.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="expand-macro"><a class="header" href="#expand-macro">expand-macro</a></h3>
<p><strong>Usage:</strong> (expand-macro 'code)</p>
<p><strong>Namespace:</strong> root</p>
<p>Output code, any macro invocation will be replaced with the code it would generate.
This is particularly useful for introspection when debugging macros.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="fn"><a class="header" href="#fn">fn</a></h3>
<p><strong>Usage:</strong> (fn (param*) expr*) -&gt; exprN</p>
<p><strong>Namespace:</strong> root</p>
<p>Create a function (lambda).</p>
<p>Example:</p>
<pre><code>(def test-fn1 nil)
(def test-fn2 nil)
(def test-fn3 nil)
(def test-fn-empty ((fn () nil)))
(test::assert-false test-fn-empty)
((fn () (set! test-fn1 1)))
(test::assert-equal 1 test-fn1)
((fn () (set! test-fn1 10)(set! test-fn2 2)))
(test::assert-equal 10 test-fn1)
(test::assert-equal 2 test-fn2)
((fn () (set! test-fn1 11)(set! test-fn2 20)(set! test-fn3 3)))
(test::assert-equal 11 test-fn1)
(test::assert-equal 20 test-fn2)
(test::assert-equal 3 test-fn3)
(test::assert-equal 63 ((fn (x y z) (set! test-fn1 x)(set! test-fn2 y)(set! test-fn3 z)(+ x y z)) 12 21 30))
(test::assert-equal 12 test-fn1)
(test::assert-equal 21 test-fn2)
(test::assert-equal 30 test-fn3)
</code></pre>
<h3 id="gensym"><a class="header" href="#gensym">gensym</a></h3>
<p><strong>Usage:</strong> (gensym)</p>
<p><strong>Namespace:</strong> root</p>
<p>Used to make macros hygenic by creating a random symbol name to be used
in code output by a macro to avoid conflicting variable names.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="get-error"><a class="header" href="#get-error">get-error</a></h3>
<p><strong>Usage:</strong> (get-error exp0 ... expN) -&gt; pair</p>
<p><strong>Namespace:</strong> root</p>
<p>Evaluate each form (like do) but on error return (:error msg backtrace) instead of aborting.
On success return (:ok . expN-result).</p>
<p>If there is no error will return the value of the last expression as the cdr of
the pair.  Always returns a pair with the first value either being :ok or :error.</p>
<p>Example:</p>
<pre><code>(let (get-error-t1 (get-error (err (mk-err :string (str "Some Error")))))
    (test::assert-equal :error (car get-error-t1))
    (test::assert-equal "error [string]: \"Some Error\"" (str (cdr get-error-t1))))
(test::assert-equal "Some String" (get-error "Some String"))
(test::assert-equal "Some Other String" (get-error (let (test-get-error "Some ") (str test-get-error "Other String"))))
</code></pre>
<h3 id="get-globals"><a class="header" href="#get-globals">get-globals</a></h3>
<p><strong>Usage:</strong> (get-globals)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a vector containing all the symbols currently defined globally.</p>
<p>No Examples</p>
<h3 id="get-prop"><a class="header" href="#get-prop">get-prop</a></h3>
<p><strong>Usage:</strong> (get-prop 'a-symbol :a-property))</p>
<p><strong>Namespace:</strong> root</p>
<p>Read property that maps to given keyword for provided-symbol. Most forms have
a :doc-string property that returns the docstring for the symbol.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="identity"><a class="header" href="#identity">identity</a></h3>
<p><strong>Usage:</strong> (identity arg)</p>
<p><strong>Namespace:</strong> root</p>
<p>Identity function.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (identity 0))
</code></pre>
<h3 id="inc"><a class="header" href="#inc">inc!</a></h3>
<p><strong>Usage:</strong> (inc! symbol [number]) -&gt; new value</p>
<p><strong>Namespace:</strong> root</p>
<p>Increment the value in symbol by one or the optional number</p>
<p>Example:</p>
<pre><code>(def *inc-test* 1)
(test::assert-equal 2 (inc! *inc-test*))
(test::assert-equal 2 *inc-test*)
(test::assert-equal 5 (inc! *inc-test* 3))
(test::assert-equal 5 *inc-test*)
(let (inc-test 1)
  (test::assert-equal 2 (inc! inc-test))
  (test::assert-equal 2 inc-test)
  (test::assert-equal 5 (inc! inc-test 3))
  (test::assert-equal 5 inc-test))
</code></pre>
<h3 id="is-noop"><a class="header" href="#is-noop">is-noop</a></h3>
<p><strong>Usage:</strong> (is-noop 'fn-to-test)</p>
<p><strong>Namespace:</strong> root</p>
<p>Report whether or not the provided function is currently set to do nothing.
When called with the 'noop function always returns true.</p>
<p>Example:</p>
<pre><code>(test::assert-true (is-noop 'noop))
(test::assert-false (is-noop 'fs-meta))
</code></pre>
<h3 id="len"><a class="header" href="#len">len</a></h3>
<p><strong>Usage:</strong> (len expression) -&gt; int</p>
<p><strong>Namespace:</strong> root</p>
<p>Return length of supplied expression.  The length of an atom is 1.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (len nil))
(test::assert-equal 5 (len "12345"))
; Note the unicode symbol is only one char even though it is more then one byte.
(test::assert-equal 6 (len "12345Σ"))
(test::assert-equal 3 (len '(1 2 3)))
(test::assert-equal 3 (len [1 2 3]))
(test::assert-equal 3 (len (list 1 2 3)))
(test::assert-equal 3 (len (vec 1 2 3)))
(test::assert-equal 1 (len 100))
(test::assert-equal 1 (len 100.0))
(test::assert-equal 1 (len \tab))
</code></pre>
<h3 id="let"><a class="header" href="#let">let</a></h3>
<p><strong>Usage:</strong> (let vals &amp;rest let-body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes list, vals, of form ((binding0 sexp0) (binding1 sexp1) ...) and evaluates
let-body with all values of binding bound to the result of the evaluation of
sexp.</p>
<p>Example:</p>
<pre><code>(def test-do-one "One1")
(def test-do-two "Two1")
(def test-do-three (let (test-do-one "One") (set! test-do-two "Two")(test::assert-equal "One" test-do-one)"Three"))
(test::assert-equal "One1" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
((fn (idx) (let (v2 (+ idx 2) v3 (+ idx 3))
    (test::assert-equal (+ idx 2) v2)
    (test::assert-equal (+ idx 3) v3)
    (if (&lt; idx 5) (recur (+ idx 1)))))0)
((fn (idx) (let (v2 (+ idx 2) v3 (+ idx 3))
    (test::assert-equal (+ idx 2) v2)
    (test::assert-equal (+ idx 3) v3)
    (if (&lt; idx 5) (this-fn (+ idx 1)))))0)
</code></pre>
<h3 id="let-while"><a class="header" href="#let-while">let-while</a></h3>
<p><strong>Usage:</strong> (let-while (initial-bindings) (loop bindings) condition &amp; let-body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes list of initial bindings (done once before loop) of form (binding0 sexp0, binding1 sexp1, ...),
and a list of loop bindings (done at the start of each iteration including the first) and evaluates
let-body with all values of binding bound to the result of the evaluation of
both bindings while condition is true.</p>
<p>Example:</p>
<pre><code>; both of these examples create a vector and iterate to print all the elements
; use traditional lisp structure
(def test-res [])
(let-while (l [1 2 3]) (done (empty? l), f (first l),  l (rest l)) (not done)
  (prn f)
  (vec-push! test-res f))
(let ([x y z] test-res)
  (test::assert-equal 1 x)
  (test::assert-equal 2 y)
  (test::assert-equal 3 z))
; same thing using destructuring
(def test-res [])
(let-while (l [1 2 3]) (done (empty? l), [% f &amp; l] l) (not done)
  (prn f)
  (vec-push! test-res f))
(let ([x y z] test-res)
  (test::assert-equal 1 x)
  (test::assert-equal 2 y)
  (test::assert-equal 3 z))
</code></pre>
<h3 id="load-1"><a class="header" href="#load-1">load</a></h3>
<p><strong>Usage:</strong> (load path) -&gt; [last form value]</p>
<p><strong>Namespace:</strong> root</p>
<p>Read and eval a file (from path- a string).  The load special form executes at compile time.
This means it's parameter must resolve at compile time.  Most of the time you will want to use
this in conjunction with 'with-ns' to namespace the contents.
Note: on it's own does nothing with namespaces.</p>
<p>Example:</p>
<pre><code>(comp-time (def test-temp-file (get-temp-file)) nil)
(defer (fs-rm test-temp-file))
(let (tst-file (fopen test-temp-file :create))
    (defer (fclose tst-file))
    (fprn tst-file "(with-ns test-load")
    (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
(load test-temp-file) ; put stuff in it's own namespace
(test::assert-equal '(1 2 3) (test-load::test-fn))


(with-ns test-out2
    (comp-time
        (def test-temp-file (get-temp-file))
        (let (tst-file (fopen test-temp-file :create))
            (defer (fclose tst-file))
            (fprn tst-file "(defn test-fn () '(1 2 3))"))
        nil)
    (defer (fs-rm test-temp-file))
    (load test-temp-file) ; put new stuff in current namespace
    (test::assert-equal '(1 2 3) (test-fn))
    (test::assert-equal '(1 2 3) (test-out2::test-fn)))
</code></pre>
<h3 id="load-rc"><a class="header" href="#load-rc">load-rc</a></h3>
<p><strong>Usage:</strong> (load-rc) | (load-rc "init.slosh)</p>
<p><strong>Namespace:</strong> root</p>
<p>Read and eval user's rc file, by default "init.slosh" or a user provided file path
found in '$HOME/.config/slosh/'.</p>
<p>No Examples</p>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<p><strong>Usage:</strong> (loop params bindings body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Binds bindings to parameters in body. Use recur with desired bindings for
subsequent iteration.
Within the loop the lambda 'break' will end the loop, break can take an option
argument that is what the loop produces (nil if no argument).</p>
<p>Example:</p>
<pre><code>(def tot 0)
(loop (idx) (3) (do
    (set! tot (+ tot 1))
    (if (&gt; idx 1) (recur (- idx 1)))))
(test::assert-equal 3 tot)
(def tot 0)
(loop (idx) (0)
    (set! tot (+ tot 1))
    (when (not (= idx 2))
        (recur (+ idx 1))))
(test::assert-equal 3 tot)
(test::assert-equal 11 (loop (idx) (0)
    (if (= idx 2) (break 11))
    (recur (+ idx 1))))
(test::assert-false (loop (idx) (0)
    (if (= idx 2) (break nil))
    (recur (+ idx 1))))
(test::assert-error (loop (idx) (0)
    (if (= idx 2) (break 1 3))
    (recur (+ idx 1))))
</code></pre>
<h3 id="macro"><a class="header" href="#macro">macro</a></h3>
<p><strong>Usage:</strong> (macro (args) `(apply + ,@args))</p>
<p><strong>Namespace:</strong> root</p>
<p>Define an anonymous macro.</p>
<p>Example:</p>
<pre><code>(def test-macro1 nil)
(def test-macro2 nil)
(def test-macro-empty (macro () nil))
(test::assert-false (test-macro-empty))
(def test-mac nil)
(def mac-var 2)
(let (mac-var 3)
  (set! test-mac (macro (x) (set! test-macro2 100) (test::assert-equal 3 mac-var) (* mac-var x))))
(set! test-macro1 (test-mac 10))
(test::assert-equal 30 test-macro1)
(test::assert-equal 100 test-macro2)
</code></pre>
<h3 id="mk-err"><a class="header" href="#mk-err">mk-err</a></h3>
<p><strong>Usage:</strong> (mk-err :keyword value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Create an error object.  This does not raise the error but merely creates it.
Can use car/cdr to extract the keyword and value.</p>
<p>Example:</p>
<pre><code>(let (error (mk-err :test "Test error"))
    (test::assert-equal :test (car error))
    (test::assert-equal "Test error" (cdr error))
    (test::assert-true (err? error)))
</code></pre>
<h3 id="noop"><a class="header" href="#noop">noop</a></h3>
<p><strong>Usage:</strong> (noop any*)</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes any number of arguments and always returns nil.</p>
<p>Example:</p>
<pre><code>(test::assert-equal nil (noop 'noop))
(test::assert-equal nil (noop "foo" :bar 'baz))
(test::assert-equal nil (noop))
</code></pre>
<h3 id="noop-fn"><a class="header" href="#noop-fn">noop-fn</a></h3>
<p><strong>Usage:</strong> (noop-fn 'fn-to-noop)</p>
<p><strong>Namespace:</strong> root</p>
<p>Alter the runtime so that the provided function is a no-operation (no-op or noop) that
does nothing and returns nil for the provided function. Any future call to this function
will do nothing, regardless of the arguments it is given.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="not-1"><a class="header" href="#not-1">not=</a></h3>
<p><strong>Usage:</strong> (not= arg1 arg2)</p>
<p><strong>Namespace:</strong> root</p>
<p>Test if two values are not equal using <code>=</code></p>
<p>Example:</p>
<pre><code>(test::assert-true (not= 0 1))
(test::assert-true (not= 1 1.0))
(test::assert-false (not= 2 2))
(test::assert-false (not= 0.0 -0.0))
</code></pre>
<h3 id="not-2"><a class="header" href="#not-2">not==</a></h3>
<p><strong>Usage:</strong> (not== arg1 arg2)</p>
<p><strong>Namespace:</strong> root</p>
<p>Test if two values are not numerically equal using <code>==</code></p>
<p>Example:</p>
<pre><code>(test::assert-true (not== 0 1))
(test::assert-false (not== 1 1.0))
(test::assert-false (not== 0.0 -0.0))
(test::assert-false (not== 2 2))
</code></pre>
<h3 id="nsubstitute"><a class="header" href="#nsubstitute">nsubstitute!</a></h3>
<p><strong>Usage:</strong> (nsubstitute! lst old-item new-item mods [SCRATCH] [SCRATCH] early-return)</p>
<p><strong>Namespace:</strong> root</p>
<p>Replaces all instances of old-item in lst with new-item. If last argument
passed in is keyword :first only the first instance of old-item will be
replaced.</p>
<p>Example:</p>
<pre><code>(let (lst (list 1 2 3 4 5))
    (test::assert-equal (list 1 2 2 4 5) (nsubstitute! lst 3 2))
    (test::assert-equal (list 1 2 2 4 5) lst)
    (test::assert-equal (list 1 3 2 4 5) (nsubstitute! lst 2 3 :first)))
</code></pre>
<h3 id="occurs"><a class="header" href="#occurs">occurs</a></h3>
<p><strong>Usage:</strong> (occurs (list 1 2 ...) 7)</p>
<p><strong>Namespace:</strong> root</p>
<p>Counts instances of item in sequence.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (occurs (list 1 3 5 2 4 8 2 4 88 2 1) 8))
(test::assert-equal 3 (occurs (list 1 3 5 2 4 10 2 4 88 2 1) 2))
(test::assert-equal 0 (occurs (list 1 3 5 2 4 10 2 4 88 2 1) 42))
</code></pre>
<h3 id="on-raised-error"><a class="header" href="#on-raised-error">on-raised-error</a></h3>
<p><strong>Usage:</strong> (on-raised-error (fn (error) ...))</p>
<p><strong>Namespace:</strong> root</p>
<p>Low level (consider this unstable) interface to the raised error machinery.
Useful for building higher level error handling (get-error for instance).
It takes either Nil or a callable with one parameter.  That parameter will be
the error that was raised.  The entire running "chunk" of code will be
displaced for the installed handler.  Probably best to use this with a
continuation or a function that ends in a continuation call otherwise it
may be difficult to reason about...</p>
<p>Will return the previously installed handler or Nil if one is not installed.
Calling with Nil will return the old handler and clear it (no handler
installed).</p>
<p>This special form will override breaking into the debugger when an error is
raised.</p>
<p>Example:</p>
<pre><code>(defmacro get-error-test (&amp; body)
`(let (old-error (on-raised-error nil))
    (defer (on-raised-error old-error))
    (call/cc (fn (k) (on-raised-error (fn (err) (k (cons (car err)(cdr err)))))
                (cons :ok (do ~@body))))))

(test::assert-equal (cons :ok 6) (get-error-test (let (x 1, y 5) (+ x y))))
(test::assert-equal '(:test . "error") (get-error-test (let (x 1, y 5) (err :test "error")(+ x y))))
</code></pre>
<h3 id="platform"><a class="header" href="#platform">platform</a></h3>
<p><strong>Usage:</strong> (platform)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns a string representing the platform.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="quote"><a class="header" href="#quote">quote</a></h3>
<p><strong>Usage:</strong> 'expression -&gt; expression</p>
<p><strong>Namespace:</strong> root</p>
<p>Return expression without evaluation.
The reader macro 'expression will expand to (quote expression).</p>
<p>Example:</p>
<pre><code>(test::assert-equal (list 1 2 3) (quote (1 2 3)))
(test::assert-equal (list 1 2 3) '(1 2 3))
(test::assert-equal '(1 2 3) (quote (1 2 3)))
</code></pre>
<h3 id="recur"><a class="header" href="#recur">recur</a></h3>
<p><strong>Usage:</strong> (recur &amp;rest)</p>
<p><strong>Namespace:</strong> root</p>
<p>Recursively call the enclosing function with the given parameters.  Recur uses
tail call optimization and must be in the tail position or it is an error.  For
a named function it would be equivalent to a normal recursive call in a tail
position but it requires a tail position and does not need a name (a normal
recursive call would work in a non-tail position but could blow the stack if
it is to deep- unlike a recur or tail position recursive call).
NOTE: potential footgun, the let macro expands to a lambda (fn) and a recur used
inside the let would bind with the let not the enclosing lambda (this would
apply to any macro that also expands to a lambda- this is by design with the
loop macro but would be unexpected with let).</p>
<p>Example:</p>
<pre><code>(def tot 0)
(loop (idx) (3) (do
    (set! tot (+ tot 1))
    (if (&gt; idx 1) (recur (- idx 1)))))
(test::assert-equal 3 tot)
(set! tot 0)
((fn (idx) (do
    (set! tot (+ tot 1))
    (if (&gt; idx 1) (recur (- idx 1)))))5)
(test::assert-equal 5 tot)
</code></pre>
<h3 id="set"><a class="header" href="#set">set!</a></h3>
<p><strong>Usage:</strong> (set! symbol expression) -&gt; expression</p>
<p><strong>Namespace:</strong> root</p>
<p>Sets an existing expression in the current scope(s).  Return the expression that was set.
Symbol is not evaluated.</p>
<p>Set will set the first binding it finds starting in the current scope and then
trying enclosing scopes until exhausted.</p>
<p>Example:</p>
<pre><code>(def test-do-one nil)
(def test-do-two nil)
(def test-do-three (do (set! test-do-one "One")(set! test-do-two "Two")"Three"))
(test::assert-equal "One" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
(let (test-do-one nil)
    ; set the currently scoped value.
    (test::assert-equal "1111" (set! test-do-one "1111"))
    (test::assert-equal "1111" test-do-one))
; Original outer scope not changed.
(test::assert-equal "One" test-do-one)
</code></pre>
<h3 id="set-env"><a class="header" href="#set-env">set-env</a></h3>
<p><strong>Usage:</strong> (set-env "NAME_OF_ENVIRONMENT_VARIABLE" "Value variable should be assigned")</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes two strings the first is the name of an environment variable, and the second is the
value it should bind.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="set-prop"><a class="header" href="#set-prop">set-prop</a></h3>
<p><strong>Usage:</strong> (set-prop 'a-symbol :a-property a-value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Write property with value for the given symbol.</p>
<p>Example:</p>
<pre><code>(def foo #t)
(set-prop 'foo :bar "baz")
(test::assert-equal "baz" (get-prop 'foo :bar))
</code></pre>
<h3 id="sizeof-heap-object"><a class="header" href="#sizeof-heap-object">sizeof-heap-object</a></h3>
<p><strong>Usage:</strong> (sizeof-heap-object)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns the default size of a heap object by the current runtime in bytes.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 16 (sizeof-heap-object))
</code></pre>
<h3 id="sizeof-value"><a class="header" href="#sizeof-value">sizeof-value</a></h3>
<p><strong>Usage:</strong> (sizeof-value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns the default size of a value by the current runtime in bytes. Optimized to
be 8 bytes so that a given primitve or pointer to a head object fits in one word
on a 64 bit machine.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 8 (sizeof-value))
</code></pre>
<h3 id="substitute"><a class="header" href="#substitute">substitute</a></h3>
<p><strong>Usage:</strong> (substitute lst old-item new-item mods)</p>
<p><strong>Namespace:</strong> root</p>
<p>Replaces all instances of old-item in copy of lst with new-item.  If last
argument passed in is keyword :first only the first instance of old-item will be
replaced.</p>
<p>Example:</p>
<pre><code>(let (lst (list 1 2 3 4 3)
      olst (list 1 2 3 4 3)
       lst2 (list 1 2 3 3 3 4 5)
      olst2 (list 1 2 3 3 3 4 5))
     (test::assert-equal (list 1 2 10 4 10) (substitute lst 3 10))
     (test::assert-equal (list 1 2 10 4 3) (substitute lst 3 10 :first))
     (test::assert-equal olst lst)
     (test::assert-equal (list 1 2 4 4 4 4 5) (substitute lst2 3 4))
     (test::assert-equal (list 1 2 4 3 3 4 5) (substitute lst2 3 4 :first))
     (test::assert-equal olst2 lst2))
</code></pre>
<h3 id="to-list"><a class="header" href="#to-list">to-list</a></h3>
<p><strong>Usage:</strong> (to-list any)</p>
<p><strong>Namespace:</strong> root</p>
<p>Turns any one value into a list. If that value or if it was a sequence
a new sequence with the same values.</p>
<p>No Examples</p>
<h3 id="to-vec"><a class="header" href="#to-vec">to-vec</a></h3>
<p><strong>Usage:</strong> (to-list any)</p>
<p><strong>Namespace:</strong> root</p>
<p>Turns any one value into a vector. If that value or if it was a sequence
a new sequence with the same values.</p>
<p>No Examples</p>
<h3 id="un-noop-fn"><a class="header" href="#un-noop-fn">un-noop-fn</a></h3>
<p><strong>Usage:</strong> (un-noop-fn 'fn-to-un-noop)</p>
<p><strong>Namespace:</strong> root</p>
<p>If the runtime was previously altered for the provided function (to make it do nothing)
swap the old function back in so the previous behavior is restored and the function
behaves as normal.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="unset-env"><a class="header" href="#unset-env">unset-env</a></h3>
<p><strong>Usage:</strong> (unset-env "NAME_OF_ENVIRONMENT_VARIABLE")</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a string, checks the environment to see if the string is a valid
environment variable and if it is it unsets it.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<p><strong>Usage:</strong> (usage 'symbol)</p>
<p><strong>Namespace:</strong> root</p>
<p>Provides usage information derived from the bytecode. Documentation can also have it's
own usage string provided in the doc string but this function returns what the actual
function's compiled code provides.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-1"><a class="header" href="#doc-1">doc</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/doc.html#build-doc">build-doc</a>, <a href="src/generated-sections/doc.html#doc-map">doc-map</a>, <a href="src/generated-sections/doc.html#doc-search">doc-search</a>, <a href="src/generated-sections/doc.html#get-exemptions">get-exemptions</a>, <a href="src/generated-sections/doc.html#get-globals-sorted">get-globals-sorted</a>, <a href="src/generated-sections/doc.html#legacy-report">legacy-report</a>, <a href="src/generated-sections/doc.html#legacyforms">legacy_forms</a></p>
<h3 id="build-doc"><a class="header" href="#build-doc">build-doc</a></h3>
<p><strong>Usage:</strong> (build-doc valid-filepath)</p>
<p><strong>Namespace:</strong> root</p>
<p>Uses mdbook to build the documentation for the given book.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="doc-map"><a class="header" href="#doc-map">doc-map</a></h3>
<p><strong>Usage:</strong> (doc-map symbol)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns documentation for given symbol as map. Keyword is a documentation fragment
(usage, section, description, example) and value is text describing given fragment.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="doc-search"><a class="header" href="#doc-search">doc-search</a></h3>
<p><strong>Usage:</strong> (doc-search query-string [options-map])</p>
<p><strong>Namespace:</strong> root</p>
<p>Search through all documentation for functions matching the query.
The query string is searched across all documentation fields by default.</p>
<p>Options map can contain:</p>
<ul>
<li>:regex #t - Use regular expressions for matching</li>
<li>:basic #t - Use basic matching (characters must appear in order)</li>
<li>:fields ["usage" "description"] - Limit search to specific fields</li>
<li>:namespace "namespace-name" - Filter by namespace</li>
<li>:section "section-name" - Filter by section</li>
<li>:markdown #t - Return results as a markdown-formatted string instead of vector</li>
<li>:styled #t - Return results with highlighted search matches</li>
<li>:style {:highlight-color "\x1b[43m\x1b[30m" ...} - Customize highlight style</li>
</ul>
<p>Style options (when :style map is provided):</p>
<ul>
<li>:highlight-color - Color for highlighting matches (default: yellow background, black text)</li>
<li>:default-color - Color to reset after highlight (default: \x1b[0m)</li>
<li>:use-background #f - Use foreground color instead of background</li>
</ul>
<p>When :styled is true, matching text in results is highlighted to show why
each result matched the search query.</p>
<p>Returns a vector of documentation maps, markdown string, or styled string.</p>
<p>Example:</p>
<pre><code>(doc-search "file")
(doc-search "^str-" {:regex #t})
(doc-search "core" {:fields ["section"]})
(doc-search "map" {:basic #t :section "core"})
(doc-search "string" {:markdown #t})
(doc-search "string" {:styled #t})
(doc-search "map" {:style {:highlight-color *fg-red* :use-background #f}})
</code></pre>
<h3 id="get-exemptions"><a class="header" href="#get-exemptions">get-exemptions</a></h3>
<p><strong>Usage:</strong> (get-exemptions)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a vector containing all the symbols currently exempted from docs
(so the build passes), Ideally this will be 0.</p>
<p>No Examples</p>
<h3 id="get-globals-sorted"><a class="header" href="#get-globals-sorted">get-globals-sorted</a></h3>
<p><strong>Usage:</strong> (get-globals-sorted)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a vector containing all the symbols currently defined globally in sorted order (alphanumerically).</p>
<p>No Examples</p>
<h3 id="legacy-report"><a class="header" href="#legacy-report">legacy-report</a></h3>
<p><strong>Usage:</strong> (legacy-report)</p>
<p><strong>Namespace:</strong> root</p>
<p>Output as a string the current legacy report, detailing how much of the former sl-sh project has been covered by the new slosh.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="legacy_forms"><a class="header" href="#legacy_forms">legacy_forms</a></h3>
<p><strong>Usage:</strong> (legacy_forms)</p>
<p><strong>Namespace:</strong> root</p>
<p>Gets list of all forms that were used in the previous version of sl_sh.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="file"><a class="header" href="#file">file</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/file.html#cd">cd</a>, <a href="src/generated-sections/file.html#fclose">fclose</a>, <a href="src/generated-sections/file.html#fflush">fflush</a>, <a href="src/generated-sections/file.html#fopen">fopen</a>, <a href="src/generated-sections/file.html#fs-accessed">fs-accessed</a>, <a href="src/generated-sections/file.html#fs-base">fs-base</a>, <a href="src/generated-sections/file.html#fs-crawl">fs-crawl</a>, <a href="src/generated-sections/file.html#fs-dir">fs-dir?</a>, <a href="src/generated-sections/file.html#fs-exists">fs-exists?</a>, <a href="src/generated-sections/file.html#fs-file">fs-file?</a>, <a href="src/generated-sections/file.html#fs-fullpath">fs-fullpath</a>, <a href="src/generated-sections/file.html#fs-len">fs-len</a>, <a href="src/generated-sections/file.html#fs-modified">fs-modified</a>, <a href="src/generated-sections/file.html#fs-parent">fs-parent</a>, <a href="src/generated-sections/file.html#fs-rm">fs-rm</a>, <a href="src/generated-sections/file.html#fs-same">fs-same?</a>, <a href="src/generated-sections/file.html#get-temp">get-temp</a>, <a href="src/generated-sections/file.html#get-temp-file">get-temp-file</a>, <a href="src/generated-sections/file.html#glob">glob</a>, <a href="src/generated-sections/file.html#read">read</a>, <a href="src/generated-sections/file.html#read-all">read-all</a>, <a href="src/generated-sections/file.html#read-line">read-line</a>, <a href="src/generated-sections/file.html#temp-dir">temp-dir</a>, <a href="src/generated-sections/file.html#with-temp">with-temp</a>, <a href="src/generated-sections/file.html#with-temp-file">with-temp-file</a></p>
<h3 id="cd"><a class="header" href="#cd">cd</a></h3>
<p><strong>Usage:</strong> (cd dir-to-change-to)</p>
<p><strong>Namespace:</strong> root</p>
<p>Change directory.</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-cd-marker") :create :truncate))
(test::assert-false (fs-exists? "fs-cd-marker"))
(cd tmp)
(test::assert-true (fs-exists? "fs-cd-marker"))
(cd)))
</code></pre>
<h3 id="fclose"><a class="header" href="#fclose">fclose</a></h3>
<p><strong>Usage:</strong> (fclose file)</p>
<p><strong>Namespace:</strong> root</p>
<p>Close a file.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
    (let (tst-file (fopen tmp-file :create :truncate))
        (fprn tst-file "Test Line Two")
        (fclose tst-file)
        (set! tst-file (fopen tmp-file :read))
        (defer (fclose tst-file))
        (test::assert-equal "Test Line Two
" (read-line tst-file)))))
</code></pre>
<h3 id="fflush"><a class="header" href="#fflush">fflush</a></h3>
<p><strong>Usage:</strong> (flush file)</p>
<p><strong>Namespace:</strong> root</p>
<p>Flush a file.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
    (let (tst-file (fopen tmp-file :create :truncate)
          tst-file-read (fopen tmp-file :read))
        (defer (fclose tst-file))
        (defer (fclose tst-file-read))
        (fprn tst-file "Test Line Three")
        (fflush tst-file)
        (test::assert-equal "Test Line Three
" (read-line tst-file-read)))))
</code></pre>
<h3 id="fopen"><a class="header" href="#fopen">fopen</a></h3>
<p><strong>Usage:</strong> (fopen filename option*)</p>
<p><strong>Namespace:</strong> root</p>
<p>Open a file.  If you use :read and :write then you get a read/write unbuffered file.  Including
one of :read or :write will provide a file buffered for read or write (this is faster).
Note: :append, :truncate, :create, :create-new all imply :write.</p>
<p>Options are:
:read
:write
:append
:truncate
:create
:create-new
:on-error-nil</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
    (let (test-open-f (fopen tmp-file :create :truncate))
        (fprn test-open-f "Test Line One")
        (fclose test-open-f)
        (set! test-open-f (fopen tmp-file :read))
        (defer (fclose test-open-f))
        (test::assert-equal "Test Line One
" (read-line test-open-f)))))
</code></pre>
<h3 id="fs-accessed"><a class="header" href="#fs-accessed">fs-accessed</a></h3>
<p><strong>Usage:</strong> (fs-accessed /path/to/file/or/dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns the unix time file last accessed in ms.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
(let (tst-file (fopen tmp :create)
last-acc (fs-accessed tmp))
(fclose tst-file)
(let (tst-file (fopen tmp :read))
(test::assert-true (&gt;= (fs-accessed tmp) last-acc))
(fclose tst-file)))))
</code></pre>
<h3 id="fs-base"><a class="header" href="#fs-base">fs-base</a></h3>
<p><strong>Usage:</strong> (fs-base /path/to/file/or/dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns base name of file or directory passed to function.</p>
<p>No Examples</p>
<h3 id="fs-crawl"><a class="header" href="#fs-crawl">fs-crawl</a></h3>
<p><strong>Usage:</strong> (fs-crawl /path/to/file/or/dir (fn (x) (prn "found path" x) [max-depth]
[:follow-syms])</p>
<p><strong>Namespace:</strong> root</p>
<p>If a directory is provided the path is recursively searched and every
file and directory is called as an argument to the provided function.
If a file is provided the path is provided as an argument to the provided
function. Takes two optional arguments (in any order) an integer,
representing max depth to traverse if file is a directory, or the
symbol, :follow-syms, to follow symbol links when traversing if
desired.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
(let (cnt 0)
(fs-crawl tmp-file (fn (x)
(test::assert-equal (fs-base tmp-file) (fs-base x))
(set! cnt (+ 1 cnt))))
(test::assert-equal 1 cnt))))


(defn create-in (in-dir num-files visited)
(dotimes-i i num-files
(let (tmp-file (get-temp-file in-dir))
(set! visited.~tmp-file #f))))

(defn create-dir (tmp-dir visited)
(let (new-tmp (get-temp tmp-dir))
(set! visited.~new-tmp #f)
new-tmp))

(with-temp (fn (root-tmp-dir)
(let (tmp-file-count 5
visited {}
cnt 0)
(set! visited.~root-tmp-dir #f)
(create-in root-tmp-dir tmp-file-count visited)
(let (tmp-dir (create-dir root-tmp-dir visited)
new-files (create-in tmp-dir tmp-file-count visited)
tmp-dir (create-dir tmp-dir visited)
new-files (create-in tmp-dir tmp-file-count visited))
(fs-crawl root-tmp-dir (fn (x)
(let (file visited.~x)
(test::assert-true (not file)) ;; also tests double counting
(set! visited.~x #t)
(inc! cnt))))
(test::assert-equal (+ 3 (* 3 tmp-file-count)) cnt)
(test::assert-equal (+ 3 (* 3 tmp-file-count)) (len visited))
(seq-for key in (hash-keys visited) (test::assert-true visited.~key))))))

(with-temp (fn (root-tmp-dir)
(let (tmp-file-count 5
visited {}
cnt 0)
(set! visited.~root-tmp-dir #f)
(create-in root-tmp-dir tmp-file-count visited)
(let (tmp-dir (create-dir root-tmp-dir visited)
new-files (create-in tmp-dir tmp-file-count visited)
tmp-dir (create-dir tmp-dir {})
new-files (do (set! visited.~tmp-dir #f)(create-in tmp-dir tmp-file-count {})))
(fs-crawl root-tmp-dir (fn (x)
(let (file visited.~x)
(test::assert-true (not file)) ;; also tests double counting
(set! visited.~x #t)
(inc! cnt))) 2)
(test::assert-equal (+ 3 (* 2 tmp-file-count)) cnt)
(test::assert-equal (+ 3 (* 2 tmp-file-count)) (len visited))
(seq-for key in (hash-keys visited) (test::assert-true visited.~key))))))

(with-temp (fn (root-tmp-dir)
(let (tmp-file-count 5
visited {}
cnt 0)
(set! visited.~root-tmp-dir #f)
(create-in root-tmp-dir tmp-file-count visited)
(let (tmp-dir (create-dir root-tmp-dir {})
new-files (do (set! visited.~tmp-dir #f)(create-in tmp-dir tmp-file-count {}))
tmp-dir (create-dir tmp-dir {})
new-files (create-in tmp-dir tmp-file-count {}))
(fs-crawl root-tmp-dir (fn (x)
(let (file visited.~x)
(test::assert-true (not file)) ;; also tests double counting
(set! visited.~x #t)
(inc! cnt))) 1)
(test::assert-equal (+ 2 tmp-file-count) cnt)
(test::assert-equal (+ 2 tmp-file-count) (len visited))
(seq-for key in (hash-keys visited) (test::assert-true visited.~key))))))
</code></pre>
<h3 id="fs-dir"><a class="header" href="#fs-dir">fs-dir?</a></h3>
<p><strong>Usage:</strong> (fs-dir? path-to-test)</p>
<p><strong>Namespace:</strong> root</p>
<p>Is the given path a directory?</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-dir-file") :create :truncate))
(test::assert-false (fs-dir? (str tmp "/fs-dir-file")))
(test::assert-true (fs-dir? tmp))
(test::assert-false (fs-file? (str tmp "/fs-dir-nope")))))
</code></pre>
<h3 id="fs-exists"><a class="header" href="#fs-exists">fs-exists?</a></h3>
<p><strong>Usage:</strong> (fs-exists? path-to-test)</p>
<p><strong>Namespace:</strong> root</p>
<p>Does the given path exist?</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-exists") :create :truncate))
(test::assert-true (fs-exists? (str tmp "/fs-exists")))
(test::assert-true (fs-exists? tmp))
(test::assert-false (fs-exists? (str tmp "/fs-exists-nope")))))
</code></pre>
<h3 id="fs-file"><a class="header" href="#fs-file">fs-file?</a></h3>
<p><strong>Usage:</strong> (fs-file? path-to-test)</p>
<p><strong>Namespace:</strong> root</p>
<p>Is the given path a file?</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-file") :create :truncate))
(test::assert-true (fs-file? (str tmp "/fs-file")))
(test::assert-false (fs-file? tmp))
(test::assert-false (fs-file? (str tmp "/fs-file-nope")))))
</code></pre>
<h3 id="fs-fullpath"><a class="header" href="#fs-fullpath">fs-fullpath</a></h3>
<p><strong>Usage:</strong> (fs-fullpath "~/some/filepath/../") -&gt; nil</p>
<p><strong>Namespace:</strong> root</p>
<p>Return absolute 'canonical' file path.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="fs-len"><a class="header" href="#fs-len">fs-len</a></h3>
<p><strong>Usage:</strong> (fs-len /path/to/file/or/dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns the size of the file in bytes.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
(let (tst-file (fopen tmp :create :truncate))
(fprn tst-file "Test Line Read Line One")
(fpr tst-file "Test Line Read Line Two")
(fclose tst-file)
(test::assert-equal 47 (fs-len tmp)))))
</code></pre>
<h3 id="fs-modified"><a class="header" href="#fs-modified">fs-modified</a></h3>
<p><strong>Usage:</strong> (fs-modified /path/to/file/or/dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns the unix time file last modified in ms.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
(let (tst-file (fopen tmp :create :truncate)
last-mod (fs-modified tmp))
(fprn tst-file "Test Line Read Line One")
(fpr tst-file "Test Line Read Line Two")
(fflush tst-file)
(fclose tst-file)
(test::assert-true (&gt;= (fs-modified tmp) last-mod)))))
</code></pre>
<h3 id="fs-parent"><a class="header" href="#fs-parent">fs-parent</a></h3>
<p><strong>Usage:</strong> (fs-parent /path/to/file/or/dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns base name of file or directory passed to function.</p>
<p>No Examples</p>
<h3 id="fs-rm"><a class="header" href="#fs-rm">fs-rm</a></h3>
<p><strong>Usage:</strong> (fs-rm "/dir/or/file/to/remove")</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a file or directory as a string and removes it. Works recursively for directories.</p>
<p>Example:</p>
<pre><code>(def fp nil)
(let (a-file (get-temp-file))
(test::assert-true (fs-exists? a-file))
(set! fp a-file)
(fs-rm a-file))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))
</code></pre>
<h3 id="fs-same"><a class="header" href="#fs-same">fs-same?</a></h3>
<p><strong>Usage:</strong> (fs-same? /path/to/file/or/dir /path/to/file/or/dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns true if the two provided file paths refer to the same file or directory.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
(test::assert-true (fs-same? tmp-file tmp-file))))
</code></pre>
<h3 id="get-temp"><a class="header" href="#get-temp">get-temp</a></h3>
<p><strong>Usage:</strong> (get-temp ["/path/to/directory/to/use/as/base" "optional-prefix" "optional-suffix" length])</p>
<p><strong>Namespace:</strong> root</p>
<p>Creates a directory inside of an OS specific temporary directory. See <a href="root::temp-dir">temp-dir</a>
for OS specific notes. Also accepts an optional prefix, an optional suffix, and an optional
length for the random number of characters in the temporary file created. Defaults to prefix of
".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-contains (get-temp) (temp-dir)))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp))
(test::assert-true (str-contains tmp-dir tmp)))))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp "some-prefix"))
(test::assert-true (str-contains tmp-dir tmp))
(test::assert-true (str-contains tmp-dir "some-prefix")))))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp "some-prefix" "some-suffix"))
(test::assert-true (str-contains tmp-dir tmp))
(test::assert-true (str-contains tmp-dir "some-prefix"))
(test::assert-true (str-contains tmp-dir "some-suffix")))))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp "some-prefix" "some-suffix" 6))
(test::assert-true (str-contains tmp-dir tmp))
(test::assert-true (str-contains tmp-dir "some-prefix"))
(test::assert-true (str-contains tmp-dir "some-suffix"))
(test::assert-equal (len "some-prefix012345some-suffix") (len (fs-base tmp-dir))))))
</code></pre>
<h3 id="get-temp-file"><a class="header" href="#get-temp-file">get-temp-file</a></h3>
<p><strong>Usage:</strong> (get-temp-file ["/path/to/directory/to/use/as/base" "optional-prefix" "optional-suffix" length])</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns name of file created inside temporary directory. Optionally takes a directory to use as
the parent directory of the temporary file. Also accepts an optional prefix, an optional suffix,
and an optional length for the random number of characters in the temporary files created. Defaults
to prefix of ".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-contains (get-temp-file) (temp-dir)))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp))
(test::assert-true (str-contains tmp-file tmp)))))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp "some-prefix"))
(test::assert-true (str-contains tmp-file "some-prefix")))))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp "some-prefix" "some-suffix"))
(test::assert-true (str-contains tmp-file "some-prefix"))
(test::assert-true (str-contains tmp-file "some-suffix")))))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp "some-prefix" "some-suffix" 10))
(test::assert-true (str-contains tmp-file "some-prefix"))
(test::assert-true (str-contains tmp-file "some-suffix"))
(test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp-file))))))
</code></pre>
<h3 id="glob"><a class="header" href="#glob">glob</a></h3>
<p><strong>Usage:</strong> (glob /path/with/*)</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a list/varargs of globs and return the list of them expanded.</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/g1") :create :truncate))
(fclose (fopen (str tmp "/g2") :create :truncate))
(fclose (fopen (str tmp "/g3") :create :truncate))
(test::assert-equal [(str tmp "/g1") (str tmp "/g2") (str tmp "/g3")] (glob (str tmp "/*")))))
</code></pre>
<h3 id="read"><a class="header" href="#read">read</a></h3>
<p><strong>Usage:</strong> (read file|string end-exp?) -&gt; expression</p>
<p><strong>Namespace:</strong> root</p>
<p>Read a file or string and return the next object (symbol, string, list, etc).
Raises an error if the file or string has been read unless end-exp is provided
then returns that on the end condition.
Note: When reading a string read always starts at the beginning of the string.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create :truncate)
          test-str nil)
        (fprn tst-file "(1 2 3)(x y z)")
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (test::assert-equal '(1 2 3) (read tst-file))
        (test::assert-equal '(x y z) (read tst-file))
        (test::assert-error (read tst-file))
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (test::assert-equal '(1 2 3) (read tst-file :done))
        (test::assert-equal '(x y z) (read tst-file :done))
        (test::assert-equal :done (read tst-file :done))
        (fclose tst-file)
        (test::assert-equal '(4 5 6) (read "(4 5 6)"))
        (set! test-str "7 8 9")
        (test::assert-equal 7 (read test-str))
        (test::assert-equal 7 (read test-str))
        (test::assert-equal '(x y z) (read "(x y z)")))))
</code></pre>
<h3 id="read-all"><a class="header" href="#read-all">read-all</a></h3>
<p><strong>Usage:</strong> (read-all file|string) -&gt; vec</p>
<p><strong>Namespace:</strong> root</p>
<p>Read a file or string and return the vector of contained expressions.  This reads the entire
file or string and will wrap it in an outer vector (always returns a vector).</p>
<p>Unlike most lisp readers this one will put loose symbols in a vector (i.e. you
enter things at the repl without the enclosing parens).</p>
<p>If the read item is empty (including a comment) then will return an empty vector.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create :truncate)
          test-str nil)
        (fprn tst-file "(1 2 3)(x y z)")
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (test::assert-equal ['(1 2 3)'(x y z)] (read-all tst-file))
        (fclose tst-file)
        (test::assert-equal ['(4 5 6)] (read-all "(4 5 6)"))
        (test::assert-equal [7 8 9] (read-all "7 8 9"))
        (test::assert-equal ['(x y z)] (read-all "(x y z)"))
        (test::assert-equal [] (read-all ";(x y z)")))))
</code></pre>
<h3 id="read-line"><a class="header" href="#read-line">read-line</a></h3>
<p><strong>Usage:</strong> (read-line file) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Read a line from a file.  Returns Nil if there is nothing left to read.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create :truncate))
        (fprn tst-file "Test Line Read Line One")
        (fpr tst-file "Test Line Read Line Two")
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (defer (fclose tst-file))
        (test::assert-equal "Test Line Read Line One\n" (read-line tst-file))
        (test::assert-equal "Test Line Read Line Two" (read-line tst-file)))))
</code></pre>
<h3 id="temp-dir"><a class="header" href="#temp-dir">temp-dir</a></h3>
<p><strong>Usage:</strong> (temp-dir)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns a string representing the temporary directory. See <a href="root::get-temp">get-temp</a> for higher
level temporary directory creation mechanism.</p>
<p>On Unix:
Returns the value of the TMPDIR environment variable if it is set, otherwise for non-Android it
returns /tmp. If Android, since there is no global temporary folder (it is usually allocated
per-app), it returns /data/local/tmp.</p>
<p>On Windows:
Returns the value of, in order, the TMP, TEMP, USERPROFILE environment variable if any are set and
not the empty string. Otherwise, temp_dir returns the path of the Windows directory. This behavior
is identical to that of GetTempPath, which this function uses internally.</p>
<p>Example:</p>
<pre><code>(test::assert-true (fs-dir? (temp-dir)))
</code></pre>
<h3 id="with-temp"><a class="header" href="#with-temp">with-temp</a></h3>
<p><strong>Usage:</strong> (with-temp (fn (x) (println "given temp dir:" x)) ["optional-prefix" "optional-suffix" length])</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a function that accepts a temporary directory. This directory will be recursively removed
when the provided function is finished executing. Also accepts an optional prefix, an optional
suffix, and an optional length for the random number of characters in the temporary directory
created. Defaults to prefix of ".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(def fp nil)
(with-temp (fn (tmp-dir)
    (let (tmp-file (str tmp-dir "/sl-sh-tmp-file.txt")
         a-file (fopen tmp-file :create :truncate))
        (test::assert-true (fs-exists? tmp-file))
        (set! fp tmp-file)
        (fclose a-file))))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix")))
    "some-prefix")

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix")))
    "some-prefix"
    "some-suffix")

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix"))
        (test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp))))
    "some-prefix"
    "some-suffix"
    10)
</code></pre>
<h3 id="with-temp-file"><a class="header" href="#with-temp-file">with-temp-file</a></h3>
<p><strong>Usage:</strong> (with-temp-file (fn (x) (println "given temp file:" x)) ["optional-prefix" "optional-suffix" length])</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a function that accepts a temporary file. This file will be removed when the provided function
is finished executing. Also accepts an optional prefix, an optional suffix, and an optional
length for the random number of characters in the temporary file created. Defaults to prefix of
".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(def fp nil)
(with-temp-file (fn (tmp-file)
    (let (a-file (fopen tmp-file :create :truncate))
        (test::assert-true (fs-exists? tmp-file))
        (set! fp tmp-file)
        (fclose a-file))))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix")))
    "some-prefix")

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix")))
    "some-prefix"
    "some-suffix")

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix"))
        (test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp))))
    "some-prefix"
    "some-suffix"
    10)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hashmap-1"><a class="header" href="#hashmap-1">hashmap</a></h2>
<p>Hashmaps as a collection benefit from the same syntactic sugar provided by the
reader macro with the added support of some generic collection functions, <code>get</code>,
<code>set!</code>, and <code>clear!</code>.</p>
<p>For retrieving items from a hashmap prefer the reader syntax (<object>.<keyword>) or use the <code>get</code>
function.</p>
<pre><code class="language-slosh">(def m {:one "one", :two "two", "three" 3})
(and (= "one" m.:one)
    (= "two" m.:two)
    (= 3 (get m "three")))

;; =&gt; true
</code></pre>
<p>For setting key/value pairs on an existing hashmap prefer the reader syntax
with the <code>set!</code> function or pass it the output of <code>get</code>.</p>
<pre><code class="language-slosh">(def m {:one "one", :two "two", "three" 3, :four 4})
(set! m.:one "changed1")
(set! m.:two "changed2")
(set! (get m "three") "changed3")
(and (= "changed1" m.:one)
    (= "changed2" m.:two)
    (= "changed3" (get m "three")))

(def four :four)
(set! m.~four "changed4")
(= "changed4" (get m :four))

;; =&gt; true
</code></pre>
<p>Clearing all keys is done with the <code>clear!</code> function.</p>
<pre><code class="language-slosh">(def m {:one "one", :two "two", "three" 3})
(clear! m)
(= (make-hash) m)

;; =&gt; true
</code></pre>
<p>** Hashmap keys that are not keyword types (not prefixed by a colon) can not be
used with the reader syntax, which is why in the example the key "three" was
used with the <code>get</code> function each time instead of using the reader syntax.</p>
<p>List of symbols:</p>
<p><a href="src/generated-sections/hashmap.html#hash-clear">hash-clear!</a>, <a href="src/generated-sections/hashmap.html#hash-haskey">hash-haskey?</a>, <a href="src/generated-sections/hashmap.html#hash-keys">hash-keys</a>, <a href="src/generated-sections/hashmap.html#hash-remove">hash-remove!</a>, <a href="src/generated-sections/hashmap.html#make-hash">make-hash</a></p>
<h3 id="hash-clear"><a class="header" href="#hash-clear">hash-clear!</a></h3>
<p><strong>Usage:</strong> (hash-clear! hashmap)</p>
<p><strong>Namespace:</strong> root</p>
<p>Clear all entries from a hashmap. This is a destructive form!</p>
<p>Example:</p>
<pre><code>(def tst-hash {:key1 "val one" 'key2 "val two" "key3" "val three"})
(test::assert-equal 3 (len tst-hash))
(hash-clear! tst-hash)
(test::assert-equal 0 (len tst-hash))
(test::assert-equal {} tst-hash)
</code></pre>
<h3 id="hash-haskey"><a class="header" href="#hash-haskey">hash-haskey?</a></h3>
<p><strong>Usage:</strong> (hash-haskey? hashmap key)</p>
<p><strong>Namespace:</strong> root</p>
<p>Checks if a key is in a hashmap.</p>
<p>Example:</p>
<pre><code>(def tst-hash {:key1  "val one" 'key2 "val two" "key3" "val three" \S "val S"})
(test::assert-equal 4 (len (hash-keys tst-hash)))
(test::assert-true (hash-haskey? tst-hash :key1))
(test::assert-true (hash-haskey? tst-hash 'key2))
(test::assert-true (hash-haskey? tst-hash "key3"))
(test::assert-true (hash-haskey? tst-hash \S))
(test::assert-false (hash-haskey? tst-hash 'key1))
(test::assert-false (hash-haskey? tst-hash :key2))
(test::assert-false (hash-haskey? tst-hash "keynone"))
(hash-remove! tst-hash :key1)
(test::assert-false (hash-haskey? tst-hash :key1))
(set! tst-hash.:key1 "val one b")
(test::assert-true (hash-haskey? tst-hash :key1))
</code></pre>
<h3 id="hash-keys"><a class="header" href="#hash-keys">hash-keys</a></h3>
<p><strong>Usage:</strong> (hash-keys hashmap)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns a vector of all the hashmaps keys.  The keys will be unordered.</p>
<p>Example:</p>
<pre><code>(def tst-hash {:key1  "val one" 'key2 "val two" "key3" "val three" \S "val S"})
(test::assert-equal 4 (len (hash-keys tst-hash)))
(test::assert-true (in? (hash-keys tst-hash) :key1) " Test :key1")
(test::assert-true (in? (hash-keys tst-hash) 'key2) " Test key2")
(test::assert-true (in? (hash-keys tst-hash) \S) " Test S")
(test::assert-true (in? (hash-keys tst-hash) "key3") " Test key3")
(test::assert-false (in? (hash-keys tst-hash) :key4))
</code></pre>
<h3 id="hash-remove"><a class="header" href="#hash-remove">hash-remove!</a></h3>
<p><strong>Usage:</strong> (hash-remove! hashmap key)</p>
<p><strong>Namespace:</strong> root</p>
<p>Remove a key from a hashmap. This is a destructive form!</p>
<p>Example:</p>
<pre><code>(def tst-hash {:key1  "val one" 'key2 "val two" "key3" "val three" \S "val S"})
(test::assert-equal 4 (len (hash-keys tst-hash)))
(test::assert-equal "val one" tst-hash.:key1)
(test::assert-equal "val two" (get tst-hash 'key2))
(test::assert-equal "val three" (get tst-hash "key3"))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash 'key2)
(test::assert-equal 3 (len (hash-keys tst-hash)))
(test::assert-equal "val one" tst-hash.:key1)
(test::assert-equal "val three" (get tst-hash "key3"))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash :key1)
(test::assert-equal 2 (len (hash-keys tst-hash)))
(test::assert-equal "val three" (get tst-hash "key3"))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash "key3")
(test::assert-equal 1 (len (hash-keys tst-hash)))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash \S)
(test::assert-equal 0 (len (hash-keys tst-hash)))
</code></pre>
<h3 id="make-hash"><a class="header" href="#make-hash">make-hash</a></h3>
<p><strong>Usage:</strong> (make-hash associations?)</p>
<p><strong>Namespace:</strong> root</p>
<p>Make a new hash map.</p>
<p>If associations is provided (makes an empty map if not) then it is a list of
pairs (key . value) that populate the initial map.  Neither key nor value in the
associations will be evaluated.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="io"><a class="header" href="#io">io</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/io.html#fs-meta">fs-meta</a></p>
<h3 id="fs-meta"><a class="header" href="#fs-meta">fs-meta</a></h3>
<p><strong>Usage:</strong> (fs-meta [FILENAME]) -&gt; map</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns a map of a files meta data.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iterator"><a class="header" href="#iterator">iterator</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/iterator.html#enumerate">enumerate</a>, <a href="src/generated-sections/iterator.html#enumerate">enumerate</a>, <a href="src/generated-sections/iterator.html#file-iter">file-iter</a>, <a href="src/generated-sections/iterator.html#file-iter">file-iter</a>, <a href="src/generated-sections/iterator.html#filter">filter</a>, <a href="src/generated-sections/iterator.html#filter">filter</a>, <a href="src/generated-sections/iterator.html#for">for</a>, <a href="src/generated-sections/iterator.html#for">for</a>, <a href="src/generated-sections/iterator.html#iter">iter</a>, <a href="src/generated-sections/iterator.html#iter">iter</a>, <a href="src/generated-sections/iterator.html#iter-or-single">iter-or-single</a>, <a href="src/generated-sections/iterator.html#iter-or-single">iter-or-single</a>, <a href="src/generated-sections/iterator.html#iter">iter?</a>, <a href="src/generated-sections/iterator.html#iter">iter?</a>, <a href="src/generated-sections/iterator.html#list-iter">list-iter</a>, <a href="src/generated-sections/iterator.html#list-iter">list-iter</a>, <a href="src/generated-sections/iterator.html#map">map</a>, <a href="src/generated-sections/iterator.html#map">map</a>, <a href="src/generated-sections/iterator.html#mk-iter">mk-iter</a>, <a href="src/generated-sections/iterator.html#mk-iter">mk-iter</a>, <a href="src/generated-sections/iterator.html#once-iter">once-iter</a>, <a href="src/generated-sections/iterator.html#once-iter">once-iter</a>, <a href="src/generated-sections/iterator.html#range">range</a>, <a href="src/generated-sections/iterator.html#range">range</a>, <a href="src/generated-sections/iterator.html#reduce">reduce</a>, <a href="src/generated-sections/iterator.html#reduce">reduce</a>, <a href="src/generated-sections/iterator.html#repeat-iter">repeat-iter</a>, <a href="src/generated-sections/iterator.html#repeat-iter">repeat-iter</a>, <a href="src/generated-sections/iterator.html#string-iter">string-iter</a>, <a href="src/generated-sections/iterator.html#string-iter">string-iter</a>, <a href="src/generated-sections/iterator.html#vec-iter">vec-iter</a>, <a href="src/generated-sections/iterator.html#vec-iter">vec-iter</a>, <a href="src/generated-sections/iterator.html#vec-iter-pair">vec-iter-pair</a>, <a href="src/generated-sections/iterator.html#vec-iter-pair">vec-iter-pair</a>, <a href="src/generated-sections/iterator.html#vec-iter-rev">vec-iter-rev</a>, <a href="src/generated-sections/iterator.html#vec-iter-rev">vec-iter-rev</a></p>
<h3 id="enumerate"><a class="header" href="#enumerate">enumerate</a></h3>
<p><strong>Usage:</strong> (iter::enumerate iter start [SCRATCH] [SCRATCH] idx [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps an iterator and generates pairs of current index and value.
Index is 0 based by default, takes an optional second parameter with the start
index.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (enumerate (vec-iter [:a :b :c])))
    (let ([i v] (test-iter)) (test::assert-equal 0 i) (test::assert-equal :a v))
    (let ([i v] (test-iter)) (test::assert-equal 1 i) (test::assert-equal :b v))
    (let ([i v] (test-iter)) (test::assert-equal 2 i) (test::assert-equal :c v))
    (test::assert-equal :*iter-empty* (test-iter)))
(let (test-iter (enumerate (vec-iter [:a :b :c]) 5))
    (let ([i v] (test-iter)) (test::assert-equal 5 i) (test::assert-equal :a v))
    (let ([i v] (test-iter)) (test::assert-equal 6 i) (test::assert-equal :b v))
    (let ([i v] (test-iter)) (test::assert-equal 7 i) (test::assert-equal :c v))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="enumerate-1"><a class="header" href="#enumerate-1">enumerate</a></h3>
<p><strong>Usage:</strong> (iter::enumerate iter start [SCRATCH] [SCRATCH] idx [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps an iterator and generates pairs of current index and value.
Index is 0 based by default, takes an optional second parameter with the start
index.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (enumerate (vec-iter [:a :b :c])))
    (let ([i v] (test-iter)) (test::assert-equal 0 i) (test::assert-equal :a v))
    (let ([i v] (test-iter)) (test::assert-equal 1 i) (test::assert-equal :b v))
    (let ([i v] (test-iter)) (test::assert-equal 2 i) (test::assert-equal :c v))
    (test::assert-equal :*iter-empty* (test-iter)))
(let (test-iter (enumerate (vec-iter [:a :b :c]) 5))
    (let ([i v] (test-iter)) (test::assert-equal 5 i) (test::assert-equal :a v))
    (let ([i v] (test-iter)) (test::assert-equal 6 i) (test::assert-equal :b v))
    (let ([i v] (test-iter)) (test::assert-equal 7 i) (test::assert-equal :c v))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="file-iter"><a class="header" href="#file-iter">file-iter</a></h3>
<p><strong>Usage:</strong> (iter::file-iter f [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps a file.  Each call produces the next line (with
trailing newline).</p>
<p>Example:</p>
<pre><code>(import iter)
(with-temp-file (fn (file-name)
    (let (tst-file (fopen file-name :create :truncate))
        (defer (fclose tst-file))
        (fprn tst-file "line 1")
        (fprn tst-file "line 2")
        (fprn tst-file "line 3")
        (fpr tst-file "line 4"))
    (let (tst-file (fopen file-name), test-iter (file-iter tst-file))
        (defer (fclose tst-file))
        (test::assert-equal "line 1\n" (test-iter))
        (test::assert-equal "line 2\n" (test-iter))
        (test::assert-equal "line 3\n" (test-iter))
        (test::assert-equal "line 4" (test-iter))
        (test::assert-equal :*iter-empty* (test-iter)))))
</code></pre>
<h3 id="file-iter-1"><a class="header" href="#file-iter-1">file-iter</a></h3>
<p><strong>Usage:</strong> (iter::file-iter f [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps a file.  Each call produces the next line (with
trailing newline).</p>
<p>Example:</p>
<pre><code>(import iter)
(with-temp-file (fn (file-name)
    (let (tst-file (fopen file-name :create :truncate))
        (defer (fclose tst-file))
        (fprn tst-file "line 1")
        (fprn tst-file "line 2")
        (fprn tst-file "line 3")
        (fpr tst-file "line 4"))
    (let (tst-file (fopen file-name), test-iter (file-iter tst-file))
        (defer (fclose tst-file))
        (test::assert-equal "line 1\n" (test-iter))
        (test::assert-equal "line 2\n" (test-iter))
        (test::assert-equal "line 3\n" (test-iter))
        (test::assert-equal "line 4" (test-iter))
        (test::assert-equal :*iter-empty* (test-iter)))))
</code></pre>
<h3 id="filter"><a class="header" href="#filter">filter</a></h3>
<p><strong>Usage:</strong> (iter::filter iter lambda [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Returns a filter-iter around iter.
Iterator that applies a lambda to each element to determine if is returned- is lazy.</p>
<p>Example:</p>
<pre><code>(let (test-iter (iter::filter (iter::vec-iter [1 2 3]) (fn (x) (not (= x 2)))))
    (test::assert-equal 1 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="filter-1"><a class="header" href="#filter-1">filter</a></h3>
<p><strong>Usage:</strong> (iter::filter iter lambda [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns a filter-iter around iter.
Iterator that applies a lambda to each element to determine if is returned- is lazy.</p>
<p>Example:</p>
<pre><code>(let (test-iter (iter::filter (iter::vec-iter [1 2 3]) (fn (x) (not (= x 2)))))
    (test::assert-equal 1 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<p><strong>Usage:</strong> (iter::for bind in items body [SCRATCH] [SCRATCH] i-name actual-bind)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Loops over each element in an iterator.
The bind parameter is bound to the current element of items and is accessible
in body. Body is evaluated a number of times equal to the items in the iterator.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (i 0)
    (for x in (range 0 11) (set! i (+ 1 i)))
    (test::assert-equal 11 i))
(let (v [:a :b :c], iter (enumerate (vec-iter v)))
    (for [idx, val] in iter (test::assert-equal v.~idx val)))
</code></pre>
<h3 id="for-1"><a class="header" href="#for-1">for</a></h3>
<p><strong>Usage:</strong> (iter::for bind in items body [SCRATCH] [SCRATCH] i-name actual-bind)</p>
<p><strong>Namespace:</strong> root</p>
<p>Loops over each element in an iterator.
The bind parameter is bound to the current element of items and is accessible
in body. Body is evaluated a number of times equal to the items in the iterator.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (i 0)
    (for x in (range 0 11) (set! i (+ 1 i)))
    (test::assert-equal 11 i))
(let (v [:a :b :c], iter (enumerate (vec-iter v)))
    (for [idx, val] in iter (test::assert-equal v.~idx val)))
</code></pre>
<h3 id="iter"><a class="header" href="#iter">iter</a></h3>
<p><strong>Usage:</strong> (iter::iter thing)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Return thing as an iterator if possible (if it is an iterator just return thing).</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (iter '(1 2 3))))
(test::assert-true (iter? (iter [1 2 3])))
(test::assert-true (iter? (iter "abc")))
(test::assert-true (iter? (iter (iter '(1 2 3)))))
</code></pre>
<h3 id="iter-1"><a class="header" href="#iter-1">iter</a></h3>
<p><strong>Usage:</strong> (iter::iter thing)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return thing as an iterator if possible (if it is an iterator just return thing).</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (iter '(1 2 3))))
(test::assert-true (iter? (iter [1 2 3])))
(test::assert-true (iter? (iter "abc")))
(test::assert-true (iter? (iter (iter '(1 2 3)))))
</code></pre>
<h3 id="iter-or-single"><a class="header" href="#iter-or-single">iter-or-single</a></h3>
<p><strong>Usage:</strong> (iter::iter-or-single thing)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Return thing as an iterator if possible (if it is an iterator just return thing).
If not possible then wrap thing in a once iter and return that.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (iter-or-single '(1 2 3))))
(test::assert-true (iter? (iter-or-single [1 2 3])))
(test::assert-true (iter? (iter-or-single "abc")))
(test::assert-true (iter? (iter-or-single (iter '(1 2 3)))))
(test::assert-true (iter? (iter-or-single 1)))
(test::assert-true (iter? (iter-or-single \A)))
</code></pre>
<h3 id="iter-or-single-1"><a class="header" href="#iter-or-single-1">iter-or-single</a></h3>
<p><strong>Usage:</strong> (iter::iter-or-single thing)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return thing as an iterator if possible (if it is an iterator just return thing).
If not possible then wrap thing in a once iter and return that.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (iter-or-single '(1 2 3))))
(test::assert-true (iter? (iter-or-single [1 2 3])))
(test::assert-true (iter? (iter-or-single "abc")))
(test::assert-true (iter? (iter-or-single (iter '(1 2 3)))))
(test::assert-true (iter? (iter-or-single 1)))
(test::assert-true (iter? (iter-or-single \A)))
</code></pre>
<h3 id="iter-2"><a class="header" href="#iter-2">iter?</a></h3>
<p><strong>Usage:</strong> (iter::iter? test)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Return true if thing is an iterator, false otherwise.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (list-iter '(1 2 3))))
(test::assert-false (iter? '(1 2 3)))
</code></pre>
<h3 id="iter-3"><a class="header" href="#iter-3">iter?</a></h3>
<p><strong>Usage:</strong> (iter::iter? test)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return true if thing is an iterator, false otherwise.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (list-iter '(1 2 3))))
(test::assert-false (iter? '(1 2 3)))
</code></pre>
<h3 id="list-iter"><a class="header" href="#list-iter">list-iter</a></h3>
<p><strong>Usage:</strong> (iter::list-iter l [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps a list.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-list-iter (list-iter '(1 2 3)))
    (test::assert-equal 1 (test-list-iter))
    (test::assert-equal 2 (test-list-iter))
    (test::assert-equal 3 (test-list-iter))
    (test::assert-equal :*iter-empty* (test-list-iter))
    (set! test-list-iter (list-iter '()))
    (test::assert-equal :*iter-empty* (test-list-iter)))
</code></pre>
<h3 id="list-iter-1"><a class="header" href="#list-iter-1">list-iter</a></h3>
<p><strong>Usage:</strong> (iter::list-iter l [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps a list.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-list-iter (list-iter '(1 2 3)))
    (test::assert-equal 1 (test-list-iter))
    (test::assert-equal 2 (test-list-iter))
    (test::assert-equal 3 (test-list-iter))
    (test::assert-equal :*iter-empty* (test-list-iter))
    (set! test-list-iter (list-iter '()))
    (test::assert-equal :*iter-empty* (test-list-iter)))
</code></pre>
<h3 id="map"><a class="header" href="#map">map</a></h3>
<p><strong>Usage:</strong> (iter::map i lambda [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that applies a lambda to each element of another iterator- is lazy.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-map-iter (map (list-iter '(1 2 3)) (fn (x) (* x 2))))
    (test::assert-equal 2 (test-map-iter))
    (test::assert-equal 4 (test-map-iter))
    (test::assert-equal 6 (test-map-iter))
    (test::assert-equal :*iter-empty* (test-map-iter)))
</code></pre>
<h3 id="map-1"><a class="header" href="#map-1">map</a></h3>
<p><strong>Usage:</strong> (iter::map i lambda [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that applies a lambda to each element of another iterator- is lazy.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-map-iter (map (list-iter '(1 2 3)) (fn (x) (* x 2))))
    (test::assert-equal 2 (test-map-iter))
    (test::assert-equal 4 (test-map-iter))
    (test::assert-equal 6 (test-map-iter))
    (test::assert-equal :*iter-empty* (test-map-iter)))
</code></pre>
<h3 id="mk-iter"><a class="header" href="#mk-iter">mk-iter</a></h3>
<p><strong>Usage:</strong> (iter::mk-iter body)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Helper to create an iterator.  Will make sure it has the correct
property set.</p>
<p>Example:</p>
<pre><code>
</code></pre>
<h3 id="mk-iter-1"><a class="header" href="#mk-iter-1">mk-iter</a></h3>
<p><strong>Usage:</strong> (iter::mk-iter body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Helper to create an iterator.  Will make sure it has the correct
property set.</p>
<p>Example:</p>
<pre><code>
</code></pre>
<h3 id="once-iter"><a class="header" href="#once-iter">once-iter</a></h3>
<p><strong>Usage:</strong> (iter::once-iter i [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps and returns a single object once.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (once-iter 3))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter))
    (set! test-iter (once-iter "iter"))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="once-iter-1"><a class="header" href="#once-iter-1">once-iter</a></h3>
<p><strong>Usage:</strong> (iter::once-iter i [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps and returns a single object once.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (once-iter 3))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter))
    (set! test-iter (once-iter "iter"))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="range"><a class="header" href="#range">range</a></h3>
<p><strong>Usage:</strong> (iter::range start end [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that generates numbers within a range.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (range 3 6))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 4 (test-iter))
    (test::assert-equal 5 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="range-1"><a class="header" href="#range-1">range</a></h3>
<p><strong>Usage:</strong> (iter::range start end [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that generates numbers within a range.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (range 3 6))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 4 (test-iter))
    (test::assert-equal 5 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="reduce"><a class="header" href="#reduce">reduce</a></h3>
<p><strong>Usage:</strong> (iter::reduce iter acc reducing-fn [SCRATCH] [SCRATCH] #<a href="src/generated-sections/SYM:922:2">SYM:922:2</a> #<a href="src/generated-sections/SYM:922:3">SYM:922:3</a> #<a href="src/generated-sections/SYM:922:3">SYM:922:3</a> [SCRATCH] val)</p>
<p><strong>Namespace:</strong> iter</p>
<p>reduce is used to amalgamate an iterator and an initial value,
according to the reducing function provided. The reducing-fcn should be a function
of two arguments. In the first iteration of reduce, the init-val will be used as
the first argument to the reducing-fcn and (iter) will be used as the
second argument. For all subsequent iterations, The result from the previous
application of the reducing-fcn will be used as the first argument to the
reducing-fcn and the second argument will be the next item in the collection
when the collection is empty reduce will return the amalgamated result.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (= 15 (iter::reduce (iter::vec-iter [1 2 3 4 5]) 0 +)))
(test::assert-true (= 16 (iter::reduce (iter::vec-iter [1 2 3 4 5]) 1 +)))
(test::assert-true (= "one hoopy frood" (iter::reduce (iter::vec-iter ["one " "hoopy " "frood"]) "" str)))
</code></pre>
<h3 id="reduce-1"><a class="header" href="#reduce-1">reduce</a></h3>
<p><strong>Usage:</strong> (iter::reduce iter acc reducing-fn [SCRATCH] [SCRATCH] #<a href="src/generated-sections/SYM:922:2">SYM:922:2</a> #<a href="src/generated-sections/SYM:922:3">SYM:922:3</a> #<a href="src/generated-sections/SYM:922:3">SYM:922:3</a> [SCRATCH] val)</p>
<p><strong>Namespace:</strong> root</p>
<p>reduce is used to amalgamate an iterator and an initial value,
according to the reducing function provided. The reducing-fcn should be a function
of two arguments. In the first iteration of reduce, the init-val will be used as
the first argument to the reducing-fcn and (iter) will be used as the
second argument. For all subsequent iterations, The result from the previous
application of the reducing-fcn will be used as the first argument to the
reducing-fcn and the second argument will be the next item in the collection
when the collection is empty reduce will return the amalgamated result.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (= 15 (iter::reduce (iter::vec-iter [1 2 3 4 5]) 0 +)))
(test::assert-true (= 16 (iter::reduce (iter::vec-iter [1 2 3 4 5]) 1 +)))
(test::assert-true (= "one hoopy frood" (iter::reduce (iter::vec-iter ["one " "hoopy " "frood"]) "" str)))
</code></pre>
<h3 id="repeat-iter"><a class="header" href="#repeat-iter">repeat-iter</a></h3>
<p><strong>Usage:</strong> (iter::repeat-iter i [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps and returns a single object on each call.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (repeat-iter 3))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (set! test-iter (repeat-iter "iter"))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter)))
</code></pre>
<h3 id="repeat-iter-1"><a class="header" href="#repeat-iter-1">repeat-iter</a></h3>
<p><strong>Usage:</strong> (iter::repeat-iter i [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps and returns a single object on each call.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (repeat-iter 3))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (set! test-iter (repeat-iter "iter"))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter)))
</code></pre>
<h3 id="string-iter"><a class="header" href="#string-iter">string-iter</a></h3>
<p><strong>Usage:</strong> (iter::string-iter s [SCRATCH] [SCRATCH] idx slen [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps a string.  Each element is the next character.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-string-iter (string-iter "123"))
    (test::assert-equal \1 (test-string-iter))
    (test::assert-equal \2 (test-string-iter))
    (test::assert-equal \3 (test-string-iter))
    (test::assert-equal :*iter-empty* (test-string-iter)))
</code></pre>
<h3 id="string-iter-1"><a class="header" href="#string-iter-1">string-iter</a></h3>
<p><strong>Usage:</strong> (iter::string-iter s [SCRATCH] [SCRATCH] idx slen [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps a string.  Each element is the next character.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-string-iter (string-iter "123"))
    (test::assert-equal \1 (test-string-iter))
    (test::assert-equal \2 (test-string-iter))
    (test::assert-equal \3 (test-string-iter))
    (test::assert-equal :*iter-empty* (test-string-iter)))
</code></pre>
<h3 id="vec-iter"><a class="header" href="#vec-iter">vec-iter</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter v [SCRATCH] [SCRATCH] idx vlen [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator that wraps a vector.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-vec-iter (vec-iter [1 2 3]))
    (test::assert-equal 1 (test-vec-iter))
    (test::assert-equal 2 (test-vec-iter))
    (test::assert-equal 3 (test-vec-iter))
    (test::assert-equal :*iter-empty* (test-vec-iter))
    (set! test-vec-iter (vec-iter (vec)))
    (test::assert-equal :*iter-empty* (test-vec-iter)))
</code></pre>
<h3 id="vec-iter-1"><a class="header" href="#vec-iter-1">vec-iter</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter v [SCRATCH] [SCRATCH] idx vlen [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator that wraps a vector.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-vec-iter (vec-iter [1 2 3]))
    (test::assert-equal 1 (test-vec-iter))
    (test::assert-equal 2 (test-vec-iter))
    (test::assert-equal 3 (test-vec-iter))
    (test::assert-equal :*iter-empty* (test-vec-iter))
    (set! test-vec-iter (vec-iter (vec)))
    (test::assert-equal :*iter-empty* (test-vec-iter)))
</code></pre>
<h3 id="vec-iter-pair"><a class="header" href="#vec-iter-pair">vec-iter-pair</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter-pair v [SCRATCH] [SCRATCH] fidx bidx [SCRATCH] [SCRATCH] iter iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Return a pair of iterators, one forward and one reverse for a vector.
The two iterators will not overlap (i.e. the forward and reverse will never
produce the same items).</p>
<p>Example:</p>
<pre><code>(import iter)
(let ([fwd-iter, rev-iter] (vec-iter-pair [1 2 3]))
    (test::assert-equal 1 (fwd-iter))
    (test::assert-equal 3 (rev-iter))
    (test::assert-equal 2 (fwd-iter))
    (test::assert-equal :*iter-empty* (rev-iter))
    (test::assert-equal :*iter-empty* (fwd-iter)))
(let ([fwd-iter, rev-iter] (vec-iter-pair (vec)))
    (test::assert-equal :*iter-empty* (fwd-iter))
    (test::assert-equal :*iter-empty* (rev-iter)))
</code></pre>
<h3 id="vec-iter-pair-1"><a class="header" href="#vec-iter-pair-1">vec-iter-pair</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter-pair v [SCRATCH] [SCRATCH] fidx bidx [SCRATCH] [SCRATCH] iter iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a pair of iterators, one forward and one reverse for a vector.
The two iterators will not overlap (i.e. the forward and reverse will never
produce the same items).</p>
<p>Example:</p>
<pre><code>(import iter)
(let ([fwd-iter, rev-iter] (vec-iter-pair [1 2 3]))
    (test::assert-equal 1 (fwd-iter))
    (test::assert-equal 3 (rev-iter))
    (test::assert-equal 2 (fwd-iter))
    (test::assert-equal :*iter-empty* (rev-iter))
    (test::assert-equal :*iter-empty* (fwd-iter)))
(let ([fwd-iter, rev-iter] (vec-iter-pair (vec)))
    (test::assert-equal :*iter-empty* (fwd-iter))
    (test::assert-equal :*iter-empty* (rev-iter)))
</code></pre>
<h3 id="vec-iter-rev"><a class="header" href="#vec-iter-rev">vec-iter-rev</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter-rev v [SCRATCH] [SCRATCH] idx [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> iter</p>
<p>Iterator produces a vector in reverse.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-vec-iter (vec-iter-rev [1 2 3]))
    (test::assert-equal 3 (test-vec-iter))
    (test::assert-equal 2 (test-vec-iter))
    (test::assert-equal 1 (test-vec-iter))
    (test::assert-equal :*iter-empty* (test-vec-iter))
    (set! test-vec-iter (vec-iter-rev (vec)))
    (test::assert-equal :*iter-empty* (test-vec-iter)))
</code></pre>
<h3 id="vec-iter-rev-1"><a class="header" href="#vec-iter-rev-1">vec-iter-rev</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter-rev v [SCRATCH] [SCRATCH] idx [SCRATCH] [SCRATCH] iter)</p>
<p><strong>Namespace:</strong> root</p>
<p>Iterator produces a vector in reverse.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-vec-iter (vec-iter-rev [1 2 3]))
    (test::assert-equal 3 (test-vec-iter))
    (test::assert-equal 2 (test-vec-iter))
    (test::assert-equal 1 (test-vec-iter))
    (test::assert-equal :*iter-empty* (test-vec-iter))
    (set! test-vec-iter (vec-iter-rev (vec)))
    (test::assert-equal :*iter-empty* (test-vec-iter)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="math"><a class="header" href="#math">math</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/math.html#">%</a>, <a href="src/generated-sections/math.html#">*</a>, <a href="src/generated-sections/math.html#euler"><em>euler</em></a>, <a href="src/generated-sections/math.html#pi"><em>pi</em></a>, <a href="src/generated-sections/math.html#">+</a>, <a href="src/generated-sections/math.html#-">-</a>, <a href="src/generated-sections/math.html#">/</a>, <a href="src/generated-sections/math.html#pow">2pow</a>, <a href="src/generated-sections/math.html#abs">abs</a>, <a href="src/generated-sections/math.html#arccos">arccos</a>, <a href="src/generated-sections/math.html#arcsin">arcsin</a>, <a href="src/generated-sections/math.html#arctan">arctan</a>, <a href="src/generated-sections/math.html#ceil">ceil</a>, <a href="src/generated-sections/math.html#cos">cos</a>, <a href="src/generated-sections/math.html#exp">exp</a>, <a href="src/generated-sections/math.html#floor">floor</a>, <a href="src/generated-sections/math.html#fract">fract</a>, <a href="src/generated-sections/math.html#log">log</a>, <a href="src/generated-sections/math.html#log">log2</a>, <a href="src/generated-sections/math.html#max">max</a>, <a href="src/generated-sections/math.html#min">min</a>, <a href="src/generated-sections/math.html#pow">pow</a>, <a href="src/generated-sections/math.html#rem">rem</a>, <a href="src/generated-sections/math.html#rem-euclid">rem-euclid</a>, <a href="src/generated-sections/math.html#round">round</a>, <a href="src/generated-sections/math.html#sin">sin</a>, <a href="src/generated-sections/math.html#sqrt">sqrt</a>, <a href="src/generated-sections/math.html#tan">tan</a></p>
<h3 id="-6"><a class="header" href="#-6">%</a></h3>
<p><strong>Usage:</strong> (% int int)</p>
<p><strong>Namespace:</strong> root</p>
<p>Remainder from dividing (arg 1) by (arg 2).
Note: Remainder and Modulo are two similar mathematical operations,
called <code>rem</code> and <code>rem-euclid</code>.
This function uses <code>rem</code> which is the same as the <code>%</code> operator in C.
With <code>rem</code>, the sign of the result is the same as the dividend (arg 1).
With <code>rem-euclid</code>, the sign of the result is always positive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (% 50 10))
(test::assert-equal 5 (% 55 10))
(test::assert-equal 1 (% 1 2))
(test::assert-equal -1 (% -10 3))
(test::assert-equal  1 (% 10 -3))
(test::assert-equal -1 (% -10 -3))

(test::assert-error (%))
(test::assert-error (% 1))
(test::assert-error (% 1 2 3))
(test::assert-error (% 1 2.0))
</code></pre>
<h3 id="-7"><a class="header" href="#-7">*</a></h3>
<p><strong>Usage:</strong> (* number*)</p>
<p><strong>Namespace:</strong> root</p>
<p>Multiply a sequence of numbers.  (*) will return 1.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (*))
(test::assert-equal 5 (* 5))
(test::assert-equal 5 (* 1 5))
(test::assert-equal 5.0 (* 1.0 5))
(test::assert-equal 7.5 (* 1.5 5))
(test::assert-equal 7.5 (* 1.5 5.0))
(test::assert-equal 15 (* 3 5))
(test::assert-equal 8 (* 1 2 4))
(test::assert-equal 16 (* 2 2 4))
(test::assert-equal 16.0 (* 2 2.0 4))
(test::assert-equal 16.0 (* 2.0 2.0 4.0))
(test::assert-equal 54.9999999999999 (* 100 0.55))
(test::assert-error (* 1 2 4 "5"))
</code></pre>
<h3 id="euler"><a class="header" href="#euler"><em>euler</em></a></h3>
<p><strong>Usage:</strong> (prn <em>euler</em>)</p>
<p><strong>Namespace:</strong> root</p>
<p>Float representing euler’s number.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 2.718281828459045 *euler*)
</code></pre>
<h3 id="pi"><a class="header" href="#pi"><em>pi</em></a></h3>
<p><strong>Usage:</strong> (prn <em>pi</em>)</p>
<p><strong>Namespace:</strong> root</p>
<p>Float representing pi.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 3.141592653589793 *pi*)
</code></pre>
<h3 id="-8"><a class="header" href="#-8">+</a></h3>
<p><strong>Usage:</strong> (+ number*)</p>
<p><strong>Namespace:</strong> root</p>
<p>Add a sequence of numbers.  (+) will return 0.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (+))
(test::assert-equal 5 (+ 5))
(test::assert-equal 10 (+ 5 5))
(test::assert-equal 6 (+ 1 5))
(test::assert-equal 6.5 (+ 1 5.5))
(test::assert-equal 7 (+ 1 2 4))
(test::assert-error (+ 1 2 4 "5"))
</code></pre>
<h3 id="-"><a class="header" href="#-">-</a></h3>
<p><strong>Usage:</strong> (- number+)</p>
<p><strong>Namespace:</strong> root</p>
<p>Subtract a sequence of numbers.  Requires at least one number (negate if only one number).</p>
<p>Example:</p>
<pre><code>(test::assert-error (- 5 "2"))
(test::assert-equal -5 (- 5))
(test::assert-equal -5.0 (- 5.0))
(test::assert-equal -4 (- 1 5))
(test::assert-equal -4.5 (- 1 5.5))
(test::assert-equal 4 (- 10 2 4))
(test::assert-equal 4.5 (- 10 2 3.5))
</code></pre>
<h3 id="-9"><a class="header" href="#-9">/</a></h3>
<p><strong>Usage:</strong> (/ number+)</p>
<p><strong>Namespace:</strong> root</p>
<p>Divide a sequence of numbers.  Requires at least two numbers.</p>
<p>No Examples</p>
<h3 id="2pow"><a class="header" href="#2pow">2pow</a></h3>
<p><strong>Usage:</strong> (2pow base)</p>
<p><strong>Namespace:</strong> root</p>
<p>Raise 2 to power of argument.</p>
<p>Example:</p>
<pre><code>(test::assert-compare == 1024 (2pow 10))
(test::assert-compare == (2pow (* 10 2)) (pow (2pow 10) 2))
</code></pre>
<h3 id="abs"><a class="header" href="#abs">abs</a></h3>
<p><strong>Usage:</strong> (abs arg)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns absolute value of arg.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 2 (abs 2))
(test::assert-equal 144 (abs -144))
(test::assert-equal 4.53 (abs -4.53))
(test::assert-equal 36028797018963967 (abs -36028797018963967))
</code></pre>
<h3 id="arccos"><a class="header" href="#arccos">arccos</a></h3>
<p><strong>Usage:</strong> (arccos value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate the arccosine (inverse cosine) of a value. Returns angle in radians.
Value must be between -1 and 1.</p>
<p>Example:</p>
<pre><code>(test::assert-true (&lt; 1.570 (arccos 0) 1.571))
(test::assert-equal 0.0 (arccos 1))
(test::assert-true (&lt; 3.141 (arccos -1) 3.142))
(test::assert-error (arccos))
(test::assert-error (arccos 2))
(test::assert-error (arccos -2))
</code></pre>
<h3 id="arcsin"><a class="header" href="#arcsin">arcsin</a></h3>
<p><strong>Usage:</strong> (arcsin value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate the arcsine (inverse sine) of a value. Returns angle in radians.
Value must be between -1 and 1.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (arcsin 0))
(test::assert-true (&lt; 1.570 (arcsin 1) 1.571))
(test::assert-true (&lt; -1.571 (arcsin -1) -1.570))
(test::assert-error (arcsin))
(test::assert-error (arcsin 2))
(test::assert-error (arcsin -2))
</code></pre>
<h3 id="arctan"><a class="header" href="#arctan">arctan</a></h3>
<p><strong>Usage:</strong> (arctan value)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate the arctangent (inverse tangent) of a value. Returns angle in radians.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (arctan 0))
(test::assert-true (&lt; 0.785 (arctan 1) 0.786))
(test::assert-true (&lt; -0.786 (arctan -1) -0.785))
(test::assert-error (arctan))
(test::assert-error (arctan 1 2))
</code></pre>
<h3 id="ceil"><a class="header" href="#ceil">ceil</a></h3>
<p><strong>Usage:</strong> (ceil num)</p>
<p><strong>Namespace:</strong> root</p>
<p>Round a number up to the nearest integer.</p>
<p>Example:</p>
<pre><code>(test::assert-compare == 3 (ceil 2.1))
(test::assert-compare == 3 (ceil 2.9))
(test::assert-compare == -2 (ceil -2.1))
(test::assert-compare == -2 (ceil -2.9))
(test::assert-compare == 5 (ceil 5))
(test::assert-error (ceil))
(test::assert-error (ceil 1 2))
</code></pre>
<h3 id="cos"><a class="header" href="#cos">cos</a></h3>
<p><strong>Usage:</strong> (cos radians)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate the cosine of an angle in radians.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1.0 (cos 0))
(test::assert-true (&lt; 0.540 (cos 1) 0.541))
(test::assert-true (&lt; -1.001 (cos 3.14159) -0.999))
(test::assert-error (cos))
(test::assert-error (cos 1 2))
</code></pre>
<h3 id="exp"><a class="header" href="#exp">exp</a></h3>
<p><strong>Usage:</strong> (exp power)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate e raised to the given power.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1.0 (exp 0))
(test::assert-true (&lt; 2.718 (exp 1) 2.719))
(test::assert-true (&lt; 7.389 (exp 2) 7.390))
(test::assert-error (exp))
(test::assert-error (exp 1 2))
</code></pre>
<h3 id="floor"><a class="header" href="#floor">floor</a></h3>
<p><strong>Usage:</strong> (floor num)</p>
<p><strong>Namespace:</strong> root</p>
<p>Round a number down to the nearest integer.</p>
<p>Example:</p>
<pre><code>(test::assert-compare == 2 (floor 2.1))
(test::assert-compare == 2 (floor 2.9))
(test::assert-compare == -3 (floor -2.1))
(test::assert-compare == -3 (floor -2.9))
(test::assert-compare == 5 (floor 5))
(test::assert-error (floor))
(test::assert-error (floor 1 2))
</code></pre>
<h3 id="fract"><a class="header" href="#fract">fract</a></h3>
<p><strong>Usage:</strong> (fract num)</p>
<p><strong>Namespace:</strong> root</p>
<p>Get the fractional part of a number.</p>
<p>Example:</p>
<pre><code>(test::assert-true (&lt; 0.099 (fract 2.1) 0.101))
(test::assert-true (&lt; 0.899 (fract 2.9) 0.901))
(test::assert-compare == 0 (fract 5))
(test::assert-true (&lt; -0.901 (fract -2.9) -0.899))
(test::assert-true (&lt; -0.101 (fract -2.1) -0.099))
(test::assert-error (fract))
(test::assert-error (fract 1 2))
</code></pre>
<h3 id="log"><a class="header" href="#log">log</a></h3>
<p><strong>Usage:</strong> (log num [base])</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate logarithm of num. If base is not provided, uses natural logarithm (base e).</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (log 1))
(test::assert-true (&lt; 2.302 (log 10) 2.303))
(test::assert-equal 3.0 (log 8 2))
(test::assert-equal 2.0 (log 100 10))
(test::assert-error (log))
(test::assert-error (log -1))
(test::assert-error (log 10 -2))
</code></pre>
<h3 id="log2"><a class="header" href="#log2">log2</a></h3>
<p><strong>Usage:</strong> (log2 num)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate base-2 logarithm of num.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (log2 1))
(test::assert-equal 3.0 (log2 8))
(test::assert-equal 10.0 (log2 1024))
(test::assert-error (log2))
(test::assert-error (log2 -1))
(test::assert-error (log2 0))
</code></pre>
<h3 id="max"><a class="header" href="#max">max</a></h3>
<p><strong>Usage:</strong> (max number+)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return the maximum value from one or more numbers.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 3 (max 1 2 3))
(test::assert-equal 10 (max 10 -5 3))
(test::assert-equal 42 (max 42))
(test::assert-equal 3.0 (max 3.0 1.5 2.0))
(test::assert-equal 3.0 (max 1 2.0 3))
(test::assert-error (max))
(test::assert-error (max 1 "two"))
</code></pre>
<h3 id="min"><a class="header" href="#min">min</a></h3>
<p><strong>Usage:</strong> (min number+)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return the minimum value from one or more numbers.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (min 1 2 3))
(test::assert-equal -5 (min 10 -5 3))
(test::assert-equal 42 (min 42))
(test::assert-equal 1.5 (min 3.0 1.5 2.0))
(test::assert-equal 1 (min 1 2.0 3))
(test::assert-error (min))
(test::assert-error (min 1 "two"))
</code></pre>
<h3 id="pow"><a class="header" href="#pow">pow</a></h3>
<p><strong>Usage:</strong> (pow base power)</p>
<p><strong>Namespace:</strong> root</p>
<p>Raise first argument to power of second argument.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 16.0 (pow 4 2))
(test::assert-equal 1024.0 (pow 2 10))
(test::assert-equal 1.0 (pow 85 0))
(test::assert-equal 0.25 (pow 2 -2))
(test::assert-error (pow))
(test::assert-error (pow 2))
(test::assert-error (pow 2 3 4))
</code></pre>
<h3 id="rem"><a class="header" href="#rem">rem</a></h3>
<p><strong>Usage:</strong> (rem int int)</p>
<p><strong>Namespace:</strong> root</p>
<p>Remainder from dividing (arg 1) by (arg 2).
Note: Remainder and Modulo are two similar mathematical operations,
called <code>rem</code> and <code>rem-euclid</code> in Rust.
This function uses <code>rem</code> which is the same as the <code>%</code> operator in C.
With <code>rem</code>, the sign of the result is the same as the dividend (arg 1).
With <code>rem-euclid</code>, the sign of the result is always positive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (rem 50 10))
(test::assert-equal 5 (rem 55 10))
(test::assert-equal 1 (rem 1 2))
(test::assert-equal -1 (rem -10 3))
(test::assert-equal  1 (rem 10 -3))
(test::assert-equal -1 (rem -10 -3))

(test::assert-error (rem))
(test::assert-error (rem 1))
(test::assert-error (rem 1 2 3))
(test::assert-error (rem 1 2.0))
</code></pre>
<h3 id="rem-euclid"><a class="header" href="#rem-euclid">rem-euclid</a></h3>
<p><strong>Usage:</strong> (rem-euclid int int)</p>
<p><strong>Namespace:</strong> root</p>
<p>Least Non-negative number that can be added to a multiple of the divisor (arg 2) to get the dividend (arg 1).
The result should always be 0 &lt;= result &lt; divisor (arg 2).
Note: Remainder and Modulo are two similar mathematical operations,
called <code>rem</code> and <code>rem-euclid</code> in Rust.
With <code>rem</code>, the sign of the result is the same as the dividend (arg 1).
With <code>rem-euclid</code>, the sign of the result is always positive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (rem-euclid 50 10))
(test::assert-equal 5 (rem-euclid 55 10))
(test::assert-equal 1 (rem-euclid 1 2))
(test::assert-equal 2 (rem-euclid -10 3))
(test::assert-equal 1 (rem-euclid 10 -3))
(test::assert-equal 2 (rem-euclid -10 -3))

(test::assert-error (rem-euclid))
(test::assert-error (rem-euclid 1))
(test::assert-error (rem-euclid 1 2 3))
(test::assert-error (rem-euclid 1 2.0))
</code></pre>
<h3 id="round"><a class="header" href="#round">round</a></h3>
<p><strong>Usage:</strong> (round num)</p>
<p><strong>Namespace:</strong> root</p>
<p>Round a number to the nearest integer, with ties rounding away from zero.</p>
<p>Example:</p>
<pre><code>(test::assert-compare == 2 (round 2.1))
(test::assert-compare == 3 (round 2.9))
(test::assert-compare == 3 (round 2.5))
(test::assert-compare == -2 (round -2.1))
(test::assert-compare == -3 (round -2.9))
(test::assert-compare == -3 (round -2.5))
(test::assert-compare == 5 (round 5))
(test::assert-error (round))
(test::assert-error (round 1 2))
</code></pre>
<h3 id="sin"><a class="header" href="#sin">sin</a></h3>
<p><strong>Usage:</strong> (sin radians)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate the sine of an angle in radians.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (sin 0))
(test::assert-true (&lt; 0.841 (sin 1) 0.842))
(test::assert-true (&lt; -0.001 (sin 3.14159) 0.001))
(test::assert-error (sin))
(test::assert-error (sin 1 2))
</code></pre>
<h3 id="sqrt"><a class="header" href="#sqrt">sqrt</a></h3>
<p><strong>Usage:</strong> (sqrt num)</p>
<p><strong>Namespace:</strong> root</p>
<p>Take square root of argument.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 2.0 (sqrt 4))
(test::assert-equal 12.0 (sqrt 144))
(test::assert-true (&lt; 2.049 (sqrt 4.2) 2.050))
(test::assert-error (sqrt))
(test::assert-error (sqrt 4 2))
(test::assert-error (sqrt -4))
</code></pre>
<h3 id="tan"><a class="header" href="#tan">tan</a></h3>
<p><strong>Usage:</strong> (tan radians)</p>
<p><strong>Namespace:</strong> root</p>
<p>Calculate the tangent of an angle in radians.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (tan 0))
(test::assert-true (&lt; 1.557 (tan 1) 1.558))
(test::assert-true (&lt; -0.001 (tan 3.14159) 0.001))
(test::assert-error (tan))
(test::assert-error (tan 1 2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="namespace"><a class="header" href="#namespace">namespace</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/namespace.html#get-in-namespace">get-in-namespace</a>, <a href="src/generated-sections/namespace.html#get-namespaces">get-namespaces</a>, <a href="src/generated-sections/namespace.html#import">import</a>, <a href="src/generated-sections/namespace.html#ns">ns</a>, <a href="src/generated-sections/namespace.html#with-ns">with-ns</a></p>
<h3 id="get-in-namespace"><a class="header" href="#get-in-namespace">get-in-namespace</a></h3>
<p><strong>Usage:</strong> (get-in-namespace 'SYMBOL)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a vector containing all the globals currently defined namespace SYMBOL.</p>
<p>No Examples</p>
<h3 id="get-namespaces"><a class="header" href="#get-namespaces">get-namespaces</a></h3>
<p><strong>Usage:</strong> (get-namespaces)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a vector containing all the namespaces currently defined globally.</p>
<p>No Examples</p>
<h3 id="import"><a class="header" href="#import">import</a></h3>
<p><strong>Usage:</strong> (import namespace [:as symbol])</p>
<p><strong>Namespace:</strong> root</p>
<p>Will import a namespace.  Without an :as then all symbols in the namespace will become available in the current
namespace as if local.  With [:as symbol] then all namespace symbols become available with symbol:: prepended.</p>
<p>Example:</p>
<pre><code>(ns testing)
(def x #t)
(test::assert-true x)
(ns ::)
(test::assert-true testing::x)
(import testing)
(test::assert-true x)
(import testing :as t)
(test::assert-true t::x)
</code></pre>
<h3 id="ns"><a class="header" href="#ns">ns</a></h3>
<p><strong>Usage:</strong> (ns SYMBOL)</p>
<p><strong>Namespace:</strong> root</p>
<p>Changes to namespace.  This is "open-ended" change and is intended for use with
the REPL prefer with-ns for scripts.
The symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
This will cause all globals defined to have namespace:: prepended.
This will also clear any existing imports.</p>
<p>Example:</p>
<pre><code>(ns testing)
(def x #t)
(test::assert-true x)
(ns ::)
(test::assert-true testing::x)
</code></pre>
<h3 id="with-ns"><a class="header" href="#with-ns">with-ns</a></h3>
<p><strong>Usage:</strong> (with-ns SYMBOL sexp+)</p>
<p><strong>Namespace:</strong> root</p>
<p>Create a namespace and compile sexp+ within it.  Restore the previous namespace when scope ends.
THe symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
This will cause all globals defined to have namespace:: prepended.
This will also clear any existing imports.</p>
<p>Example:</p>
<pre><code>(with-ns test-with-ns
    (def ttf (fn () '(1 2 3)))
    (test::assert-equal '(1 2 3) (ttf))
    (test::assert-equal '(1 2 3) (test-out::ttf)))
(test::assert-equal '(1 2 3) (test-out::ttf))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pair"><a class="header" href="#pair">pair</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/pair.html#car">car</a>, <a href="src/generated-sections/pair.html#cdr">cdr</a>, <a href="src/generated-sections/pair.html#cons">cons</a>, <a href="src/generated-sections/pair.html#list">list</a>, <a href="src/generated-sections/pair.html#list-append">list-append</a>, <a href="src/generated-sections/pair.html#xar">xar!</a>, <a href="src/generated-sections/pair.html#xdr">xdr!</a></p>
<h3 id="car"><a class="header" href="#car">car</a></h3>
<p><strong>Usage:</strong> (car pair)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return the car (first item) from a pair.  If used on a proper list this will be the first element.</p>
<p>Example:</p>
<pre><code>(def tst-pairs-two (list 'x 'y 'z))
(test::assert-equal 'x (car tst-pairs-two))
(test::assert-equal 10 (car '(10)))
(test::assert-equal 9 (car '(9 11 13)))
</code></pre>
<h3 id="cdr"><a class="header" href="#cdr">cdr</a></h3>
<p><strong>Usage:</strong> (cdr pair)</p>
<p><strong>Namespace:</strong> root</p>
<p>Return the cdr (second item) from a pair.  If used on a proper list this will be the list minus the first element.</p>
<p>Example:</p>
<pre><code>(def tst-pairs-three (list 'x 'y 'z))
(test::assert-equal '(y z) (cdr tst-pairs-three))
(test::assert-equal nil (cdr '(10)))
(test::assert-equal '(13) (cdr '(9 13)))
(test::assert-equal '(11 13) (cdr '(9 11 13)))
</code></pre>
<h3 id="cons"><a class="header" href="#cons">cons</a></h3>
<p><strong>Usage:</strong> (cons item collection)</p>
<p><strong>Namespace:</strong> root</p>
<p>Prepends item to collection, forms a pair.</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(1 2 3) (cons 1 (list 2 3)))
(test::assert-equal (cons 1 (cons 2 (cons 3 '()))) '(1 2 3))
(test::assert-equal (cons 1 2) (1 . 2))
(test::assert-equal (cons 1 nil) (1))
(test::assert-equal (cons nil 2) (nil . 3))
(test::assert-equal (cons nil nil) (nil))
(test::assert-equal (cons 1 (cons 2 (cons 3 (cons 4 nil)))) '(1 2 3 4))
(test::assert-equal (cons 1 2) (1 . 2))
(test::assert-equal (cons 1 '(2 3 4)) (1 2 3 4))
</code></pre>
<h3 id="list"><a class="header" href="#list">list</a></h3>
<p><strong>Usage:</strong> (list item0 item1 .. itemN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Create a proper list from pairs with items 0 - N.</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(1 2 3) (list 1 2 3))
(test::assert-equal '() (list))
</code></pre>
<h3 id="list-append"><a class="header" href="#list-append">list-append</a></h3>
<p><strong>Usage:</strong> (list-append list item)</p>
<p><strong>Namespace:</strong> root</p>
<p>If last parameter is a list it will be appened to the first list, otherwise
adds item as pair.</p>
<p>Example:</p>
<pre><code>(test::assert-equal (list-append (list 1 2 3) (list 1)) (list 1 2 3 1))
;; demonstrates that appending two lists is different than appending a non-list value
(test::assert-not-equal (list-append (list 1 2 3) (list 1)) (list-append (list 1 2 3) 1))
(test::assert-equal (list 1 2 3 4 5 6 7 8 9) (list-append (list 1 2 3) (list 4 5 6) (list 7 8 9)))
(test::assert-equal (list-append '(:a :b :c) '(:d :e :f) '() '(:g))  '(:a :b :c :d :e :f :g))
;; TODO PC unrepresentable?
(test::assert-equal (list-append '(1 2 3) 4)  '(1 2 3 . 4))
(def lst '(:a :b :c))
(test::assert-equal (list-append lst (list :d)) (list :a :b :c :d))
(test::assert-equal lst '(:a :b :c))
(test::assert-equal (list-append) nil)
(test::assert-equal (list-append :a) :a)
</code></pre>
<h3 id="xar"><a class="header" href="#xar">xar!</a></h3>
<p><strong>Usage:</strong> (xar! pair expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>Destructive form that replaces the car (first item) in a pair with a new expression.</p>
<p>If used on a proper list will replace the first item.  Can be used on nil to
create a pair (expression . nil).</p>
<p>Example:</p>
<pre><code>(def tst-pairs-three (list 'x 'y 'z))
(test::assert-equal '(x y z) tst-pairs-three)
(test::assert-equal '(s y z) (xar! tst-pairs-three 's))
(test::assert-equal '(s y z) tst-pairs-three)
(def tst-pairs-four (list 't))
(test::assert-equal '(y) (xar! tst-pairs-four 'y))
(test::assert-equal '(y) tst-pairs-four)
</code></pre>
<h3 id="xdr"><a class="header" href="#xdr">xdr!</a></h3>
<p><strong>Usage:</strong> (xdr! pair expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>Destructive form that replaces the cdr (second item) in a pair with a new expression.</p>
<p>If used on a proper list will replace everything after the first item.
Can be used on nil to create a pair (nil . expression).</p>
<p>Example:</p>
<pre><code>(def tst-pairs-five (list 'a 'b 'c))
(test::assert-equal '(a b c) tst-pairs-five)
(test::assert-equal '(a y z) (xdr! tst-pairs-five '(y z)))
(test::assert-equal '(a y z) tst-pairs-five)
(def tst-pairs-six (list 'v))
(test::assert-equal (list 'v) tst-pairs-six)
(test::assert-equal '(v . v) (xdr! tst-pairs-six 'v))
(test::assert-equal '(v . v) tst-pairs-six)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="random"><a class="header" href="#random">random</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/random.html#probool">probool</a>, <a href="src/generated-sections/random.html#random">random</a>, <a href="src/generated-sections/random.html#random-seq">random-seq</a>, <a href="src/generated-sections/random.html#random-str">random-str</a></p>
<h3 id="probool"><a class="header" href="#probool">probool</a></h3>
<p><strong>Usage:</strong> (probool), (probool numerator denominator)</p>
<p><strong>Namespace:</strong> root</p>
<p>PRObability of a BOOLean.</p>
<p>If no arguments are given, returns #t 1/2 of the time, otherwise takes two
integers, numerator and denominator, and returns #t numerator/denominator of the
time. Throws an error if denominator is 0. If (&gt;= (/ numerator denominator) 1)
probool always returns true. If numerator is 0 probool always returns false.</p>
<p>Example:</p>
<pre><code>(def val0 (probool))
(test::assert-true (or (= #t val0) (= nil val0)))
(def val1 (probool 17 42))
(test::assert-true (or (= #t val1) (= nil val1)))
(test::assert-true (probool 1 1))
(test::assert-false (probool 0 42))
(test::assert-error-msg (probool 0 0) :rand "Denominator can not be zero")
(test::assert-error-msg (probool 0 0 0) :rand "Expected zero or two positive ints")
</code></pre>
<h3 id="random-1"><a class="header" href="#random-1">random</a></h3>
<p><strong>Usage:</strong> (random), (random limit)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns non-negative number less than limit and of the same type as limit.</p>
<p>Example:</p>
<pre><code>(def rand-int (random 100))
(test::assert-true (and (&gt;= rand-int 0) (&lt; rand-int 100)))
(def rand-float (random 1.0))
(test::assert-true (and (&gt;= rand-float 0.0) (&lt; rand-float 1.0)))
(test::assert-error-msg (random -1) :rand "Expected positive number")
(test::assert-error-msg (random 1 2) :rand "Expected positive number, float or int")
</code></pre>
<h3 id="random-seq"><a class="header" href="#random-seq">random-seq</a></h3>
<p><strong>Usage:</strong> (random-seq limit count [seed])</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns Vector of size <code>count</code> of non-negative integer(s) less than limit. Optional seed can be used
for the random number generator which allows (random-seq) to behave as a pure function, each unique
triple of (<code>limit</code>, <code>count</code>, <code>seed</code>) is equivalent to one deterministic sequence. Without seed values in
returned Vector are randomly selected on each invocation.</p>
<p>Like (random) but with two additional parameters and is capable of returning a Vector of random values instead of just one.</p>
<p>Example:</p>
<pre><code>(test::assert-equal (vec 0 4) (random-seq 4 2 "42"))
</code></pre>
<h3 id="random-str"><a class="header" href="#random-str">random-str</a></h3>
<p><strong>Usage:</strong> (random-str str-length [char-set])</p>
<p><strong>Namespace:</strong> root</p>
<p>Takes a positive integer, str-length, and one of :hex, :ascii, :alnum, or
a string. Returns random string of provided str-length composed of second argument,
:hex results in random hex string, :ascii results in random string of all printable
ascii characters, :alnum results in random string of all alphanumeric characters,
and providing a string results in a random string composed by sampling input.</p>
<p>Example:</p>
<pre><code>(test::assert-error-msg (random-str) :rand "Expected two arguments, length and charset")
(test::assert-error-msg (random-str 10) :rand "Expected two arguments, length and charset")
(test::assert-error-msg (random-str -1 :hex) :rand "Expected positive length")
(test::assert-error-msg (random-str 10 1) :rand "Second argument must be keyword or string")
(test::assert-error-msg (random-str 1 :hexy) :rand "Unknown symbol :hexy")
(test::assert-equal 10 (len (random-str 10 :hex)))
(test::assert-true (str-contains (random-str 42 "⚙") "⚙"))
(test::assert-equal 19 (len (random-str 19 :ascii)))
(test::assert-equal 91 (len (random-str 91 :alnum)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="scripting"><a class="header" href="#scripting">scripting</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/scripting.html#run-script">run-script</a></p>
<h3 id="run-script-1"><a class="header" href="#run-script-1">run-script</a></h3>
<p><strong>Usage:</strong> (run-script path) -&gt; [last form value]</p>
<p><strong>Namespace:</strong> root</p>
<p>Read and eval a file (from path- a string).</p>
<p>Example:</p>
<pre><code>(def test-load::test-fn)
(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create))
        (defer (fclose tst-file))
        (fprn tst-file "(with-ns test-load")
        (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
    (run-script tmp)
    (test::assert-equal '(1 2 3) (test-load::test-fn))))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sequence"><a class="header" href="#sequence">sequence</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/sequence.html#butlast">butlast</a>, <a href="src/generated-sections/sequence.html#first">first</a>, <a href="src/generated-sections/sequence.html#last">last</a>, <a href="src/generated-sections/sequence.html#rest">rest</a>, <a href="src/generated-sections/sequence.html#seq-for">seq-for</a></p>
<h3 id="butlast"><a class="header" href="#butlast">butlast</a></h3>
<p><strong>Usage:</strong> (butlast obj [SCRATCH] [SCRATCH] new-link)</p>
<p><strong>Namespace:</strong> root</p>
<p>Produces the provided list minus the last element.  Nil if the list is empty or one element.</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(1 2) (butlast '(1 2 3)))
(test::assert-equal [1 2] (butlast [1 2 3]))
(test::assert-equal nil (butlast '(1)))
(test::assert-equal [] (butlast [1]))
(test::assert-equal nil (butlast '()))
(test::assert-equal nil (butlast nil))
(test::assert-equal nil (butlast []))
</code></pre>
<h3 id="first"><a class="header" href="#first">first</a></h3>
<p><strong>Usage:</strong> (first obj)</p>
<p><strong>Namespace:</strong> root</p>
<p>Produces the first element of the provided list or vector.  Nil if the
list/vector is nil/empty.  Note this is like car that works for lists and
vectors.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (first '(1 2 3)))
(test::assert-equal 1 (first [1 2 3]))
(test::assert-equal nil (first '()))
(test::assert-equal nil (first nil))
(test::assert-equal [] (first []))
</code></pre>
<h3 id="last"><a class="header" href="#last">last</a></h3>
<p><strong>Usage:</strong> (last obj [SCRATCH] [SCRATCH] last-list [SCRATCH] [SCRATCH] i)</p>
<p><strong>Namespace:</strong> root</p>
<p>Produces the last element in a list or vector.  Nil if the list/vector is empty.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 3 (last '(1 2 3)))
(test::assert-equal 3 (last [1 2 3]))
(test::assert-equal nil (last '()))
(test::assert-equal nil (last nil))
(test::assert-equal nil (last []))
</code></pre>
<h3 id="rest"><a class="header" href="#rest">rest</a></h3>
<p><strong>Usage:</strong> (rest obj)</p>
<p><strong>Namespace:</strong> root</p>
<p>Produces the provided list or vector minus the first element.  Nil if the
list/vector is nil/empty or one element.  Note this is like cdr that works for
lists and vectors.  This calls vec-slice to create a new vector when called with
a vector (i.e. is much more efficient with lists).</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(2 3) (rest '(1 2 3)))
(test::assert-equal [2 3] (rest [1 2 3]))
(test::assert-equal nil (rest '(1)))
(test::assert-equal [] (rest [1]))
(test::assert-equal nil (rest '()))
(test::assert-equal nil (rest nil))
(test::assert-equal [] (rest []))
</code></pre>
<h3 id="seq-for"><a class="header" href="#seq-for">seq-for</a></h3>
<p><strong>Usage:</strong> (seq-for bind in items body [SCRATCH] [SCRATCH] lst)</p>
<p><strong>Namespace:</strong> root</p>
<p>Loops over each element in a sequence.  Simple version that works with lists and
vectors, use iterator::for in general.</p>
<p>Example:</p>
<pre><code>(def i 0)
(seq-for x in '(1 2 3 4 5 6) (set! i (+ 1 i)))
(test::assert-equal 6 i)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shell"><a class="header" href="#shell">shell</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/shell.html#sh">$sh</a>, <a href="src/generated-sections/shell.html#args"><em>args</em></a>, <a href="src/generated-sections/shell.html#shell-exe"><em>shell-exe</em></a>, <a href="src/generated-sections/shell.html#bg-color-rgb">bg-color-rgb</a>, <a href="src/generated-sections/shell.html#fg-color-rgb">fg-color-rgb</a>, <a href="src/generated-sections/shell.html#sh">sh</a>, <a href="src/generated-sections/shell.html#syntax-off">syntax-off</a>, <a href="src/generated-sections/shell.html#syntax-on">syntax-on</a>, <a href="src/generated-sections/shell.html#sys-command">sys-command?</a></p>
<h3 id="sh"><a class="header" href="#sh">$sh</a></h3>
<p><strong>Usage:</strong> ($sh "echo 'hello world'")</p>
<p><strong>Namespace:</strong> root</p>
<p>Runs a shell command and returns a string of the output with newlines removed.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="args"><a class="header" href="#args"><em>args</em></a></h3>
<p><strong>Usage:</strong> <em>args</em></p>
<p><strong>Namespace:</strong> root</p>
<p>A vector of the argumants passed to the script.
The first argument will be the name of the script.</p>
<p>No Examples</p>
<h3 id="shell-exe"><a class="header" href="#shell-exe"><em>shell-exe</em></a></h3>
<p><strong>Usage:</strong> <em>shell-exe</em></p>
<p><strong>Namespace:</strong> root</p>
<p>A string that contains the executable that is running the script.</p>
<p>No Examples</p>
<h3 id="bg-color-rgb"><a class="header" href="#bg-color-rgb">bg-color-rgb</a></h3>
<p><strong>Usage:</strong> (bg-color-rgb red-val green-val blue-val)</p>
<p><strong>Namespace:</strong> root</p>
<p>Set the background color to the desired rgb where each arg is an integer between 0 and 255 inclusive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "\x1b[48;2;128;128;128m" (bg-color-rgb 128 128 128))
(test::assert-equal "\x1b[48;2;255;255;255m" (bg-color-rgb 255 255 255))
(test::assert-equal "\x1b[48;2;255;0;0m" (bg-color-rgb 255 0 0))
(test::assert-equal "\x1b[48;2;0;255;0m" (bg-color-rgb 0 255 0))
(test::assert-equal "\x1b[48;2;0;0;255m" (bg-color-rgb 0 0 255))
(test::assert-equal "\x1b[48;2;0;0;0m" (bg-color-rgb 0 0 0))
</code></pre>
<h3 id="fg-color-rgb"><a class="header" href="#fg-color-rgb">fg-color-rgb</a></h3>
<p><strong>Usage:</strong> (fg-color-rgb red-val green-val blue-val)</p>
<p><strong>Namespace:</strong> root</p>
<p>Set the foreground color to the desired rgb where each arg is an integer between 0 and 255 inclusive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "\x1b[38;2;0;0;0m" (fg-color-rgb 0 0 0))
(test::assert-equal "\x1b[38;2;128;128;128m" (fg-color-rgb 128 128 128))
(test::assert-equal "\x1b[38;2;255;0;0m" (fg-color-rgb 255 0 0))
(test::assert-equal "\x1b[38;2;0;255;0m" (fg-color-rgb 0 255 0))
(test::assert-equal "\x1b[38;2;0;0;255m" (fg-color-rgb 0 0 255))
(test::assert-equal "\x1b[38;2;255;255;255m" (fg-color-rgb 255 255 255))
</code></pre>
<h3 id="sh-1"><a class="header" href="#sh-1">sh</a></h3>
<p><strong>Usage:</strong> (sh "echo 'hello world'")</p>
<p><strong>Namespace:</strong> root</p>
<p>Runs a shell command and returns its status.</p>
<p>No Examples</p>
<h3 id="syntax-off"><a class="header" href="#syntax-off">syntax-off</a></h3>
<p><strong>Usage:</strong> (syntax-off)</p>
<p><strong>Namespace:</strong> root</p>
<p>Turn off syntax highlighting at the repl.</p>
<p>No Examples</p>
<h3 id="syntax-on"><a class="header" href="#syntax-on">syntax-on</a></h3>
<p><strong>Usage:</strong> (syntax-on [SCRATCH] [SCRATCH] plev ch sys-syms token in-sys-command tok-command is-lisp paren-color my-sys-command? sys-command-color command-color prrawtoken prtoken paren-open paren-close whitespace in-quote out last-ch str-mapper-fn line-handler)</p>
<p><strong>Namespace:</strong> root</p>
<p>Turn on syntax highlighting at the repl.</p>
<p>No Examples</p>
<h3 id="sys-command"><a class="header" href="#sys-command">sys-command?</a></h3>
<p><strong>Usage:</strong> (sys-command? com)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the supplied command is a system command.</p>
<p>Example:</p>
<pre><code>(test::assert-true (sys-command? "sh"))
(test::assert-false (sys-command? "rst-not-a-command-strsnt"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="string-1"><a class="header" href="#string-1">string</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/string.html#str">str</a>, <a href="src/generated-sections/string.html#str-append">str-append</a>, <a href="src/generated-sections/string.html#str-bytes">str-bytes</a>, <a href="src/generated-sections/string.html#str-cat-list">str-cat-list</a>, <a href="src/generated-sections/string.html#str-clear">str-clear!</a>, <a href="src/generated-sections/string.html#str-contains">str-contains</a>, <a href="src/generated-sections/string.html#str-empty">str-empty?</a>, <a href="src/generated-sections/string.html#str-lower">str-lower</a>, <a href="src/generated-sections/string.html#str-ltrim">str-ltrim</a>, <a href="src/generated-sections/string.html#str-map">str-map</a>, <a href="src/generated-sections/string.html#str-push">str-push!</a>, <a href="src/generated-sections/string.html#str-replace">str-replace</a>, <a href="src/generated-sections/string.html#str-rsplit">str-rsplit</a>, <a href="src/generated-sections/string.html#str-rsplitn">str-rsplitn</a>, <a href="src/generated-sections/string.html#str-rtrim">str-rtrim</a>, <a href="src/generated-sections/string.html#str-split">str-split</a>, <a href="src/generated-sections/string.html#str-splitn">str-splitn</a>, <a href="src/generated-sections/string.html#str-starts-with">str-starts-with</a>, <a href="src/generated-sections/string.html#str-sub">str-sub</a>, <a href="src/generated-sections/string.html#str-trim">str-trim</a>, <a href="src/generated-sections/string.html#str-trim">str-trim!</a>, <a href="src/generated-sections/string.html#str-upper">str-upper</a></p>
<h3 id="str"><a class="header" href="#str">str</a></h3>
<p><strong>Usage:</strong> (str arg0 ... argN) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Make a new string with its arguments.</p>
<p>Arguments will be turned into strings.  If an argument is a process then the
output of the process will be captured and put into the string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stringsome" (str "string" "some"))
(test::assert-equal "string" (str "string" ""))
(test::assert-equal "string 50" (str "string" " " 50))
</code></pre>
<h3 id="str-append"><a class="header" href="#str-append">str-append</a></h3>
<p><strong>Usage:</strong> (str-append string1 string2) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Append two strings together.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "helloworld" (str-append "hello" "world"))
(test::assert-equal "hello world" (str-append "hello " "world"))
(test::assert-equal "hello" (str-append "hello" ""))
(test::assert-equal "world" (str-append "" "world"))
</code></pre>
<h3 id="str-bytes"><a class="header" href="#str-bytes">str-bytes</a></h3>
<p><strong>Usage:</strong> (str-bytes string) -&gt; int</p>
<p><strong>Namespace:</strong> root</p>
<p>Return number of bytes in a string (may be more then length).</p>
<p>Strings are utf8 so it chars and bytes may not be a one to one match.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 4 (str-bytes "Stau"))
(test::assert-equal 0 (str-bytes ""))
; Note 5 chars and 6 bytes because of the final char.
(test::assert-equal 6 (str-bytes "StauΣ"))
</code></pre>
<h3 id="str-cat-list"><a class="header" href="#str-cat-list">str-cat-list</a></h3>
<p><strong>Usage:</strong> (str-cat-list join-str sequence) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Build a string by concatenating a sequence of strings by join-str.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stringxxxyyyxxxsome" (str-cat-list "xxx" ["string" "yyy" "some"]))
(test::assert-equal "string yyy some" (str-cat-list " " ["string" "yyy" "some"]))
(test::assert-equal "stringyyysome" (str-cat-list "" ["string" "yyy" "some"]))
</code></pre>
<h3 id="str-clear"><a class="header" href="#str-clear">str-clear!</a></h3>
<p><strong>Usage:</strong> (str-clear! string) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Clear a string buffer in place.  This is a destructive form.</p>
<p>Example:</p>
<pre><code>(def test-str-clear (str "string"))
(test::assert-equal "string" test-str-clear)
(test::assert-equal "" (str-clear! test-str-clear))
(test::assert-equal "" test-str-clear)
</code></pre>
<h3 id="str-contains"><a class="header" href="#str-contains">str-contains</a></h3>
<p><strong>Usage:</strong> (str-contains string pattern) -&gt; #t/#f</p>
<p><strong>Namespace:</strong> root</p>
<p>True if string contains pattern (pattern will be converted to a string first).</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-contains "Stausomething" "Stau"))
(test::assert-false (str-contains "Stausomething" "StaU"))
(test::assert-true (str-contains "Stausomething" "some"))
(test::assert-false (str-contains "Stausomething" "Some"))
(test::assert-true (str-contains "Stausomething" "thing"))
(test::assert-false (str-contains "Stausomething" "Thing"))
(test::assert-true (str-contains "StausomeΣthing" "someΣ"))
</code></pre>
<h3 id="str-empty"><a class="header" href="#str-empty">str-empty?</a></h3>
<p><strong>Usage:</strong> (str-empty? string) -&gt; #t/#f</p>
<p><strong>Namespace:</strong> root</p>
<p>Is a string empty?  Let's find out...</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-empty? ""))
(test::assert-true (str-empty? (str-trim "   ")))
(test::assert-false (str-empty? " "))
(test::assert-false (str-empty? "string"))
</code></pre>
<h3 id="str-lower"><a class="header" href="#str-lower">str-lower</a></h3>
<p><strong>Usage:</strong> (str-lower string) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Get all lower case string from a string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stau" (str-lower "STAU"))
(test::assert-equal "stau" (str-lower "stau"))
(test::assert-equal "stau" (str-lower "Stau"))
(test::assert-equal "stau" (str-lower "StaU"))
(test::assert-equal "stau" (str-lower "sTaU"))
</code></pre>
<h3 id="str-ltrim"><a class="header" href="#str-ltrim">str-ltrim</a></h3>
<p><strong>Usage:</strong> (str-ltrim string) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Trim left whitespace from string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some string" (str-ltrim "   some string"))
(test::assert-equal "some string   " (str-ltrim "   some string   "))
(test::assert-equal "some string   " (str-ltrim (str "   some string   ")))
(test::assert-equal "some string   " (str-ltrim "some string   "))
(test::assert-equal "some string" (str-ltrim "some string"))
</code></pre>
<h3 id="str-map"><a class="header" href="#str-map">str-map</a></h3>
<p><strong>Usage:</strong> (str-map string lambda) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Make a new string by applying lambda to each char in input string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "XstringXstrX" (str-map "xstringxstrx" (fn (ch) (if (= "x" ch) "X" ch))))
(def test-str-map (str-map "xstringxstrx" (fn (ch) (if (= "x" ch) "X" ch))))
(test::assert-equal "XstringXstrX" test-str-map)
(test::assert-true (string? test-str-map))
(def test-str-map (str-map (str "xstringxstrx") (fn (ch) (if (= "x" ch) "X" ch))))
(test::assert-equal "XstringXstrX" test-str-map)
(test::assert-true (string? test-str-map))
</code></pre>
<h3 id="str-push"><a class="header" href="#str-push">str-push!</a></h3>
<p><strong>Usage:</strong> (str-push! string arg0 ... argN) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Push the args (as strings) onto the string.  This is a destructive form.</p>
<p>Arguments will be turned into strings.  Returns the string it was given.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stringsome" (str-push! (str "string") "some"))
(def test-str-push (str "def-string"))
(test::assert-equal "def-stringsome" (str-push! test-str-push "some"))
(test::assert-equal "def-stringsome" test-str-push)
</code></pre>
<h3 id="str-replace"><a class="header" href="#str-replace">str-replace</a></h3>
<p><strong>Usage:</strong> (str-replace string old-pattern new-pattern) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Replace occurrences of second string with third in the first string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some yyy string" (str-replace "some xxx string" "xxx" "yyy"))
(test::assert-equal "some yyy string yyy" (str-replace "some xxx string xxx" "xxx" "yyy"))
(test::assert-equal "yyy some yyy string yyy" (str-replace "xxx some xxx string xxx" "xxx" "yyy"))
</code></pre>
<h3 id="str-rsplit"><a class="header" href="#str-rsplit">str-rsplit</a></h3>
<p><strong>Usage:</strong> (str-rsplit pattern string) -&gt; list</p>
<p><strong>Namespace:</strong> root</p>
<p>Use a pattern to split a string in reverse order.</p>
<p>Example:</p>
<pre><code>(test::assert-equal ["string" "yyy" "some"] (str-rsplit "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["" "string" "yyy" "some"] (str-rsplit "xxx" "somexxxyyyxxxstringxxx"))
(test::assert-equal ["" "string" "yyy" "some" ""] (str-rsplit "xxx" "xxxsomexxxyyyxxxstringxxx"))
</code></pre>
<h3 id="str-rsplitn"><a class="header" href="#str-rsplitn">str-rsplitn</a></h3>
<p><strong>Usage:</strong> (str-rsplitn n split-pattern string) -&gt; list</p>
<p><strong>Namespace:</strong> root</p>
<p>Use a pattern to split a string in reverse order with at most n items.</p>
<p>Example:</p>
<pre><code>(test::assert-equal ["string" "somexxxyyy"] (str-rsplitn 2 "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["string" "yyy" "some"] (str-rsplitn 3 "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["string" "yyy" "some"] (str-rsplitn 4 "xxx" "somexxxyyyxxxstring"))
</code></pre>
<h3 id="str-rtrim"><a class="header" href="#str-rtrim">str-rtrim</a></h3>
<p><strong>Usage:</strong> (str-rtrim string) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Trim right whitespace from string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "   some string" (str-rtrim "   some string"))
(test::assert-equal "   some string" (str-rtrim "   some string   "))
(test::assert-equal "   some string" (str-rtrim (str "   some string   ")))
(test::assert-equal "some string" (str-rtrim "some string   "))
(test::assert-equal "some string" (str-rtrim "some string"))
</code></pre>
<h3 id="str-split"><a class="header" href="#str-split">str-split</a></h3>
<p><strong>Usage:</strong> (str-split string split-pattern) -&gt; vector</p>
<p><strong>Namespace:</strong> root</p>
<p>Use a pattern to split a string (:whitespace to split on whitespace).</p>
<p>Example:</p>
<pre><code>(test::assert-equal ["some" "yyy" "string"] (str-split "somexxxyyyxxxstring" "xxx"))
(test::assert-equal ["some" "yyy" "string" ""] (str-split "somexxxyyyxxxstringxxx" "xxx"))
(test::assert-equal ["" "some" "yyy" "string" ""] (str-split "xxxsomexxxyyyxxxstringxxx" "xxx"))
(test::assert-equal ["some" "yyy" "string"] (str-split "some yyy string" :whitespace))
(test::assert-equal ["somexxxyyyxxxstring"] (str-split "somexxxyyyxxxstring" :whitespace))
(test::assert-equal ["somexxxyyyxxxstring"] (str-split "somexxxyyyxxxstring" "zzz"))
</code></pre>
<h3 id="str-splitn"><a class="header" href="#str-splitn">str-splitn</a></h3>
<p><strong>Usage:</strong> (str-splitn n split-pattern string) -&gt; vector</p>
<p><strong>Namespace:</strong> root</p>
<p>Use a pattern to split a string with at most n items.</p>
<p>Example:</p>
<pre><code>(test::assert-equal ["some" "yyy" "string"] (str-splitn 3 "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["some" "yyy" "string"] (str-splitn 4 "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["some" "yyy" "stringxxxother"] (str-splitn 3 "xxx" "somexxxyyyxxxstringxxxother"))
(test::assert-equal ["somexxxyyyxxxstringxxxother"] (str-splitn 1 "xxx" "somexxxyyyxxxstringxxxother"))
(test::assert-equal [] (str-splitn 0 "xxx" "somexxxyyyxxxstringxxxzero"))
</code></pre>
<h3 id="str-starts-with"><a class="header" href="#str-starts-with">str-starts-with</a></h3>
<p><strong>Usage:</strong> (str-starts-with string pattern) -&gt; #t/#f</p>
<p><strong>Namespace:</strong> root</p>
<p>True if string start with pattern.</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-starts-with "Stausomething" "Stau"))
(test::assert-false (str-starts-with "Stausomething" "StaU"))
</code></pre>
<h3 id="str-sub"><a class="header" href="#str-sub">str-sub</a></h3>
<p><strong>Usage:</strong> (str-sub string start [length]) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Return a substring from a string given start (0 based) and optional length.
If length is 0 or not provided produces the rest of the string from start to
string end.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "string" (str-sub "stringxxxyyyxxxsome" 0 6))
(test::assert-equal "some" (str-sub "stringxxxyyyxxxsome" 15 4))
(test::assert-equal "yyy" (str-sub "stringxxxyyyxxxsome" 9 3))
(test::assert-equal "some" (str-sub "stringxxxyyyxxxsome" 15))
</code></pre>
<h3 id="str-trim"><a class="header" href="#str-trim">str-trim</a></h3>
<p><strong>Usage:</strong> (str-trim string [:right | :left]) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Trim right and/or left whitespace from string.  With no optional keywork trims both, otherwise :right
or :left specify right or left trimming.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some string" (str-trim "   some string"))
(test::assert-equal "some string" (str-trim "   some string   "))
(test::assert-equal "some string" (str-trim (str "   some string   ")))
(test::assert-equal "some string" (str-trim "some string   "))
(test::assert-equal "some string" (str-trim "some string"))

(test::assert-equal "   some string" (str-trim "   some string" :right))
(test::assert-equal "   some string" (str-trim "   some string   " :right))
(test::assert-equal "   some string" (str-trim (str "   some string   ") :right))
(test::assert-equal "some string" (str-trim "some string   " :right))
(test::assert-equal "some string" (str-trim "some string" :right))

(test::assert-equal "some string" (str-trim "   some string" :left))
(test::assert-equal "some string   " (str-trim "   some string   " :left))
(test::assert-equal "some string   " (str-trim (str "   some string   ")  :left))
(test::assert-equal "some string   " (str-trim "some string   " :left))
(test::assert-equal "some string" (str-trim "some string" :left))
</code></pre>
<h3 id="str-trim-1"><a class="header" href="#str-trim-1">str-trim!</a></h3>
<p><strong>Usage:</strong> (str-trim! string [:right | :left]) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Trim right and/or left whitespace from string in place.  With no optional keywork trims both,
otherwise :right or :left specify right or left trimming.</p>
<p>This is a destructive operation (unlike str-trim) and requires an actual non-const string as it's first
argument.  It returns this string on success.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some string" (str-trim! (str "   some string")))
(test::assert-equal "some string" (str-trim! (str  "   some string   ")))
(test::assert-equal "some string" (str-trim! (str  (str "   some string   "))))
(test::assert-equal "some string" (str-trim! (str  "some string   ")))
(test::assert-equal "some string" (str-trim! (str  "some string")))

(test::assert-equal "   some string" (str-trim! (str  "   some string") :right))
(test::assert-equal "   some string" (str-trim! (str  "   some string   ") :right))
(test::assert-equal "   some string" (str-trim! (str  (str "   some string   "))  :right))
(test::assert-equal "some string" (str-trim! (str  "some string   ") :right))
(test::assert-equal "some string" (str-trim! (str  "some string") :right))

(test::assert-equal "some string" (str-trim! (str  "   some string") :left))
(test::assert-equal "some string   " (str-trim! (str  "   some string   ") :left))
(test::assert-equal "some string   " (str-trim! (str  (str "   some string   "))  :left))
(test::assert-equal "some string   " (str-trim! (str  "some string   ") :left))
(test::assert-equal "some string" (str-trim! (str  "some string") :left))
</code></pre>
<h3 id="str-upper"><a class="header" href="#str-upper">str-upper</a></h3>
<p><strong>Usage:</strong> (str-upper string) -&gt; string</p>
<p><strong>Namespace:</strong> root</p>
<p>Get all upper case string from a string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "STAU" (str-upper "STAU"))
(test::assert-equal "STAU" (str-upper "stau"))
(test::assert-equal "STAU" (str-upper "Stau"))
(test::assert-equal "STAU" (str-upper "StaU"))
(test::assert-equal "STAU" (str-upper "sTaU"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="system"><a class="header" href="#system">system</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/system.html#sleep">sleep</a></p>
<h3 id="sleep"><a class="header" href="#sleep">sleep</a></h3>
<p><strong>Usage:</strong> (sleep milliseconds) -&gt; nil</p>
<p><strong>Namespace:</strong> root</p>
<p>Sleep for <em>at least</em> the provided milliseconds (must be a positive integer),
otherwise function will no-op.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test"><a class="header" href="#test">test</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/test.html#assert-compare">assert-compare</a>, <a href="src/generated-sections/test.html#assert-compare">assert-compare</a>, <a href="src/generated-sections/test.html#assert-equal">assert-equal</a>, <a href="src/generated-sections/test.html#assert-equal">assert-equal</a>, <a href="src/generated-sections/test.html#assert-error">assert-error</a>, <a href="src/generated-sections/test.html#assert-error">assert-error</a>, <a href="src/generated-sections/test.html#assert-error-msg">assert-error-msg</a>, <a href="src/generated-sections/test.html#assert-error-msg">assert-error-msg</a>, <a href="src/generated-sections/test.html#assert-false">assert-false</a>, <a href="src/generated-sections/test.html#assert-false">assert-false</a>, <a href="src/generated-sections/test.html#assert-not-compare">assert-not-compare</a>, <a href="src/generated-sections/test.html#assert-not-compare">assert-not-compare</a>, <a href="src/generated-sections/test.html#assert-not-equal">assert-not-equal</a>, <a href="src/generated-sections/test.html#assert-not-equal">assert-not-equal</a>, <a href="src/generated-sections/test.html#assert-true">assert-true</a>, <a href="src/generated-sections/test.html#assert-true">assert-true</a></p>
<h3 id="assert-compare"><a class="header" href="#assert-compare">assert-compare</a></h3>
<p><strong>Usage:</strong> (test::assert-compare compare expected-val right-val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the two values are true based on the provided comparator.</p>
<p>No Examples</p>
<h3 id="assert-compare-1"><a class="header" href="#assert-compare-1">assert-compare</a></h3>
<p><strong>Usage:</strong> (test::assert-compare compare expected-val right-val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the two values are true based on the provided comparator.</p>
<p>No Examples</p>
<h3 id="assert-equal"><a class="header" href="#assert-equal">assert-equal</a></h3>
<p><strong>Usage:</strong> (test::assert-equal expected-val right-val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the two values are identical.</p>
<p>No Examples</p>
<h3 id="assert-equal-1"><a class="header" href="#assert-equal-1">assert-equal</a></h3>
<p><strong>Usage:</strong> (test::assert-equal expected-val right-val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the two values are identical.</p>
<p>No Examples</p>
<h3 id="assert-error"><a class="header" href="#assert-error">assert-error</a></h3>
<p><strong>Usage:</strong> (test::assert-error val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the value is an error</p>
<p>No Examples</p>
<h3 id="assert-error-1"><a class="header" href="#assert-error-1">assert-error</a></h3>
<p><strong>Usage:</strong> (test::assert-error val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the value is an error</p>
<p>No Examples</p>
<h3 id="assert-error-msg"><a class="header" href="#assert-error-msg">assert-error-msg</a></h3>
<p><strong>Usage:</strong> (test::assert-error-msg form key msg)</p>
<p><strong>Namespace:</strong> root</p>
<p>Test asserts an error is thrown with a given key and message.</p>
<p>Example:</p>
<pre><code>(test::assert-error-msg (err "error thrown") :error "error thrown")
</code></pre>
<h3 id="assert-error-msg-1"><a class="header" href="#assert-error-msg-1">assert-error-msg</a></h3>
<p><strong>Usage:</strong> (test::assert-error-msg form key msg)</p>
<p><strong>Namespace:</strong> test</p>
<p>Test asserts an error is thrown with a given key and message.</p>
<p>Example:</p>
<pre><code>(test::assert-error-msg (err "error thrown") :error "error thrown")
</code></pre>
<h3 id="assert-false"><a class="header" href="#assert-false">assert-false</a></h3>
<p><strong>Usage:</strong> (test::assert-false val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the value is false</p>
<p>No Examples</p>
<h3 id="assert-false-1"><a class="header" href="#assert-false-1">assert-false</a></h3>
<p><strong>Usage:</strong> (test::assert-false val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the value is false</p>
<p>No Examples</p>
<h3 id="assert-not-compare"><a class="header" href="#assert-not-compare">assert-not-compare</a></h3>
<p><strong>Usage:</strong> (test::assert-not-compare compare expected-val right-val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the two values are not true based on the comparator.</p>
<p>No Examples</p>
<h3 id="assert-not-compare-1"><a class="header" href="#assert-not-compare-1">assert-not-compare</a></h3>
<p><strong>Usage:</strong> (test::assert-not-compare compare expected-val right-val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the two values are not true based on the comparator.</p>
<p>No Examples</p>
<h3 id="assert-not-equal"><a class="header" href="#assert-not-equal">assert-not-equal</a></h3>
<p><strong>Usage:</strong> (test::assert-not-equal expected-val right-val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the two values are not identical.</p>
<p>No Examples</p>
<h3 id="assert-not-equal-1"><a class="header" href="#assert-not-equal-1">assert-not-equal</a></h3>
<p><strong>Usage:</strong> (test::assert-not-equal expected-val right-val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the two values are not identical.</p>
<p>No Examples</p>
<h3 id="assert-true"><a class="header" href="#assert-true">assert-true</a></h3>
<p><strong>Usage:</strong> (test::assert-true val body)</p>
<p><strong>Namespace:</strong> root</p>
<p>Asserts the value is true.</p>
<p>No Examples</p>
<h3 id="assert-true-1"><a class="header" href="#assert-true-1">assert-true</a></h3>
<p><strong>Usage:</strong> (test::assert-true val body)</p>
<p><strong>Namespace:</strong> test</p>
<p>Asserts the value is true.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type"><a class="header" href="#type">type</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/type.html#-float">-&gt;float</a>, <a href="src/generated-sections/type.html#-int">-&gt;int</a>, <a href="src/generated-sections/type.html#boolean">boolean?</a>, <a href="src/generated-sections/type.html#callable">callable?</a>, <a href="src/generated-sections/type.html#char">char?</a>, <a href="src/generated-sections/type.html#err">err?</a>, <a href="src/generated-sections/type.html#false">false?</a>, <a href="src/generated-sections/type.html#falsey">falsey?</a>, <a href="src/generated-sections/type.html#float">float?</a>, <a href="src/generated-sections/type.html#hash-set">hash-set?</a>, <a href="src/generated-sections/type.html#int">int?</a>, <a href="src/generated-sections/type.html#io">io?</a>, <a href="src/generated-sections/type.html#list">list?</a>, <a href="src/generated-sections/type.html#nil">nil?</a>, <a href="src/generated-sections/type.html#ok">ok?</a>, <a href="src/generated-sections/type.html#pair">pair?</a>, <a href="src/generated-sections/type.html#seq">seq?</a>, <a href="src/generated-sections/type.html#string">string?</a>, <a href="src/generated-sections/type.html#symbol">symbol?</a>, <a href="src/generated-sections/type.html#true">true?</a>, <a href="src/generated-sections/type.html#vec">vec?</a></p>
<h3 id="-float"><a class="header" href="#-float">-&gt;float</a></h3>
<p><strong>Usage:</strong> (-&gt;float ?float) -&gt; float</p>
<p><strong>Namespace:</strong> root</p>
<p>If string or other value is a valid representation of a float return that float.  Error if not.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (-&gt;float "0"))
(test::assert-equal 11.0 (-&gt;float 11))
(test::assert-equal 10.0 (-&gt;float "10.0"))
(test::assert-equal 13.0 (-&gt;float :13))
(test::assert-equal 10.5 (-&gt;float "10.5"))
(test::assert-equal 101.0 (-&gt;float "101"))
(test::assert-equal -101.95 (-&gt;float "-101.95"))
(test::assert-error (-&gt;float "not int"))
(test::assert-error (-&gt;float "--10"))
;; for some reason this -&gt;sym test case must be last or else there's an error w/ load
(test::assert-equal 12.0 (-&gt;float (-&gt;sym 12)))
</code></pre>
<h3 id="-int"><a class="header" href="#-int">-&gt;int</a></h3>
<p><strong>Usage:</strong> (-&gt;int ?int) -&gt; int</p>
<p><strong>Namespace:</strong> root</p>
<p>If string or other value is a valid representation of an integer return that int.  Error if not.</p>
<p>Note, if value is a float (or is a string that casts initially to a float) and it is NaN,
+/- infinity, &lt; i56::MIN, or &gt; i56::MAX the function will error.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (-&gt;int "0"))
(test::assert-equal 101 (-&gt;int "101"))
(test::assert-equal 1101 (-&gt;int :1101))
(test::assert-equal 8 (-&gt;int 8.1))
(test::assert-equal -111 (-&gt;int "-111"))
(test::assert-equal 10 (-&gt;int "10.0"))
(test::assert-error (-&gt;int "not int"))
(test::assert-error (-&gt;int "--10"))
;; for some reason this -&gt;sym test case must be last or else there's an error w/ load
(test::assert-equal 1102 (-&gt;int (-&gt;sym 1102)))
</code></pre>
<h3 id="boolean"><a class="header" href="#boolean">boolean?</a></h3>
<p><strong>Usage:</strong> (boolean? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a boolean (#t or #f), false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (boolean? #t))
(test::assert-true (boolean? #f))
(test::assert-false (boolean? 1))
(test::assert-false (boolean? "string"))
(test::assert-false (boolean? nil))
</code></pre>
<h3 id="callable"><a class="header" href="#callable">callable?</a></h3>
<p><strong>Usage:</strong> (callable? v [SCRATCH] [SCRATCH] t)</p>
<p><strong>Namespace:</strong> root</p>
<p>Usage: (callable? to-test)</p>
<p>No Examples</p>
<h3 id="char-1"><a class="header" href="#char-1">char?</a></h3>
<p><strong>Usage:</strong> (char? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a char, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (char? \a))
(test::assert-false (char? 1))
(test::assert-false (char? "a"))
</code></pre>
<h3 id="err-1"><a class="header" href="#err-1">err?</a></h3>
<p><strong>Usage:</strong> (err? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is an error, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (err? (mk-err :arr "test")))
(test::assert-false (err? nil))
</code></pre>
<h3 id="false"><a class="header" href="#false">false?</a></h3>
<p><strong>Usage:</strong> (false? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is the value false (#f), false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (false? #f))
(test::assert-false (false? #t))
(test::assert-false (false? nil))
(test::assert-false (false? 0))
(test::assert-false (false? "false"))
</code></pre>
<h3 id="falsey"><a class="header" href="#falsey">falsey?</a></h3>
<p><strong>Usage:</strong> (falsey? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is false (#f) or nil, false otherwise.
This is useful for testing "truthiness" in conditionals.</p>
<p>Example:</p>
<pre><code>(test::assert-true (falsey? #f))
(test::assert-true (falsey? nil))
(test::assert-true (falsey? '()))
(test::assert-false (falsey? #t))
(test::assert-false (falsey? 0))
(test::assert-false (falsey? ""))
</code></pre>
<h3 id="float"><a class="header" href="#float">float?</a></h3>
<p><strong>Usage:</strong> (float? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a float, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (float? 7.0))
(test::assert-false (float? "7.0"))
</code></pre>
<h3 id="hash-set"><a class="header" href="#hash-set">hash-set?</a></h3>
<p><strong>Usage:</strong> (hash-set? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a set, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (hash-set? (make-hash)))
(test::assert-false (hash-set? 1))
</code></pre>
<h3 id="int"><a class="header" href="#int">int?</a></h3>
<p><strong>Usage:</strong> (int? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is an int, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (int? 7))
(test::assert-false (int? "7"))
</code></pre>
<h3 id="io-1"><a class="header" href="#io-1">io?</a></h3>
<p><strong>Usage:</strong> (io? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is an IO object (file), false otherwise.</p>
<p>Example:</p>
<pre><code>(def iotst (fopen "/tmp/iotst" :create))
(test::assert-true (io? iotst))
(test::assert-false (io? 1))
(test::assert-false (io? '(1 2 3)))
(test::assert-false (io? (list)))
</code></pre>
<h3 id="list-1"><a class="header" href="#list-1">list?</a></h3>
<p><strong>Usage:</strong> (list? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a list, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (list? '(1 2 3)) "reader macro")
(test::assert-true (list? (list 1 2 3)) "list")
(test::assert-false (list? 1))
(test::assert-false (list? [1 2 3]))
(test::assert-false (list? []))
(test::assert-false (list? '(1 . 2)))
</code></pre>
<h3 id="nil"><a class="header" href="#nil">nil?</a></h3>
<p><strong>Usage:</strong> (nil? v)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is nil, false otherwise</p>
<p>Example:</p>
<pre><code>(test::assert-true (nil? ()))
(test::assert-true (nil? '()))
(test::assert-true (nil? nil))
(test::assert-true (nil? (list)))
(test::assert-false (nil? #f))
</code></pre>
<h3 id="ok"><a class="header" href="#ok">ok?</a></h3>
<p><strong>Usage:</strong> (ok? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is NOT an error, false if it is an error.</p>
<p>Example:</p>
<pre><code>(test::assert-false (ok? (mk-err :arr "test")))
(test::assert-true (ok? nil))
</code></pre>
<h3 id="pair-1"><a class="header" href="#pair-1">pair?</a></h3>
<p><strong>Usage:</strong> (pair? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a pair, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (pair? '(1 . 2)) "reader macro")
(test::assert-true (pair? (cons 1 2)) "cons")
(test::assert-true (pair? '(1 2)))
(test::assert-false (pair? 1))
(test::assert-false (pair? [1 2 3]))
(test::assert-false (pair? (vec)))
</code></pre>
<h3 id="seq"><a class="header" href="#seq">seq?</a></h3>
<p><strong>Usage:</strong> (seq? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if expression is a list or vector, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (seq? '(1 2 3)))
(test::assert-true (seq? [1 2 3]))
(test::assert-true (seq? []))
(test::assert-false (seq? "aaa"))
(test::assert-false (seq? 1))
</code></pre>
<h3 id="string-2"><a class="header" href="#string-2">string?</a></h3>
<p><strong>Usage:</strong> (string? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a string, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (string? "string"))
(test::assert-false (string? 1))
</code></pre>
<h3 id="symbol"><a class="header" href="#symbol">symbol?</a></h3>
<p><strong>Usage:</strong> (symbol? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a symbol, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (symbol? 'symbol))
(test::assert-false (symbol? 1))
</code></pre>
<h3 id="true"><a class="header" href="#true">true?</a></h3>
<p><strong>Usage:</strong> (true? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is the value true (#t), false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (true? #t))
(test::assert-false (true? #f))
(test::assert-false (true? 1))
(test::assert-false (true? "true"))
(test::assert-false (true? nil))
</code></pre>
<h3 id="vec"><a class="header" href="#vec">vec?</a></h3>
<p><strong>Usage:</strong> (vec? expression)</p>
<p><strong>Namespace:</strong> root</p>
<p>True if the expression is a vector, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (vec? [1 2 3]) "reader macro")
(test::assert-true (vec? (make-vec)) "make-vec")
(test::assert-true (vec? (vec 1 2 3)) "vec")
(test::assert-false (vec? 1))
(test::assert-false (vec? '(1 2 3)))
(test::assert-false (vec? (list)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="undocumented"><a class="header" href="#undocumented">undocumented</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/undocumented.html#bg-black"><em>bg-black</em></a>, <a href="src/generated-sections/undocumented.html#bg-blue"><em>bg-blue</em></a>, <a href="src/generated-sections/undocumented.html#bg-cyan"><em>bg-cyan</em></a>, <a href="src/generated-sections/undocumented.html#bg-default"><em>bg-default</em></a>, <a href="src/generated-sections/undocumented.html#bg-green"><em>bg-green</em></a>, <a href="src/generated-sections/undocumented.html#bg-magenta"><em>bg-magenta</em></a>, <a href="src/generated-sections/undocumented.html#bg-red"><em>bg-red</em></a>, <a href="src/generated-sections/undocumented.html#bg-white"><em>bg-white</em></a>, <a href="src/generated-sections/undocumented.html#bg-yellow"><em>bg-yellow</em></a>, <a href="src/generated-sections/undocumented.html#fg-black"><em>fg-black</em></a>, <a href="src/generated-sections/undocumented.html#fg-blue"><em>fg-blue</em></a>, <a href="src/generated-sections/undocumented.html#fg-cyan"><em>fg-cyan</em></a>, <a href="src/generated-sections/undocumented.html#fg-default"><em>fg-default</em></a>, <a href="src/generated-sections/undocumented.html#fg-green"><em>fg-green</em></a>, <a href="src/generated-sections/undocumented.html#fg-magenta"><em>fg-magenta</em></a>, <a href="src/generated-sections/undocumented.html#fg-red"><em>fg-red</em></a>, <a href="src/generated-sections/undocumented.html#fg-white"><em>fg-white</em></a>, <a href="src/generated-sections/undocumented.html#fg-yellow"><em>fg-yellow</em></a>, <a href="src/generated-sections/undocumented.html#int-bits"><em>int-bits</em></a>, <a href="src/generated-sections/undocumented.html#int-max"><em>int-max</em></a>, <a href="src/generated-sections/undocumented.html#int-min"><em>int-min</em></a>, <a href="src/generated-sections/undocumented.html#ns"><em>ns</em></a>, <a href="src/generated-sections/undocumented.html#linehandler">__line_handler</a>, <a href="src/generated-sections/undocumented.html#callcc">call/cc</a>, <a href="src/generated-sections/undocumented.html#dasm">dasm</a>, <a href="src/generated-sections/undocumented.html#defer">defer</a>, <a href="src/generated-sections/undocumented.html#doc-string">doc-string</a>, <a href="src/generated-sections/undocumented.html#dump-regs">dump-regs</a>, <a href="src/generated-sections/undocumented.html#epr">epr</a>, <a href="src/generated-sections/undocumented.html#eprn">eprn</a>, <a href="src/generated-sections/undocumented.html#fpr">fpr</a>, <a href="src/generated-sections/undocumented.html#fprn">fprn</a>, <a href="src/generated-sections/undocumented.html#get">get</a>, <a href="src/generated-sections/undocumented.html#get-rgb-seq">get-rgb-seq</a>, <a href="src/generated-sections/undocumented.html#identical">identical?</a>, <a href="src/generated-sections/undocumented.html#pr">pr</a>, <a href="src/generated-sections/undocumented.html#prn">prn</a>, <a href="src/generated-sections/undocumented.html#return">return</a>, <a href="src/generated-sections/undocumented.html#this-fn">this-fn</a>, <a href="src/generated-sections/undocumented.html#tok-default-color">tok-default-color</a>, <a href="src/generated-sections/undocumented.html#tok-invalid-color">tok-invalid-color</a>, <a href="src/generated-sections/undocumented.html#tok-slsh-fcn-color">tok-slsh-fcn-color</a>, <a href="src/generated-sections/undocumented.html#tok-slsh-form-color">tok-slsh-form-color</a>, <a href="src/generated-sections/undocumented.html#tok-string-color">tok-string-color</a>, <a href="src/generated-sections/undocumented.html#tok-sys-alias-color">tok-sys-alias-color</a>, <a href="src/generated-sections/undocumented.html#tok-sys-command-color">tok-sys-command-color</a>, <a href="src/generated-sections/undocumented.html#type">type</a>, <a href="src/generated-sections/undocumented.html#while">while</a></p>
<h3 id="bg-black"><a class="header" href="#bg-black"><em>bg-black</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-blue"><a class="header" href="#bg-blue"><em>bg-blue</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-cyan"><a class="header" href="#bg-cyan"><em>bg-cyan</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-default"><a class="header" href="#bg-default"><em>bg-default</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-green"><a class="header" href="#bg-green"><em>bg-green</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-magenta"><a class="header" href="#bg-magenta"><em>bg-magenta</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-red"><a class="header" href="#bg-red"><em>bg-red</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-white"><a class="header" href="#bg-white"><em>bg-white</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="bg-yellow"><a class="header" href="#bg-yellow"><em>bg-yellow</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-black"><a class="header" href="#fg-black"><em>fg-black</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-blue"><a class="header" href="#fg-blue"><em>fg-blue</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-cyan"><a class="header" href="#fg-cyan"><em>fg-cyan</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-default"><a class="header" href="#fg-default"><em>fg-default</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-green"><a class="header" href="#fg-green"><em>fg-green</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-magenta"><a class="header" href="#fg-magenta"><em>fg-magenta</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-red"><a class="header" href="#fg-red"><em>fg-red</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-white"><a class="header" href="#fg-white"><em>fg-white</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fg-yellow"><a class="header" href="#fg-yellow"><em>fg-yellow</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="int-bits"><a class="header" href="#int-bits"><em>int-bits</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="int-max"><a class="header" href="#int-max"><em>int-max</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="int-min"><a class="header" href="#int-min"><em>int-min</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="ns-1"><a class="header" href="#ns-1"><em>ns</em></a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="__line_handler"><a class="header" href="#__line_handler">__line_handler</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="callcc"><a class="header" href="#callcc">call/cc</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="dasm"><a class="header" href="#dasm">dasm</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="defer"><a class="header" href="#defer">defer</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="doc-string"><a class="header" href="#doc-string">doc-string</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="dump-regs"><a class="header" href="#dump-regs">dump-regs</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="epr"><a class="header" href="#epr">epr</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="eprn"><a class="header" href="#eprn">eprn</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fpr"><a class="header" href="#fpr">fpr</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="fprn"><a class="header" href="#fprn">fprn</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="get"><a class="header" href="#get">get</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="get-rgb-seq"><a class="header" href="#get-rgb-seq">get-rgb-seq</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="identical"><a class="header" href="#identical">identical?</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="pr"><a class="header" href="#pr">pr</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="prn"><a class="header" href="#prn">prn</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="return"><a class="header" href="#return">return</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="this-fn"><a class="header" href="#this-fn">this-fn</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-default-color"><a class="header" href="#tok-default-color">tok-default-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-invalid-color"><a class="header" href="#tok-invalid-color">tok-invalid-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-slsh-fcn-color"><a class="header" href="#tok-slsh-fcn-color">tok-slsh-fcn-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-slsh-form-color"><a class="header" href="#tok-slsh-form-color">tok-slsh-form-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-string-color"><a class="header" href="#tok-string-color">tok-string-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-sys-alias-color"><a class="header" href="#tok-sys-alias-color">tok-sys-alias-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="tok-sys-command-color"><a class="header" href="#tok-sys-command-color">tok-sys-command-color</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="type-1"><a class="header" href="#type-1">type</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<p><strong>Usage:</strong> unknown</p>
<p><strong>Namespace:</strong> root</p>
<p>unknown</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vector-1"><a class="header" href="#vector-1">vector</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/vector.html#make-vec">make-vec</a>, <a href="src/generated-sections/vector.html#vec">vec</a>, <a href="src/generated-sections/vector.html#vec-list">vec-&gt;list</a>, <a href="src/generated-sections/vector.html#vec-clear">vec-clear!</a>, <a href="src/generated-sections/vector.html#vec-insert">vec-insert!</a>, <a href="src/generated-sections/vector.html#vec-pop">vec-pop!</a>, <a href="src/generated-sections/vector.html#vec-push">vec-push!</a>, <a href="src/generated-sections/vector.html#vec-remove">vec-remove!</a>, <a href="src/generated-sections/vector.html#vec-slice">vec-slice</a></p>
<h3 id="make-vec"><a class="header" href="#make-vec">make-vec</a></h3>
<p><strong>Usage:</strong> (make-vec capacity default)</p>
<p><strong>Namespace:</strong> root</p>
<p>Make a new vector with capacity and default item(s).</p>
<p>Example:</p>
<pre><code>(test::assert-equal [] (make-vec))
(test::assert-equal ['x 'x 'x] (make-vec 3 'x))
(test::assert-equal [nil nil nil nil nil] (make-vec 5 nil))
(test::assert-equal [] (make-vec 5))
</code></pre>
<h3 id="vec-1"><a class="header" href="#vec-1">vec</a></h3>
<p><strong>Usage:</strong> (vec item1 item2 .. itemN)</p>
<p><strong>Namespace:</strong> root</p>
<p>Make a new vector with items.</p>
<p>Example:</p>
<pre><code>(test::assert-equal [] (vec))
(test::assert-equal [1 2 3] (vec 1 2 3))
</code></pre>
<h3 id="vec-list"><a class="header" href="#vec-list">vec-&gt;list</a></h3>
<p><strong>Usage:</strong> (vec-&gt;list vector)</p>
<p><strong>Namespace:</strong> root</p>
<p>Convert a vector to a list.</p>
<p>No Examples</p>
<h3 id="vec-clear"><a class="header" href="#vec-clear">vec-clear!</a></h3>
<p><strong>Usage:</strong> (vec-clear! vector)</p>
<p><strong>Namespace:</strong> root</p>
<p>Clear all elements from a vector. This is a destructive form!</p>
<p>Example:</p>
<pre><code>(def test-vec [1 2 3])
(test::assert-false (empty? test-vec))
(vec-clear! test-vec)
(test::assert-true (empty? test-vec))
(test::assert-equal [] test-vec)
</code></pre>
<h3 id="vec-insert"><a class="header" href="#vec-insert">vec-insert!</a></h3>
<p><strong>Usage:</strong> (vec-insert! vector index new-element) -&gt; vector</p>
<p><strong>Namespace:</strong> root</p>
<p>Inserts new-element at index and moves following elements right in vector.  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-insert-nth-vec [1 2 3])
(test::assert-equal [1 2 3] test-insert-nth-vec)
(vec-insert! test-insert-nth-vec 1 5)
(test::assert-equal [1 5 2 3] test-insert-nth-vec)
(vec-insert! test-insert-nth-vec 2 6)
(test::assert-equal [1 5 6 2 3] test-insert-nth-vec)
(vec-insert! test-insert-nth-vec 0 4)
(test::assert-equal [4 1 5 6 2 3] test-insert-nth-vec)
</code></pre>
<h3 id="vec-pop"><a class="header" href="#vec-pop">vec-pop!</a></h3>
<p><strong>Usage:</strong> (vec-pop! vector) -&gt; object</p>
<p><strong>Namespace:</strong> root</p>
<p>Pops the last object off of the end of the vector.  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-pop-vec (vec 1 2 3))
(test::assert-equal 3 (vec-pop! test-pop-vec))
(test::assert-equal [1 2] test-pop-vec)
(test::assert-equal 2 (vec-pop! test-pop-vec))
(test::assert-equal [1] test-pop-vec)
(test::assert-equal 1 (vec-pop! test-pop-vec))
(test::assert-equal [] test-pop-vec)
</code></pre>
<h3 id="vec-push"><a class="header" href="#vec-push">vec-push!</a></h3>
<p><strong>Usage:</strong> (vec-push! vector object) -&gt; vector</p>
<p><strong>Namespace:</strong> root</p>
<p>Pushes the provided object onto the end of the vector.  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-push-vec (vec))
(test::assert-equal [1] (vec-push! test-push-vec 1))
(test::assert-equal [1] test-push-vec)
(test::assert-equal [1 2] (vec-push! test-push-vec 2))
(test::assert-equal [1 2] test-push-vec)
(test::assert-equal [1 2 3] (vec-push! test-push-vec 3))
(test::assert-equal [1 2 3] test-push-vec)
</code></pre>
<h3 id="vec-remove"><a class="header" href="#vec-remove">vec-remove!</a></h3>
<p><strong>Usage:</strong> (vec-remove! vector index) -&gt; vector</p>
<p><strong>Namespace:</strong> root</p>
<p>Remove the element at index from vector, shifting all elements after it to the left.
This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-remove-nth-vec [1 2 3])
(test::assert-equal [1 2 3] test-remove-nth-vec)
(vec-remove! test-remove-nth-vec 1)
(test::assert-equal [1 3] test-remove-nth-vec)
(vec-remove! test-remove-nth-vec 1)
(test::assert-equal [1] test-remove-nth-vec)
(vec-remove! test-remove-nth-vec 0)
(test::assert-equal [] test-remove-nth-vec)
</code></pre>
<h3 id="vec-slice"><a class="header" href="#vec-slice">vec-slice</a></h3>
<p><strong>Usage:</strong> (vec-slice vector start end)</p>
<p><strong>Namespace:</strong> root</p>
<p>Returns a slice of a vector (0 based indexes, end is exclusive).</p>
<p>Example:</p>
<pre><code>(test::assert-equal [5 6] (vec-slice [1 2 3 4 5 6] 4 6))
(test::assert-equal [1 2 3] (vec-slice [1 2 3 4 5 6] 0 3))
(test::assert-equal [3 4 5] (vec-slice [1 2 3 4 5 6] 2 5))
(test::assert-equal [3 4 5 6] (vec-slice [1 2 3 4 5 6] 2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-forms"><a class="header" href="#user-forms">User Forms</a></h1>
<p>When built locally (see doc/README.md) the mdbook generator has access to the user's
slosh environment. This enables creating documentation in md form of all user defined
functions. The user's init.slosh is automatically loaded, so any additional files it
loads are also imported. If the user needs to alter the slosh load path or add
additional files to be loaded (presumably because they aren't imported in init.slosh
or any slosh file it imports) it can be done by adding the paths in the <code>user-doc-files</code>
and <code>user-doc-load-paths</code> string arrays in doc/book.toml. The default is to use
<code>~/.config/slosh/</code> as the load path and <code>~/.config/slosh/init.slosh</code> for the rc file.</p>
<p>List of sections:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracking-function-parity-between-sl-sh-and-slosh"><a class="header" href="#tracking-function-parity-between-sl-sh-and-slosh">tracking function Parity Between sl-sh and slosh</a></h1>
<h2 id="forms-yet-to-be-implemented-248"><a class="header" href="#forms-yet-to-be-implemented-248">Forms yet to be implemented: 248</a></h2>
<h2 id="forms-implemented-or-skipped-273"><a class="header" href="#forms-implemented-or-skipped-273">Forms implemented or skipped: 273</a></h2>
<div class="table-wrapper"><table><thead><tr><th>?</th><th>Slosh Form</th><th>Notes</th></tr></thead><tbody>
<tr><td>✅</td><td><code>%                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>*                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>*active-ns*                     </code></td><td>Renamed to: <code>*ns*</code></td></tr>
<tr><td>✅</td><td><code>*bg-black*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-blue*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-cyan*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-default*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-green*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-magenta*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-red*                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-white*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-yellow*                     </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*collection-src*                </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*core-src*                      </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>*euid*                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>*euler*                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-black*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-blue*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-cyan*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-default*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-green*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-magenta*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-red*                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-white*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-yellow*                     </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*getopts-log*                   </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*getopts-src*                   </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*iterator-src*                  </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>*last-command*                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>*last-status*                   </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*lib-src*                       </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>*load-path*                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>*ns*                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*ns-exports*                    </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>*pi*                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*read-table*                    </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*read-table-terminal*           </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>*repl-settings*                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>*run-script*                    </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*seq-src*                       </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*shell-read-src*                </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*shell-src*                     </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*slsh-std-src*                  </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*slshrc-src*                    </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>*std-lib-exported-syms-hash*    </code></td><td></td></tr>
<tr><td>❌</td><td><code>*std-lib-namespaces*            </code></td><td></td></tr>
<tr><td>❌</td><td><code>*std-lib-syms-hash*             </code></td><td></td></tr>
<tr><td>❌</td><td><code>*stderr*                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>*stdin*                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>*stdout*                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>*string-read-table*             </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*struct-src*                    </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*test-src*                      </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>*uid*                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>=+                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>-                               </code></td><td></td></tr>
<tr><td>❌</td><td><code>-&gt;                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>-&gt;&gt;                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>/                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>2pow                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>&lt;                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>&lt;=                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>=                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>&gt;                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>&gt;=                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>^ns-stack-xyz^                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>__prompt                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>abs                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>alias                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>alias?                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>and                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>and-let*                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>append                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>append-iter                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>append-to!                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>apply                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>apply-defaults                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>arccos                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>arcsin                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>arctan                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>args                            </code></td><td>Renamed to: <code>*args*</code></td></tr>
<tr><td>❌</td><td><code>arity-zero-can-not-be-required  </code></td><td></td></tr>
<tr><td>✅</td><td><code>assert-equal                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>assert-error                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>assert-error-msg                </code></td><td></td></tr>
<tr><td>✅</td><td><code>assert-false                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-includes                 </code></td><td></td></tr>
<tr><td>✅</td><td><code>assert-not-equal                </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-not-includes             </code></td><td></td></tr>
<tr><td>✅</td><td><code>assert-true                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>back-quote                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>bg                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>bg-color-rgb                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>block                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>boolean?                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>builtin?                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>butlast                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>caaar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>caadr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>caar                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>cadar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cadddr                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>caddr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cadr                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>callable?                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>car                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>cd                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdaar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdadr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdar                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>cddar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdddr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cddr                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>cdr                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>ceil                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>chain                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>chain-and                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>chain-when                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>char-&gt;int                       </code></td><td>Renamed to: <code>-&gt;int</code></td></tr>
<tr><td>✅</td><td><code>char-lower                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>char-upper                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>char-whitespace?                </code></td><td></td></tr>
<tr><td>✅</td><td><code>char?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>check                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>check-custom                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>clear-dirs                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>close                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>codepoints                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>collate-fs-changes              </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect-copy                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect-str                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect-vec                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>cond                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>consume-comment                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>consume-whitespace              </code></td><td></td></tr>
<tr><td>✅</td><td><code>cos                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>dec!                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>def                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>def?                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>defmacro                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>defn                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>defstruct                       </code></td><td>Will consider other implementations if struct-like functionality if desired.</td></tr>
<tr><td>☑️</td><td><code>deftrait                        </code></td><td>Will consider other implementations if trait-like functionality is desired.</td></tr>
<tr><td>❌</td><td><code>dirs                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>do                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>do-unstr                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>doc                             </code></td><td></td></tr>
<tr><td>☑️</td><td><code>doc-raw                         </code></td><td>Possible now with command: (get-prop 'symbol :doc-string)</td></tr>
<tr><td>✅</td><td><code>dotimes                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>dotimes-i                       </code></td><td></td></tr>
<tr><td>☑️</td><td><code>double-ended-iter?              </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>double-ended-iterator           </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>dyn                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>empty-seq?                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>empty?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>enforce-constrains              </code></td><td></td></tr>
<tr><td>❌</td><td><code>epoch                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>eprint                          </code></td><td>Renamed to: <code>epr</code></td></tr>
<tr><td>✅</td><td><code>eprintln                        </code></td><td>Renamed to: <code>eprn</code></td></tr>
<tr><td>✅</td><td><code>err                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>err&gt;                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>err&gt;&gt;                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>err&gt;null                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>error-stack-off                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>error-stack-on                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>eval                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>exit                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>exp                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-brace                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-dollar                   </code></td><td></td></tr>
<tr><td>✅</td><td><code>expand-macro                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-macro-all                </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-macro1                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-tilde                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>export                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>false?                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>falsey?                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>fc                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>fg                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>fg-color-rgb                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>file-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>file?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>filter                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>filter-iter                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>find-symbol                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>first                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>first-quartile                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>fix-one-arg-bindings            </code></td><td></td></tr>
<tr><td>❌</td><td><code>flatten-args                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>float-&gt;int                      </code></td><td>Renamed to: <code>-&gt;int</code></td></tr>
<tr><td>✅</td><td><code>float?                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>floor                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>flush                           </code></td><td>Renamed to: <code>fflush</code></td></tr>
<tr><td>✅</td><td><code>fn                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>fn-to-predicate                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>fncall                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>for                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>for-i                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>fork                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>format                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>fract                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-accessed                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-base                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-crawl                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-dir?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-exists?                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-file?                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-len                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-modified                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>fs-notify                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-parent                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-rm                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-same?                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>func?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>gensym                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-arity                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-dirs                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-env                         </code></td><td>Renamed to: <code>env</code></td></tr>
<tr><td>✅</td><td><code>get-error                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-home                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-next-params                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-pid                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-rgb-seq                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-temp                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-temp-file                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>get_pwd                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-bad-first-arg           </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-bad-option-arity        </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-help                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-help--options-map-is-map</code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-illegal-option          </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-invalid-type-function   </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-options-map-is-map      </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-type-error-message      </code></td><td></td></tr>
<tr><td>✅</td><td><code>glob                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>handle-last-command             </code></td><td></td></tr>
<tr><td>❌</td><td><code>handle-process                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>hash-clear!                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>hash-get                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>hash-haskey                     </code></td><td>Renamed to: <code>hash-haskey?</code></td></tr>
<tr><td>✅</td><td><code>hash-keys                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>hash-remove!                    </code></td><td></td></tr>
<tr><td>☑️</td><td><code>hash-set!                       </code></td><td>(set! my-set.key "value")</td></tr>
<tr><td>✅</td><td><code>hash?                           </code></td><td>Renamed to: <code>hash-set?</code></td></tr>
<tr><td>❌</td><td><code>history-context                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-empty?                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-length                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-nth                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-push                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-push-throwaway          </code></td><td></td></tr>
<tr><td>✅</td><td><code>identity                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>if                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>import                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>in?                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>inc!                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>int-&gt;float                      </code></td><td>Renamed to: <code>-&gt;float</code></td></tr>
<tr><td>✅</td><td><code>int?                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>interleave                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>interleave-iter                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>intern-stats                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-getopts-option-string        </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-multi-char-arg               </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-multi-single-char-args       </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-single-char-arg              </code></td><td></td></tr>
<tr><td>✅</td><td><code>iter                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>iter-or-single                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>iter?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>iterator                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>jobs                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>join                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>lambda?                         </code></td><td>Renamed to: <code>callable?</code></td></tr>
<tr><td>✅</td><td><code>last                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>len0?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>len&gt;0?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>length                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>let                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>let*                            </code></td><td>Renamed to: <code>let</code></td></tr>
<tr><td>❌</td><td><code>let-env                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>list                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>list-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>list-vec?                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>list?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>lists=                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>lne                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>load                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>log                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>log2                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>logger                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>loop                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>macro                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>macro?                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>make-hash                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>make-hash-with-keys             </code></td><td></td></tr>
<tr><td>❌</td><td><code>make-regex                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>make-vec                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>map                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>map-iter                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>match                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>max                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>maybe-docstring?                </code></td><td></td></tr>
<tr><td>❌</td><td><code>maybe-glob?                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>mean                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>median                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>meld                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>meld-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-add-tags                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-column-no                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-file-name                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-line-no                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-tag?                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>method                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>min                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>mkli                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>mode                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>next!                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>nil?                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>non-empty-seq?                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>none?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>not                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>ns-auto-export                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>ns-create                       </code></td><td>Renamed to: <code>with-ns</code></td></tr>
<tr><td>✅</td><td><code>ns-enter                        </code></td><td>Renamed to: <code>ns</code></td></tr>
<tr><td>❌</td><td><code>ns-exists?                      </code></td><td></td></tr>
<tr><td>☑️</td><td><code>ns-export                       </code></td><td>Everything in slosh is exported by default.</td></tr>
<tr><td>✅</td><td><code>ns-import                       </code></td><td>Renamed to: <code>import</code></td></tr>
<tr><td>✅</td><td><code>ns-list                         </code></td><td>Renamed to: <code>get-namespaces</code></td></tr>
<tr><td>☑️</td><td><code>ns-pop                          </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>ns-push                         </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>ns-symbols                      </code></td><td>Renamed to: <code>get-in-namespace</code></td></tr>
<tr><td>✅</td><td><code>nsubstitute!                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>nth                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>null                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>nyi                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>occurs                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>open                            </code></td><td>Renamed to: <code>fopen</code></td></tr>
<tr><td>✅</td><td><code>or                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>out-err&gt;                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>out-err&gt;&gt;                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>out-err&gt;null                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>out&gt;                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>out&gt;&gt;                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>out&gt;null                        </code></td><td></td></tr>
<tr><td>☑️</td><td><code>pair=                           </code></td><td>Do not need separate equals specifier for pair.</td></tr>
<tr><td>✅</td><td><code>pair?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>path_list_trunc                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>pid                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>pipe                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>pipe-err                        </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>popd                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>pow                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>print                           </code></td><td>Renamed to: <code>pr</code></td></tr>
<tr><td>☑️</td><td><code>print-error                     </code></td><td>Now one drops in to the debugger when an error occurs.</td></tr>
<tr><td>✅</td><td><code>println                         </code></td><td>Renamed to: <code>prn</code></td></tr>
<tr><td>✅</td><td><code>probool                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>process?                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>prompt                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>pushd                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>qsort                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>quote                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>random                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>random-str                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>range                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>range-iter                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-color                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-find                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-find-all                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-match                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-replace                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>read                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>read-all                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>read-line                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-list                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-string                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-var                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-var-bracket                </code></td><td></td></tr>
<tr><td>❌</td><td><code>reader-macro-dot                </code></td><td></td></tr>
<tr><td>❌</td><td><code>reap-jobs                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>recur                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&amp;&gt;                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&amp;&gt;&gt;                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir2&gt;                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir2&gt;&gt;                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&gt;                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&gt;&gt;                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>reduce                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>reduce-times                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>ref                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>regex?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>register-alias                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>repeat                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>repeat-iter                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>repl                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>repl-eof                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>repl-line                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>required-argument               </code></td><td></td></tr>
<tr><td>✅</td><td><code>rest                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>return-from                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>reverse                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>reverse-iter                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>rm-esc                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>round                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-bg-first                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-bg-prep-args                </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-example                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-ns-example                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>seq-for                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>seq?                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>set!                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>set-dirs-max                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>set_prompt_tail                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>setnth!                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>setup-chainer                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>shell-read                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>shell-read-int                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>sin                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>single-iter                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>sleep                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>slice                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>slice-iter                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>some?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>sqrt                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>std-dev                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>str                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-&gt;float                      </code></td><td>Renamed to: <code>-&gt;float</code></td></tr>
<tr><td>✅</td><td><code>str-&gt;int                        </code></td><td>Renamed to: <code>-&gt;int</code></td></tr>
<tr><td>✅</td><td><code>str-append                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-bytes                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-cat-list                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-clear!                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-contains                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-empty?                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-empty?                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-next!                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-peek                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-start                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-lower                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-ltrim                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-map                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-nth                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-push!                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-replace                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-rsplit                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-rsplitn                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-rtrim                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-split                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-splitn                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-starts-with                 </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-sub                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-trim                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-upper                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>string-iter                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>string?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>substitute                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>summary-stats                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>supported-types-map             </code></td><td></td></tr>
<tr><td>❌</td><td><code>sym                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>sym-&gt;str                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>symbol?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>syntax-off                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>syntax-on                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>sys-apply                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>sys-command?                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>syscall                         </code></td><td>Renamed to: <code>sh</code></td></tr>
<tr><td>❌</td><td><code>take                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>take-iter                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>tan                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>temp-dir                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>third-quartile                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>time                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>timer                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>to-degrees                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>to-radians                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-default-color               </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-invalid-color               </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-slsh-fcn-color              </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-slsh-form-color             </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-string-color                </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-sys-alias-color             </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-sys-command-color           </code></td><td></td></tr>
<tr><td>❌</td><td><code>token-delim                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>true?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>type                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>umask                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>unalias                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>undef                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>unexport                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>unregister-alias                </code></td><td></td></tr>
<tr><td>❌</td><td><code>unwind-protect                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>valid-first-arg?                </code></td><td></td></tr>
<tr><td>❌</td><td><code>values                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>values-length                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>values-nth                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>values?                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>var                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>var-or-env                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-clear!                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-empty?                      </code></td><td>Renamed to: <code>empty?</code></td></tr>
<tr><td>✅</td><td><code>vec-insert!                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-iter                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-nth                         </code></td><td>Renamed to: <code>get</code></td></tr>
<tr><td>✅</td><td><code>vec-pop!                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-push!                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-remove!                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-set!                        </code></td><td>Renamed to: <code>set!</code></td></tr>
<tr><td>✅</td><td><code>vec-slice                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec?                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>verify-all-options-valid        </code></td><td>Leftover from getopts implementation.</td></tr>
<tr><td>☑️</td><td><code>verify-arity                    </code></td><td>Leftover from getopts implementation.</td></tr>
<tr><td>❌</td><td><code>version                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>wait                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>when                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>with-padding                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>with-temp                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>with-temp-file                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>write-line                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>write-string                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>xar!                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>xdr!                            </code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p>[Slosh Rust Docs]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[All Rust Docs]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[Legacy sl-sh Documentation]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
