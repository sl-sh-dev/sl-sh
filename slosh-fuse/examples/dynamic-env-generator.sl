#!/usr/bin/env slosh

;; Dynamic Environment File Generator
;; A practical implementation that generates env files based on slosh expressions

(def *env-expressions* (hash))

(defn register-env-file [path expr-fn]
  "Register an environment file path with a function that generates its content"
  (hash-set! *env-expressions* path expr-fn))

(defn generate-env-file [path]
  "Generate the environment file by evaluating its registered expression"
  (if-let [expr-fn (hash-get *env-expressions* path)]
    (let [content (expr-fn)
          file (open path :create :truncate)]
      (write-string file content)
      (close file)
      (println "Generated" path))
    (println "No expression registered for" path)))

(defn generate-all-env-files []
  "Generate all registered environment files"
  (doseq [[path _] *env-expressions*]
    (generate-env-file path)))

;; Example: Register systemd environment files

;; Define some global configuration
(def *app-config* 
  {:environment "production"
   :version "1.0.0"
   :debug false})

;; Register my-service.env
(register-env-file "/tmp/my-service.env"
  (fn []
    (str "# Generated by slosh at " (current-time-millis) "\n"
         "HOST=" (or (env "HOSTNAME") "meow") "\n"
         "CUSTOM_TYPE=" (:environment *app-config*) "\n"
         "APP_VERSION=" (:version *app-config*) "\n"
         "DEBUG=" (if (:debug *app-config*) "true" "false") "\n"
         "USER=" (env "USER") "\n"
         "PATH=" (env "PATH") "\n")))

;; Register database.env
(register-env-file "/tmp/database.env"
  (fn []
    (str "# Database configuration\n"
         "DB_HOST=" (if (= (:environment *app-config*) "production") 
                      "prod-db.example.com" 
                      "localhost") "\n"
         "DB_PORT=5432\n"
         "DB_NAME=" (:environment *app-config*) "_db\n"
         "DB_USER=" (env "USER") "_app\n"
         "DB_POOL_SIZE=" (if (= (:environment *app-config*) "production") "20" "5") "\n")))

;; Generate the files
(println "Generating environment files with current configuration:")
(println "*app-config*:" *app-config*)
(generate-all-env-files)

;; Show the generated content
(println "\n--- Generated my-service.env ---")
(let [file (open "/tmp/my-service.env" :read)]
  (println (read-string file 10000))
  (close file))

(println "--- Generated database.env ---")  
(let [file (open "/tmp/database.env" :read)]
  (println (read-string file 10000))
  (close file))

;; Demonstrate dynamic updates
(println "\n--- Updating configuration to development ---")
(set! *app-config* (assoc *app-config* 
                     :environment "development"
                     :debug true))

(generate-all-env-files)

(println "\n--- Updated my-service.env ---")
(let [file (open "/tmp/my-service.env" :read)]
  (println (read-string file 10000))
  (close file))

(println "--- Updated database.env ---")
(let [file (open "/tmp/database.env" :read)]
  (println (read-string file 10000))
  (close file))

;; Create a watcher function that regenerates files when config changes
(defn watch-and-regenerate [check-interval-ms]
  "Watch for config changes and regenerate files"
  (let [last-config (atom *app-config*)]
    (fork
      (loop []
        (when (not= @last-config *app-config*)
          (println "Configuration changed, regenerating files...")
          (generate-all-env-files)
          (reset! last-config *app-config*))
        (sleep check-interval-ms)
        (recur)))))

(println "\n--- Starting config watcher ---")
(def watcher (watch-and-regenerate 1000))
(println "Watcher started, will check for config changes every second")
(println "Try changing *app-config* and the files will auto-regenerate!")
(println "Stop watcher with: (kill" (pid watcher) "9)")