# Slosh FUSE Integration

This module provides FUSE (Filesystem in Userspace) integration for slosh, allowing you to create dynamic files whose contents are generated by evaluating slosh expressions.

## Use Case

The primary use case is creating dynamic configuration files for services like systemd, where environment files need to contain values from slosh variables, environment variables, or computed values.

For example, a systemd service file at `~/.config/systemd/user/my-service.env` could dynamically generate content like:

```bash
HOST=meow
CUSTOM_TYPE=value-of-global
```

Where `meow` is the hostname and `value-of-global` comes from a slosh global variable.

## Architecture

The implementation consists of:

1. **slosh-fuse crate**: Implements the FUSE filesystem that serves dynamic files
2. **Builtin functions**: Slosh functions to mount/unmount filesystems and register files
3. **Expression evaluation**: Files contain slosh expressions that are evaluated on read

## Usage

```lisp
;; Mount a dynamic filesystem
(def mount-id (mount-eval-fs "/tmp/dynamic"))

;; Register a file with dynamic content
(register-eval-file mount-id "config.env"
  "(str \"HOST=\" (hostname) \"\\n\"
        \"TYPE=\" *my-global-var* \"\\n\")")

;; The file /tmp/dynamic/config.env will now return evaluated content when read

;; Unmount when done
(unmount-eval-fs mount-id)
```

## Implementation Status

The current implementation provides:
- Basic FUSE filesystem structure
- File registration and mapping system
- Builtin functions for mounting and file management
- Example scripts demonstrating the concept

Full FUSE integration with expression evaluation requires:
- Process forking and IPC for evaluation
- FUSE mount/unmount handling
- Security considerations for file access

## Alternative Approach

For simpler use cases, the `dynamic-env-generator.sl` example shows how to achieve similar functionality without FUSE by:
- Registering file paths with generator functions
- Periodically regenerating files when configuration changes
- Using standard file I/O operations

This approach is simpler to implement and doesn't require FUSE support.