#%
Usage: (nil? value) => boolean

Test whether a value is nil.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is nil, false otherwise.

Section: type

Example:
(test::assert-true (nil? ()))
(test::assert-true (nil? '()))
(test::assert-true (nil? nil))
(test::assert-true (nil? (list)))
(test::assert-false (nil? #f))
%#
(def nil? (fn (v) (identical? (type v) :Nil)))

#%
Usage: (char? value) => boolean

Test whether a value is a character.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a character, false otherwise.

Section: type

Example:
(test::assert-true (char? \\a))
(test::assert-false (char? 1))
(test::assert-false (char? "a"))
%#
(def char? (fn (v) (identical? (type v) :Char)))

#%
Usage: (pair? value) => boolean

Test whether a value is a pair.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a pair, false otherwise.

Section: type

Example:
(test::assert-true (pair? '(1 . 2)) "reader macro")
(test::assert-true (pair? (cons 1 2)) "cons")
(test::assert-true (pair? '(1 2)))
(test::assert-false (pair? 1))
(test::assert-false (pair? [1 2 3]))
(test::assert-false (pair? (vec)))
%#
(def pair? (fn (v) (identical? (type v) :Pair)))

#%
Usage: (string? value) => boolean

Test whether a value is a string.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a string, false otherwise.

Section: type

Example:
(test::assert-true (string? "string"))
(test::assert-false (string? 1))
%#
(def string? (fn (v) (identical? (type v) :String)))

#%
Usage: (symbol? value) => boolean

Test whether a value is a symbol.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a symbol, false otherwise.

Section: type

Example:
(test::assert-true (symbol? 'symbol))
(test::assert-false (symbol? 1))
%#
(def symbol? (fn (v) (identical? (type v) :Symbol)))

#%
Usage: (vec? value) => boolean

Test whether a value is a vector.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a vector, false otherwise.

Section: type

Example:
(test::assert-true (vec? [1 2 3]) "reader macro")
(test::assert-true (vec? (make-vec)) "make-vec")
(test::assert-true (vec? (vec 1 2 3)) "vec")
(test::assert-false (vec? 1))
(test::assert-false (vec? '(1 2 3)))
(test::assert-false (vec? (list)))
%#
(def vec? (fn (v) (identical? (type v) :Vector)))

#%
Usage: (list? value) => boolean

Test whether a value is a proper list.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a proper list, false otherwise.

Section: type

Example:
(test::assert-true (list? '(1 2 3)) "reader macro")
(test::assert-true (list? (list 1 2 3)) "list")
(test::assert-false (list? 1))
(test::assert-false (list? [1 2 3]))
(test::assert-false (list? []))
(test::assert-false (list? '(1 . 2)))
%#
(def list? (fn (v) (if (or (nil? v)(pair? v))(if (nil? (cdr v)) #t (recur (cdr v))) #f)))

#%
Usage: (seq? value) => boolean

Test whether a value is a sequence (list or vector).

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is a list or vector, false otherwise.

Section: type

Example:
(test::assert-true (seq? '(1 2 3)))
(test::assert-true (seq? [1 2 3]))
(test::assert-true (seq? []))
(test::assert-false (seq? "aaa"))
(test::assert-false (seq? 1))
%#
(def seq? (fn (v) (or (pair? v)(vec? v))))

#%
Usage: (empty? sequence) => boolean

Test whether a sequence has zero length.

Arguments:
- sequence: A sequence. The collection to test (list, vector, string, etc.).
- boolean: A boolean. True if sequence is empty, false otherwise.

Section: collection

Example:
(test::assert-true (empty? nil))
(test::assert-true (empty? []))
(test::assert-false (empty? [1]))
%#
(def empty? (fn (v) (= (len v) 0)))

#%
Usage: (not-empty? sequence) => boolean

Test whether a sequence has non-zero length.

Arguments:
- sequence: A sequence. The collection to test (list, vector, string, etc.).
- boolean: A boolean. True if sequence is not empty, false otherwise.

Section: collection

Example:
(test::assert-false (empty? nil))
(test::assert-false (empty? []))
(test::assert-true (empty? [1]))
%#
(def not-empty? (fn (v) (> (len v) 0)))

#%
Usage: (callable? value) => boolean

Test whether a value can be called as a function.

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value can be called (function, macro, etc.), false otherwise.

Section: type
%#
(def callable? (fn (v) (let (t (type v))(or (identical? t :Lambda)
                                             (identical? t :Continuation)
                                             (identical? t :Special)
                                             (identical? t :Builtin)
                                             (identical? t :Map)
                                             (identical? t :Vector)
                                             (identical? t :Pair)))))

#%
Usage: (io? value) => boolean

Test whether a value is an I/O object (file handle).

Arguments:
- value: Any type. The value to test.
- boolean: A boolean. True if value is an I/O object, false otherwise.

Section: type

Example:
(def iotst (fopen "/tmp/iotst" :create))
(test::assert-true (io? iotst))
(test::assert-false (io? 1))
(test::assert-false (io? '(1 2 3)))
(test::assert-false (io? (list)))
%#
(def io? (fn (v) (identical? (type v) :Io)))

#%
Usage: (defmacro name arguments & body) => nil

Define a macro and bind it to a symbol.

Arguments:
- name: A symbol. The name of the macro.
- arguments: A list. The parameter list for the macro.
- body: Forms. The macro expansion template.
- nil: Always returns nil.

Section: core

Example:
(defmacro test-mac (x) `(inc! ~x))
(def test-mac-x 2)
(test-mac test-mac-x)
(test::assert-equal 3 test-mac-x)
(defmacro test-mac (x) `(set! ~x 15))
(test-mac test-mac-x)
(test::assert-equal 15 test-mac-x)
%#
(comp-time (def defmacro
  (macro (name args & body)
      `(comp-time (def ~name (macro ~args ~@body))nil))) nil)

#%
Usage: (get-error & expressions) => pair

Evaluate expressions and capture any errors.

Arguments:
- expressions: Forms. One or more expressions to evaluate.
- pair: A pair. Either (:ok . result) or (:error . error-info).

Evaluates each form in sequence. On error returns (:error msg backtrace) instead of aborting.
On success returns (:ok . last-result). Always returns a pair with car being :ok or :error.

Section: core

Example:
(let (get-error-t1 (get-error (err (mk-err :string (str "Some Error")))))
    (test::assert-equal :error (car get-error-t1))
    (test::assert-equal "error [string]: \\"Some Error\\"" (str (cdr get-error-t1))))
(test::assert-equal "Some String" (get-error \"Some String\"))
(test::assert-equal "Some Other String" (get-error (let (test-get-error \"Some \") (str test-get-error \"Other String\"))))
%#
(defmacro get-error (& body)
    (let (old-error (gensym))
    `(let (~old-error (on-raised-error nil))
        (defer (on-raised-error ~old-error))
        (call/cc (fn (k)
                     (on-raised-error k)
                     ~@body)))))


#%
Usage: (block & body) => result

Create a block that can be exited early with return-from.

Arguments:
- body: Forms. The expressions to evaluate in the block.
- result: Any type. The result of the last expression or return-from value.

Section: core
%#
(defmacro block (& body)
    `(call/cc (fn (return-from) ~@body)))

#%
Usage: (defn name arguments & body) => nil

Define a named function in the current namespace.

Arguments:
- name: A symbol. The name of the function.
- arguments: A list. The parameter list for the function.
- body: Forms. The function body expressions.
- nil: Always returns nil.

Section: core

Example:
(defn defn-test (x y) (+ x y))
(test::assert-equal 5 (defn-test 2 3))
(defn defn-test (x y) (set! x (* x 2)) (+ x y))
(test::assert-equal 7 (defn-test 2 3))
(defn defn-test (x y) nil)
(test::assert-false (defn-test 2 3))
(defn defn-test (x y) #t)
(test::assert-true (defn-test 2 3))
%#
(defmacro defn
    (name args & body)
        `(def ~name (fn ~args ~@body)))

#%
Binds bindings to parameters in body. Use recur with desired bindings for
subsequent iteration.
Within the loop the lambda 'break' will end the loop, break can take an option
argument that is what the loop produces (nil if no argument).

Section: core

Example:
(def tot 0)
(loop (idx) (3) (do
    (set! tot (+ tot 1))
    (if (> idx 1) (recur (- idx 1)))))
(test::assert-equal 3 tot)
(def tot 0)
(loop (idx) (0)
    (set! tot (+ tot 1))
    (when (not (= idx 2))
        (recur (+ idx 1))))
(test::assert-equal 3 tot)
(test::assert-equal 11 (loop (idx) (0)
    (if (= idx 2) (break 11))
    (recur (+ idx 1))))
(test::assert-false (loop (idx) (0)
    (if (= idx 2) (break nil))
    (recur (+ idx 1))))
(test::assert-error (loop (idx) (0)
    (if (= idx 2) (break 1 3))
    (recur (+ idx 1))))
%#
(defmacro loop
  (params bindings & body)
    `(call/cc (fn (break) ((fn ~params ~@body) ~@bindings))))

#%
Return the documentation for provided symbol as a string.

Section: core
%#
(defmacro doc-raw (sym)
    (let (docs `(eval (get-prop ~sym :doc-string))
         has-usage `(str-starts-with (str-trim (str ~docs)) "Usage:"))
        (do
        `(if ~has-usage
          (str ~docs)
          (str (usage ~sym) "\n\n" ~docs)))))

#%
Print the documentation for provided symbol.

Section: core
%#
(defn doc (sym)
    (prn (doc-raw sym)))

#%
Evaluate body a number of times equal to times' numerical value.

Section: core

Example:
(def i 0)
(dotimes 11 (set! i (+ 1 i)))
(test::assert-equal 11 i)
%#
(defmacro dotimes
    (times & body)
    (let (i-name (gensym))
    `(let (~i-name 0)
        (while (< ~i-name ~times)
            ~@body
            (inc! ~i-name)))))

#%
Evaluate body a number of times equal to times' numerical value. Includes an
incrementing reference binding, idx-bind, accessible in body.

Section: core

Example:
(def i 0)
(def i-tot 0)
(dotimes-i idx 11 (do (set! i-tot (+ idx i-tot))(set! i (+ 1 i))))
(test::assert-equal 11 i)
(test::assert-equal 55 i-tot)
%#
(defmacro dotimes-i
    (idx-bind times & body)
    `(let (~idx-bind 0)
        (while (< ~idx-bind ~times)
            ~@body
            (inc! ~idx-bind))))


#%
Usage: (when condition body) => result-or-nil

Evaluate body only if condition is true.

Arguments:
- condition: Any type. The condition to test.
- body: A form. The expression to evaluate if condition is true.
- result-or-nil: Any type. The result of body if condition is true, nil otherwise.

Section: conditional

Example:

(test::assert-true (when #t #t))
(test::assert-false (when #t nil))
(test::assert-false (when nil nil))
%#
(defmacro when
    (provided-condition if-true)
    `(if ~provided-condition ~if-true))

#%
Usage: (dyn symbol value & body) => result

Create a dynamic binding and evaluate body.

Arguments:
- symbol: A symbol. The variable to dynamically bind (not evaluated).
- value: Any type. The value to bind to the symbol.
- body: Forms. The expressions to evaluate with the binding.
- result: Any type. The result of the last expression in body.

The binding is restored to its previous value when the dyn form exits.
Calls to dyn can be nested and previous values are properly restored.

Section: core

Example:
(def *dyn-test* 1)
(defn test-dyn-fn (val) (str *dyn-test* val))
(def out (dyn *dyn-test* 11 (test-dyn-fn 101)))
(test::assert-equal "11101" (str out))
;; when file handling works
;;(defn test-dyn-fn () (prn \"Print dyn out\"))
;;(dyn *stdout* (open \"/tmp/sl-sh.dyn.test\" :create :truncate) (test-dyn-fn))
;;(test::assert-equal \"Print dyn out\" (read-line (open \"/tmp/sl-sh.dyn.test\" :read)))
%#
(defmacro dyn
  (key value & expression)
  (let (old-val (gensym))
    `(let (~old-val ~key)
      (defer (set! ~key ~old-val))
      (do (set! ~key ~value) ~@expression))))

#%
Usage: (identity value) => value

Return the argument unchanged.

Arguments:
- value: Any type. The value to return.
- value: The same value, unchanged.

Section: core

Example:

(test::assert-equal 0 (identity 0))
%#
(defn identity (x) x)

#%
Usage: (last sequence) => element-or-nil

Return the last element of a sequence.

Arguments:
- sequence: A sequence. A list or vector to get the last element from.
- element-or-nil: Any type. The last element, or nil if sequence is empty.

Section: sequence

Example:
(test::assert-equal 3 (last '(1 2 3)))
(test::assert-equal 3 (last [1 2 3]))
(test::assert-equal nil (last '()))
(test::assert-equal nil (last nil))
(test::assert-equal nil (last []))
%#
(defn last
  (obj)

  (let (last-list (fn (obj)
                       (if (nil? (cdr obj)) (car obj)
                           (recur (cdr obj)))))

    (if (vec? obj) (if (> (len obj) 0) (let (i (- (len obj) 1)) obj.~i) nil)
        (list? obj) (last-list obj)
        (err "Not a vector or list"))))

#%
Produces the provided list minus the last element.  Nil if the list is empty or one element.

Section: sequence

Example:
(test::assert-equal '(1 2) (butlast '(1 2 3)))
(test::assert-equal [1 2] (butlast [1 2 3]))
(test::assert-equal nil (butlast '(1)))
(test::assert-equal [] (butlast [1]))
(test::assert-equal nil (butlast '()))
(test::assert-equal nil (butlast nil))
(test::assert-equal nil (butlast []))
%#
(def butlast nil) ; predeclare and assign butlast to avoid a warning when used in butlast declaration.
(defn butlast
  (obj)
  (if (vec? obj) (if (> (len obj) 0) (vec-slice obj 0 (- (len obj) 1)) nil)
      (list? obj)
      (let (new-link (cons nil nil))
        (if (nil? (cdr obj))
            (set! new-link nil)
            (set! new-link (cons (car obj) (butlast (cdr obj)))))
        new-link)
      (err "Not a vector or list")))

#%
Usage: (first sequence) => object

Returns the first element of sequence, which must be a list or vector.

Arguments:
- sequence: A list or vector.
- object: The first element of sequence, or nil/[] if sequence is empty.

If sequence is a non-empty list, returns the first element (equivalent to car).
If sequence is a non-empty vector, returns the element at index 0.
If sequence is nil or an empty list, returns nil.
If sequence is an empty vector, returns an empty vector.

Section: sequence

Example:
(test::assert-equal 1 (first '(1 2 3)))
(test::assert-equal 1 (first [1 2 3]))
(test::assert-equal 'a (first '(a b c)))
(test::assert-equal nil (first '()))
(test::assert-equal nil (first nil))
(test::assert-equal [] (first []))
%#
(defn first
  (obj)
  (if (vec? obj) (if (empty? obj) obj obj.0)
      (list? obj) (car obj)
      (err (str "Not a vector or list, " (type obj)))))

#%
Usage: (rest sequence) => object

Returns a sequence of the elements of sequence except the first.

Arguments:
- sequence: A list or vector.
- object: A sequence containing all but the first element, or nil/[] if sequence has one or zero elements.

If sequence is a list with more than one element, returns the cdr of the list.
If sequence is a single-element list or nil, returns nil.
If sequence is a vector with more than one element, returns a new vector containing all elements except the first.
If sequence is a single-element or empty vector, returns an empty vector.

Section: sequence

Example:
(test::assert-equal '(2 3) (rest '(1 2 3)))
(test::assert-equal [2 3] (rest [1 2 3]))
(test::assert-equal '(b c) (rest '(a b c)))
(test::assert-equal nil (rest '(1)))
(test::assert-equal [] (rest [1]))
(test::assert-equal nil (rest '()))
(test::assert-equal nil (rest nil))
(test::assert-equal [] (rest []))
%#
(defn rest
  (obj)
  (if (vec? obj) (if (empty? obj) obj (vec-slice obj 1))
      (list? obj) (cdr obj)
      (err "Not a vector or list")))


#%
Loops over each element in a sequence.  Simple version that works with lists and
vectors, use iterator::for in general.

Section: sequence

Example:
(def i 0)
(seq-for x in '(1 2 3 4 5 6) (set! i (+ 1 i)))
(test::assert-equal 6 i)
%#
(defmacro seq-for
  (bind in items & body)
  (if (not (identical? in 'in)) (err "Invalid seq-for: (for [i] in [sequence] (body))"))
    (let (lst (gensym))
    `(let-while (~lst ~items) (~bind (first ~lst), done (empty? ~lst), ~lst (rest ~lst)) (not done) ~@body)))

#%
Usage: (match value & branches) => result

Pattern match a value against multiple cases.

Arguments:
- value: Any type. The value to match against.
- branches: Lists. Each branch is (match-value & forms).
- result: Any type. The result of the matching branch's forms, or nil.

Evaluates value once and compares against each match-value in order.
When a match is found, evaluates the corresponding forms in an implicit do.
Use nil as the match-value for a default case.

Section: conditional

Example:

(defn select-option (a)
    (match a (1 \"opt-one\")
             (2 (set! b 5) \"opt-two\")
             (3 (str \"opt\" \"-three\"))))
(defn select-option-def (a)
    (match a (1 \"opt-one\")
             (2 \"opt-two\")
             (3 (str \"opt\" \"-three\"))
             (nil \"default\")))
(def b 0)
(test::assert-equal b 0)
(test::assert-equal \"opt-one\" (select-option 1))
(test::assert-equal \"opt-two\" (select-option 2))
(test::assert-equal b 5)
(test::assert-equal \"opt-three\" (select-option 3))
(test::assert-equal #f (select-option 4))
(test::assert-equal \"opt-one\" (select-option-def 1))
(test::assert-equal \"opt-two\" (select-option-def 2))
(test::assert-equal \"opt-three\" (select-option-def 3))
(test::assert-equal \"default\" (select-option-def 4))
%#
(defmacro match
  (condition & branches)
  ((fn ()
       (let (make-action (fn (action)
                              (if (seq? action)
                                  `(do ~@action)
                                  `action))
             make-cond (fn (condition val action others)
                            (if (nil? val) (make-action action)
                                (if (empty? others) `((= ~condition ~val) ~(make-action action))
                                    `((= ~condition ~val) ~(make-action action) ~@(make-cond condition (first (first others)) (rest (first others)) (rest others))))))
             cond-name condition)
         `(if ~@(make-cond cond-name (first (first branches)) (rest (first branches)) (rest branches)))))))


#%
Usage: (cond & clauses) => result

Evaluate conditions and execute the first true branch.

Arguments:
- clauses: Lists. Each clause is (test & forms).
- result: Any type. The result of the first true branch, or nil.

Evaluates each test expression in order. When a test returns true,
evaluates the corresponding forms in an implicit do and returns the result.
Stops at the first true test. Returns nil if no tests are true.

Section: conditional

Example:

(def b 0)
(defn select-option (a)
    (cond ((= a 1) \"opt-one\")
          ((= a 2) (set! b 5) \"opt-two\")
          ((= a 3) (str \"opt\" \"-three\"))))
(defn select-option-def (a)
    (cond ((= a 1) \"opt-one\")
          ((= a 2) \"opt-two\")
          ((= a 3) (str \"opt\" \"-three\"))
          (#t \"default\")))
(test::assert-equal \"opt-one\" (select-option 1))
(test::assert-equal b 0)
(test::assert-equal \"opt-two\" (select-option 2))
(test::assert-equal b 5)
(test::assert-equal \"opt-three\" (select-option 3))
(test::assert-equal nil (select-option 4))
(test::assert-equal \"opt-one\" (select-option-def 1))
(test::assert-equal \"opt-two\" (select-option-def 2))
(test::assert-equal \"opt-three\" (select-option-def 3))
(test::assert-equal \"default\" (select-option-def 4))
%#
(defmacro cond
  (& branches)
  ((fn ()
       (let (make-action (fn (action)
                              (if (seq? action)
                                  `(do ~@action)
                                  `action))
             make-cond (fn (condition action others)
                            (if (empty? others)
                                `(~condition ~(make-action action) nil)
                                `(~condition ~(make-action action) ~@(make-cond (first (first others)) (rest (first others)) (rest others))))))
         `(if ~@(make-cond (first (first branches)) (rest (first branches)) (rest branches)))))))

#%
Usage: (when provided-condition if-true)

when is a convenience function used to check a form, provided-condition,
and run some form, if-true, if provided-condition evaluates to true.

Section: conditional

Example:
(test::assert-true (when #t #t))
(test::assert-false (when #t nil))
(test::assert-false (when nil nil))
%#

(defmacro when
    (provided-condition if-true)
    `(if ~provided-condition ~if-true))

#%
Usage: (with-temp-file function & prefix suffix length) => result

Create a temporary file and pass it to a function.

Arguments:
- function: A function. Takes one argument (the temp file path).
- prefix: A string (optional). Prefix for filename (defaults to ".tmp").
- suffix: A string (optional). Suffix for filename (defaults to empty).
- length: An integer (optional). Random character count (defaults to 5).
- result: Any type. The result of calling function.

The temporary file is automatically removed after function completes.

Section: file

Example:
(def fp nil)
(with-temp-file (fn (tmp-file)
    (let (a-file (fopen tmp-file :create :truncate))
        (test::assert-true (fs-exists? tmp-file))
        (set! fp tmp-file)
        (fclose a-file))))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix")))
    "some-prefix")

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix")))
    "some-prefix"
    "some-suffix")

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix"))
        (test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp))))
    "some-prefix"
    "some-suffix"
    10)
%#
(defn with-temp-file (func & args)
    (let (file-name (apply get-temp-file (temp-dir) args))
        (defer (fs-rm file-name))
        (func file-name)))

#%
Usage: (with-temp function & prefix suffix length) => result

Create a temporary directory and pass it to a function.

Arguments:
- function: A function. Takes one argument (the temp directory path).
- prefix: A string (optional). Prefix for dirname (defaults to ".tmp").
- suffix: A string (optional). Suffix for dirname (defaults to empty).
- length: An integer (optional). Random character count (defaults to 5).
- result: Any type. The result of calling function.

The temporary directory is recursively removed after function completes.

Section: file

Example:
(def fp nil)
(with-temp (fn (tmp-dir)
    (let (tmp-file (str tmp-dir "/sl-sh-tmp-file.txt")
         a-file (fopen tmp-file :create :truncate))
        (test::assert-true (fs-exists? tmp-file))
        (set! fp tmp-file)
        (fclose a-file))))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix")))
    "some-prefix")

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix")))
    "some-prefix"
    "some-suffix")

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix"))
        (test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp))))
    "some-prefix"
    "some-suffix"
    10)
%#
(defn with-temp (func & args)
    (let (dir (apply get-temp (temp-dir) args))
        (defer (fs-rm dir))
        (func dir)))

#%
Usage: (identity value) => value

Return the argument unchanged.

Arguments:
- value: Any type. The value to return.
- value: The same value, unchanged.

Section: core

Example:

(test::assert-equal 0 (identity 0))
%#
(defn identity (x) x)

#%
Usage: (not= value1 value2) => boolean

Test if two values are not equal.

Arguments:
- value1: Any type. First value to compare.
- value2: Any type. Second value to compare.
- boolean: A boolean. True if values are not equal (using =).

Section: core

Example:
(test::assert-true (not= 0 1))
(test::assert-true (not= 1 1.0))
(test::assert-false (not= 2 2))
(test::assert-false (not= 0.0 -0.0))
%#
(defmacro not= (expected-val right-val)
    `(not (= ~expected-val ~right-val))
)

#%
Usage: (not== value1 value2) => boolean

Test if two values are not numerically equal.

Arguments:
- value1: Any type. First value to compare.
- value2: Any type. Second value to compare.
- boolean: A boolean. True if values are not numerically equal (using ==).

Section: core

Example:
(test::assert-true (not== 0 1))
(test::assert-false (not== 1 1.0))
(test::assert-false (not== 0.0 -0.0))
(test::assert-false (not== 2 2))
%#
(defmacro not== (expected-val right-val)
    `(not (== ~expected-val ~right-val))
)

#%
Replaces all instances of old-item in lst with new-item. If last argument
passed in is keyword :first only the first instance of old-item will be
replaced.

Section: core

Example:
(let (lst (list 1 2 3 4 5))
    (test::assert-equal (list 1 2 2 4 5) (nsubstitute! lst 3 2))
    (test::assert-equal (list 1 2 2 4 5) lst)
    (test::assert-equal (list 1 3 2 4 5) (nsubstitute! lst 2 3 :first)))
%#
(defn nsubstitute!
    (lst old-item new-item & mods)
    (let (early-return (in? mods :first))
      (loop (idx items) (0 lst)
        (if (empty? items)
            lst
            (do
              (when (= (car items) old-item)
                  (do
                    (set! lst.~idx new-item)
                    (when early-return (break lst))))
              (recur (+ 1 idx) (cdr items)))))
           lst))

 #%
 Replaces all instances of old-item in copy of lst with new-item.  If last
 argument passed in is keyword :first only the first instance of old-item will be
 replaced.

 Section: core

 Example:

 (let (lst (list 1 2 3 4 3)
      olst (list 1 2 3 4 3)
       lst2 (list 1 2 3 3 3 4 5)
      olst2 (list 1 2 3 3 3 4 5))
     (test::assert-equal (list 1 2 10 4 10) (substitute lst 3 10))
     (test::assert-equal (list 1 2 10 4 3) (substitute lst 3 10 :first))
     (test::assert-equal olst lst)
     (test::assert-equal (list 1 2 4 4 4 4 5) (substitute lst2 3 4))
     (test::assert-equal (list 1 2 4 3 3 4 5) (substitute lst2 3 4 :first))
     (test::assert-equal olst2 lst2))
 %#
  (defmacro substitute (lst old-item new-item & mods)
       `(nsubstitute! (to-list ~lst) ~old-item ~new-item ~@mods))

(load "iterator.slosh")
(load "test.slosh")
